This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been formatted for parsing in plain style.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been formatted for parsing in plain style
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
User Provided Header
================================================================
THE WEAVE, by Javi Prieto@GeeseBumps

================================================================
Directory Structure
================================================================
.gitignore
.repomix/bundles.json
add_texts_comments.py
enemy_sm_removal_report.md
memory_bank/activeContext.md
memory_bank/final_state_machine_combat_plan.md
memory_bank/productContext.md
memory_bank/progress.md
memory_bank/projectBrief.md
memory_bank/systemPatterns.md
memory_bank/techContext.md
old_src/character_patterns.c
old_src/character_patterns.h
old_src/collisions.c
old_src/combat.c
old_src/counter_spell.c
old_src/counter_spell.h
old_src/enemies_patterns.c
old_src/enemies_patterns.h
old_src/pattern_types/electric_pattern.c
old_src/pattern_types/electric_pattern.h
old_src/pattern_types/enemy_bite_pattern.c
old_src/pattern_types/enemy_bite_pattern.h
old_src/pattern_types/enemy_electric_pattern.c
old_src/pattern_types/enemy_electric_pattern.h
old_src/pattern_types/hide_pattern.c
old_src/pattern_types/hide_pattern.h
old_src/pattern_types/open_pattern.c
old_src/pattern_types/open_pattern.h
old_src/pattern_types/sleep_pattern.c
old_src/pattern_types/sleep_pattern.h
old_src/patterns_registry.c
old_src/patterns_registry.h
old_src/patterns.h
old_src/statemachine.c
old_src/statemachine.h
old_src/test.h
README.md
res/Backgrounds/Act1/bedroom_daylight.pal
res/Backgrounds/Act1/bedroom_midnight.pal
res/Backgrounds/Act1/forest_dark.pal
res/Backgrounds/Act1/forest.pal
res/Backgrounds/Act1/hall.pal
res/Backgrounds/Act1/OLD_bedroom_night.pal
res/Geesebumps/pal_black.pal
res/Geesebumps/pal_lines.pal
res/Geesebumps/pal_white.pal
res/Geesebumps/pal_white2.pal
res/Geesebumps/tmp2.pal
res/res_backgrounds.h
res/res_backgrounds.res
res/res_characters.h
res/res_characters.res
res/res_enemies.h
res/res_enemies.res
res/res_faces.h
res/res_faces.res
res/res_geesebumps.h
res/res_geesebumps.res
res/res_interface.h
res/res_interface.res
res/res_intro.h
res/res_intro.res
res/res_items.h
res/res_items.res
res/res_sound.h
res/res_sound.res
res/resources.h
res/resources.res
res/Sound/Effects/source.txt
res/Sprites/Characters/characters.pal
src/act_1.c
src/act_1.h
src/background.c
src/background.h
src/boot/rom_head.c
src/boot/sega.s
src/characters.c
src/characters.h
src/collisions.c
src/collisions.h
src/combat.c
src/combat.h
src/controller.c
src/controller.h
src/dialogs.c
src/dialogs.h
src/enemies.c
src/enemies.h
src/entity.c
src/entity.h
src/geesebumps.c
src/geesebumps.h
src/globals.c
src/globals.h
src/init.c
src/init.h
src/interface.c
src/interface.h
src/intro.c
src/intro.h
src/items.c
src/items.h
src/main.c
src/patterns.c
src/patterns.h
src/patterns/pattern_en_bite.c
src/patterns/pattern_en_bite.h
src/patterns/pattern_en_thunder.c
src/patterns/pattern_en_thunder.h
src/patterns/pattern_hide.c
src/patterns/pattern_hide.h
src/patterns/pattern_open.c
src/patterns/pattern_open.h
src/patterns/pattern_sleep.c
src/patterns/pattern_sleep.h
src/patterns/pattern_thunder.c
src/patterns/pattern_thunder.h
src/sound.c
src/sound.h
src/texts.c
src/texts.h

================================================================
Files
================================================================

================
File: .gitignore
================
# Windows image file caches
Thumbs.db
ehthumbs.db

# Folder config file
Desktop.ini

# Recycle Bin used on file shares
$RECYCLE.BIN/

# game/data/
.vscode
out/
sgdk/
*.bat
*.conf
*.layout
*.cbp

# Windows Installer files
*.cab
*.msi
*.msm
*.msp

# Windows shortcuts
*.lnk

# =========================
# Operating System Files
# =========================

# OSX
# =========================

.DS_Store
.AppleDouble
.LSOverride

# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

================
File: .repomix/bundles.json
================
{
  "bundles": {}
}

================
File: res/Geesebumps/pal_black.pal
================
JASC-PAL
0100
16
0 0 0
0 0 0
0 0 0
0 0 0
0 0 0
0 0 0
0 0 0
0 0 0
0 0 0
0 0 0
0 0 0
0 0 0
0 0 0
0 0 0
0 0 0
0 0 0

================
File: res/Geesebumps/pal_lines.pal
================
JASC-PAL
0100
32
0 0 0 0
34 33 33 255
64 63 61 255
65 64 63 255
99 98 96 255
129 127 124 255
133 130 126 255
91 173 163 255
122 193 177 255
164 162 159 255
194 189 183 255
156 205 188 255
199 196 190 255
180 213 200 255
223 227 222 255
0 0 0 255
0 0 0 0
210 61 68 255
212 82 84 255
211 99 93 255
214 94 97 255
214 108 108 255
237 151 58 255
237 160 61 255
235 160 86 255
244 216 117 255
215 126 129 255
228 170 162 255
245 218 159 255
245 234 218 255
0 0 0 255
0 0 0 255

================
File: res/Geesebumps/pal_white.pal
================
JASC-PAL
0100
16
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237

================
File: res/Geesebumps/pal_white2.pal
================
JASC-PAL
0100
32
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237
239 240 237

================
File: res/Geesebumps/tmp2.pal
================
JASC-PAL
0100
16
0 0 0 0
210 61 68 255
212 82 84 255
211 99 93 255
214 94 97 255
214 108 108 255
237 151 58 255
237 160 61 255
235 160 86 255
244 216 117 255
215 126 129 255
228 170 162 255
245 218 159 255
245 234 218 255
0 0 0 255
0 0 0 255

================
File: src/act_1.h
================
#ifndef _ACT1_H_
#define _ACT1_H_

void act_1_scene_1(void); // Execute the 1st scene of Act 1
void act_1_scene_2(void); // Execute the 2nd scene of Act 1
void act_1_scene_3(void); // Execute the 3nd scene of Act 1
void act_1_scene_5(void); // Execute the 5th scene of Act 1

#endif

================
File: src/background.h
================
#ifndef _BACKGROUND_H_
#define _BACKGROUND_H_

// Backgrounds
extern Map *background_BGA;
extern Map *background_BGB;
extern u32 offset_BGA;
extern u32 offset_BGB;

// Background scroll modes
extern u8 background_scroll_mode; // Scroll modes (BG_SCRL_*)
extern u8 scroll_speed; // Scroll speed (each mode uses it in a way)
extern bool player_scroll_active; // Can you scroll ?
extern u16 background_width; // Background width

#define BG_SCRL_AUTO_RIGHT   00 // background scrolls in auto mode to the right (updated every frame)
#define BG_SCRL_AUTO_LEFT    01 // background scrolls in auto mode to the left (updated every frame)
#define BG_SCRL_USER_RIGHT   10 // background scrolls as the player walks - user starts in the left, and advances to the right
#define BG_SCRL_USER_LEFT    11 // background scrolls as the player walks - user starts in the right, and advances to the left

// Screen limits
extern u16 x_limit_min; // Minimum x position (if there's scroll, player scrolls at that point)
extern u16 x_limit_max; // Maximum x position (if there's scroll, player scrolls at that point)
extern u16 y_limit_min; // Minimum y position
extern u16 y_limit_max; // Maximum y position

#define X_OUT_OF_BOUNDS 9999 // Value to return when x coordinate is out of bounds

void update_bg(bool player_moved); // Update background and do the scroll
void set_limits(u16 x_min, u16 y_min, u16 x_max, u16 y_max); // Set background limits
void scroll_background(s16 dx); // Scroll the background if the character is at the screen edge. This function is called when the character can't move but the background can scroll.
u16 get_x_in_screen(u16 x_in_background, u8 width); // Get screen X coordinate from background X coordinate

#endif

================
File: src/geesebumps.h
================
#ifndef _GBUMPS_H_
#define _GBUMPS_H_

void geesebumps_logo(void);

#endif

================
File: src/intro.h
================
#ifndef _INTRO_H_
#define _INTRO_H_

#define MAXSTARS 7

void theweave_intro(void);
void intro_update_language(void);
bool intro_read_keys(void);

#endif

================
File: enemy_sm_removal_report.md
================
# Informe definitivo – eliminación de StateMachine de enemigos

## 0. Preparación
```bash
git checkout <commit-base>
git checkout -b refactor/no-sm
```

## 1. Estructura `Enemy`
**Archivo:** `src/enemies.h`

```diff
+ typedef enum {
+     ENEMY_MODE_IDLE,
+     ENEMY_MODE_PLAY_NOTE,
+     ENEMY_MODE_CASTING,
+     ENEMY_MODE_RECOVER
+ } EnemyMode;

  typedef struct {
      ...
+     EnemyMode mode;
+     u16       mode_timer;
+
+     u8  pattern_id;     /*255 = ninguno*/
+     u8  pattern_phase;
+     u16 pattern_timer;
  } Enemy;

+ void update_enemy_logic(u16 enemy_id);
```
**🛠 Compila / prueba** — 0 errores.

## 2. IA sin SM
### 2.1 `src/enemy_logic.h`
```c
#ifndef ENEMY_LOGIC_H
#define ENEMY_LOGIC_H
void update_enemy_logic(u16 enemy_id);
#endif
```

### 2.2 `src/enemy_logic.c`
*(copiar 92 líneas de decide_next/update_enemy_logic)*

### 2.3 Makefile
```diff
 OBJS += enemy_logic.o
```
**🛠 Compila / prueba**

## 3. Retirada de `enemy_state_machines`
### 3.1
```bash
rm src/enemies_patterns.c src/enemies_patterns.h
```

### 3.2 Makefile
```diff
- OBJS += enemies_patterns.o
```

### 3.3 `src/combat.c`
```diff
- #include "enemies_patterns.h"
+ #include "enemy_logic.h"

- extern StateMachine enemy_state_machines[MAX_ENEMIES];

- StateMachine_Init(&enemy_state_machines[i], ...);
- enemy_state_machines[i].owner_type = OWNER_ENEMY;

- StateMachine_Update(&enemy_state_machines[i], NULL);
+ update_enemy_logic(i);

- StateMachine_SendMessage(&enemy_state_machines[...]
- enemy_state_machines[...].current_state = ...
```

### 3.4 `src/counter_spell.c`
```diff
- execute_counter_spell(StateMachine* player_sm, StateMachine* enemy_sm, u16 pattern_id)
+ execute_counter_spell(StateMachine* player_sm, u16 enemy_id, u16 pattern_id)
```
Reemplazar `enemy_sm->entity_id` → `enemy_id + ENEMY_ENTITY_ID_BASE`, borrar resto.

**🛠 C-2** — aparecen símbolos de combate enemigo.

## 4. Estado global de combate enemigo
### 4.1 `src/enemy_combat_state.h`
(definiciones y `extern`)

### 4.2 `src/enemy_combat_state.c`
(inicializaciones)

### 4.3 Makefile
```diff
+ OBJS += enemy_combat_state.o
```

### 4.4 Includes
```c
#include "enemy_combat_state.h"
```

**🛠 Compila** — faltan metadatos HUD.

## 5. Metadatos y notas HUD
### 5.1 `src/enemy_pattern_data.h`
(EnemyPatternInfo, arrays, prototipos)

### 5.2 `src/enemy_pattern_data.c`
(obj_Pattern_Enemy[2], enemy_note_active[4], stubs HUD)

### 5.3 Makefile
```diff
+ OBJS += enemy_pattern_data.o
```

### 5.4 Includes
```c
#include "enemy_pattern_data.h"
```

### 5.5 Warning
```diff
- u16 current_pattern = enemy_attack_pattern;
```

**🛠 C-3** — compila.

## 6. Callbacks de patrones (`u16 enemy_id`)
Eliminar versiones `StateMachine*` en:
* `src/pattern_types/enemy_bite_pattern.c/.h`
* `src/pattern_types/enemy_electric_pattern.c/.h`

Actualizar tabla en `src/patterns_registry.c`:
```c
[PTRN_EN_ELECTIC] = { enemy_electric_pattern_launch, enemy_electric_pattern_do },
[PTRN_EN_BITE]    = { bite_pattern_launch,           bite_pattern_do }
```

**🛠 C-4** — sin warnings.

## 7. Alias opcional
```c
#define PTRN_EN_ELECTRIC PTRN_EN_ELECTIC
```

## 8. Limpieza final
```bash
grep -R "enemy_state_machines" src/   # → vacío
grep -R "StateMachine_" src/ | grep -v player
```

## 9. Makefile final
```make
OBJS = ...        enemy_logic.o        enemy_combat_state.o        enemy_pattern_data.o
```

## 10. Pruebas finales
1. Weaver Ghost → patrón eléctrico.
2. Three‑Head Monkey → patrón BITE.
3. Contra‑hechizo eléctrico refleja daño.
4. HUD de notas funciona.

---

### Check‑points de compilación

| ID | tras paso | estado |
|----|-----------|--------|
| C-0 | 1 | enlaza |
| C-1 | 2 | enlaza (enemigos quietos) |
| C-2 | 3 | errores de símbolos globales |
| C-3 | 5 | compila |
| C-4 | 6 | 0 warnings |
| Final | 9 | 0 errores / 0 warnings |

---

### Ficheros creados
```
src/enemy_logic.c/h
src/enemy_combat_state.c/h
src/enemy_pattern_data.c/h
```
### Ficheros eliminados
```
src/enemies_patterns.c/h
```

Fin del informe.

================
File: memory_bank/final_state_machine_combat_plan.md
================
# Plan Final para la Máquina de Estados y Sistema de Combate

## Resumen

Este documento presenta el plan final para completar la implementación de la máquina de estados y el sistema de combate en "The Weave". La implementación se basa en los documentos previos y las discusiones mantenidas, consolidando toda la información en un único plan coherente.

## Arquitectura General

La arquitectura se basa en los siguientes componentes principales:

1. **Máquina de Estados (StateMachine)**: Componente central que gestiona los estados de personajes y enemigos.
2. **Sistema de Patrones**: Gestiona los patrones de notas que pueden ejecutar tanto el jugador como los enemigos.
3. **Sistema de Combate**: Coordina las interacciones entre personajes y enemigos durante el combate.

## Implementación de la Máquina de Estados

### Estructura Principal (statemachine.h/c)

```c
typedef struct StateMachine {
    // Estados y temporizadores base
    SM_State current_state;      // Estado actual
    u16 timer;                   // Temporizador general
    
    // Sistema de notas
    u8 notes[4];                 // Notas del patrón actual
    u8 note_count;               // Número de notas reproducidas
    u8 current_note;             // Nota actual que se está reproduciendo
    u16 note_time;               // Tiempo que lleva reproduciendo la nota
    u16 pattern_time;            // Tiempo desde la última nota
    
    // Sistema de patrones base
    u16 active_pattern;          // Patrón activo (si hay alguno)
    bool is_reversed;            // Si el patrón es invertido
    u16 effect_time;             // Tiempo que lleva el efecto activo
    u16 entity_id;               // ID de la entidad (jugador o enemigo)
    
    // Sistema de patrones expandido
    PatternSystem pattern_system;
    
    // Callbacks para efectos específicos
    EffectCallback launch_effect;  // Función para iniciar un efecto
    EffectCallback do_effect;      // Función para procesar un efecto
    EffectCallback finish_effect;  // Función para finalizar un efecto
} StateMachine;
```

### Estados de la Máquina

```c
typedef enum {
    SM_STATE_IDLE,               // Sistema inactivo
    SM_STATE_PLAYING_NOTE,       // Reproduciendo una nota
    SM_STATE_PATTERN_CHECK,      // Verificando si el patrón es válido
    SM_STATE_PATTERN_EFFECT,     // Ejecutando el efecto del patrón
    SM_STATE_PATTERN_EFFECT_FINISH, // Finalizando el efecto del patrón
    SM_STATE_ATTACK_FINISHED     // Ataque finalizado, en enfriamiento
} SM_State;
```

### Mensajes para Comunicación

```c
typedef enum {
    MSG_PATTERN_COMPLETE,        // Patrón completado
    MSG_COMBAT_START,            // Inicio de combate
    MSG_COMBAT_END,              // Fin de combate
    MSG_ENEMY_DEFEATED,          // Enemigo derrotado
    MSG_PLAYER_HIT,              // Jugador golpeado
    MSG_ENEMY_HIT,               // Enemigo golpeado
    MSG_NOTE_PLAYED,             // Nota reproducida
    MSG_PATTERN_TIMEOUT          // Tiempo de espera del patrón agotado
} MessageType;
```

## Flujo de Ejecución

1. **Inicialización**:
   - Se inicializan las máquinas de estado para el jugador y los enemigos.
   - Se configuran los patrones disponibles.

2. **Durante el Combate**:
   - En cada frame, se llama a combat_update para actualizar todas las máquinas de estado.
   - Las máquinas de estado procesan los mensajes y actualizan sus estados.
   - Los callbacks de los patrones se ejecutan según el estado actual.

3. **Reproducción de Notas**:
   - Cuando el jugador reproduce una nota, se envía un mensaje MSG_NOTE_PLAYED a la máquina de estados.
   - La máquina de estados actualiza su estado a SM_STATE_PLAYING_NOTE.

4. **Verificación de Patrones**:
   - Después de reproducir 4 notas, se verifica si forman un patrón válido.
   - Si se encuentra un patrón, se envía un mensaje MSG_PATTERN_COMPLETE a la máquina de estados.

5. **Ejecución de Efectos**:
   - La máquina de estados asigna los callbacks correspondientes según el tipo de patrón.
   - Se ejecutan los callbacks para iniciar, procesar y finalizar el efecto.

6. **Contraataque**:
   - Si el jugador reproduce el patrón eléctrico invertido durante un ataque eléctrico enemigo, se activa el contraataque.
   - Se muestra un mensaje de éxito y se golpea al enemigo.

## Correcciones Adicionales

### 1. Mejora de la Detección de Contraataques

Se ha mejorado la detección de contraataques para asegurarse de que solo se puedan realizar durante un ataque enemigo en progreso:

```c
// Handle thunder counter (reverse thunder during enemy thunder)
else if (matched_pattern == PTRN_ELECTRIC && is_reverse_match) {
    kprintf("Reverse thunder spell detected! Combat active: %d, Enemy attacking: %d, Effect in progress: %d", 
            is_combat_active, enemy_attacking, enemy_attack_effect_in_progress);
    
    if (is_combat_active && enemy_attacking != ENEMY_NONE && enemy_attack_effect_in_progress) {
        kprintf("COUNTER-ATTACK ACTIVATED!");
        
        // Mostrar mensaje de éxito
        show_or_hide_interface(false);
        show_or_hide_enemy_combat_interface(false);
        talk_dialog(&dialogs[ACT1_DIALOG3][3]); // (ES) "¡Contraataque!" - (EN) "Counter-attack!"
        show_or_hide_enemy_combat_interface(true);
        show_or_hide_interface(true);
        
        // Activar el contraataque
        StateMachine_SendMessage(&player_state_machine, MSG_PATTERN_COMPLETE, PTRN_ELECTRIC);
        obj_character[active_character].state = STATE_PATTERN_EFFECT;
        player_pattern_effect_in_progress = PTRN_ELECTRIC;
        player_pattern_effect_reversed = true;
        
        // Establecer la bandera de contraataque exitoso
        counter_spell_success = true;
        
        // Golpear al enemigo
        hit_enemy(enemy_attacking);
        
        // Resetear el estado del enemigo
        enemy_attack_effect_in_progress = false;
        enemy_attack_effect_time = 0;
        enemy_attack_pattern = PTRN_EN_NONE;
        
        // Asegurarse de que el efecto visual se desactive
        VDP_setHilightShadow(false);
        
        // Limpiar el estado del patrón
        reset_pattern_state();
        
        // Actualizar sprites
        SPR_update();
    } else {
        // Si no estamos en combate o no hay un ataque en progreso, mostrar mensaje de error
        kprintf("Reverse thunder spell not usable in current context");
        show_pattern_icon(matched_pattern, true, true);
        play_pattern_sound(PTRN_NONE);
        show_or_hide_interface(false);
        talk_dialog(&dialogs[SYSTEM_DIALOG][0]); // (ES) "No puedo usar ese patrón|ahora mismo" - (EN) "I can't use that pattern|right now"
        show_or_hide_interface(true);
        show_pattern_icon(matched_pattern, false, false);
        obj_character[active_character].state = STATE_IDLE;
    }
}
```

### 2. Mejora de la Función play_note

Se ha mejorado la función play_note para que sea más fiable en la detección de la primera nota:

```c
void play_note(u8 nnote)    // Handle new musical note input and update character state
{
    // Prevenir notas demasiado rápidas, pero permitir la primera nota
    // o si ha pasado suficiente tiempo desde la última nota
    if (note_playing_time < MIN_TIME_BETWEEN_NOTES && note_playing != 0) {
        kprintf("Rejecting note: too soon after previous note");
        return;
    }

    // Asegurarse de que la nota sea válida (1-6)
    if (nnote < 1 || nnote > 6) {
        kprintf("Invalid note: %d", nnote);
        return;
    }

    // Verificar si podemos reproducir una nota ahora
    if (!player_state_machine.pattern_system.is_note_playing) {
        kprintf("Playing note: %d, current count: %d", nnote, num_played_notes);
        
        // Añadir la nota al patrón actual
        if (num_played_notes < 4) {
            played_notes[num_played_notes] = nnote;
            num_played_notes++;
            
            // Sincronizar con la máquina de estados
            for (u8 i = 0; i < 4; i++) {
                player_state_machine.notes[i] = played_notes[i];
            }
            player_state_machine.note_count = num_played_notes;
        }
        
        // Mostrar la nota visualmente
        show_note(nnote, true);
        
        // Mantener la compatibilidad con el sistema actual
        note_playing = nnote;
        note_playing_time = 0;
        obj_character[active_character].state = STATE_PLAYING_NOTE;
        
        // Enviar mensaje después de actualizar las notas
        StateMachine_SendMessage(&player_state_machine, MSG_NOTE_PLAYED, nnote);
    }
}
```

### 3. Corrección del Efecto Visual del Patrón Eléctrico

Se ha corregido el problema con el fondo oscuro que no se restablecía correctamente después de un contraataque:

```c
void do_electric_pattern_effect(void)    // Process electric pattern visual and combat effects
{
    // ...
    
    // Asegurarse de que el efecto visual se desactive
    VDP_setHilightShadow(false);
    show_pattern_icon(PTRN_ELECTRIC, false, false);
    SPR_update();
    
    // ...
}

void finish_electric_pattern_effect(void)    // Clean up electric pattern state
{
    // Asegurarse de que el efecto visual se desactive
    VDP_setHilightShadow(false);
    show_pattern_icon(PTRN_ELECTRIC, false, false);
    SPR_update();
    
    // ...
}
```

### 4. Mejora del Ataque Enemigo para Permitir Contraataques

Se ha modificado la función do_electric_enemy_pattern_effect para que el ataque enemigo no termine si el jugador está tocando notas, dándole tiempo para completar un contraataque:

```c
void do_electric_enemy_pattern_effect(void)    // Process electric pattern effect and counter-spell checks
{
    // ...
    
    // Check if player is currently playing notes
    bool player_is_playing_notes = (obj_character[active_character].state == STATE_PLAYING_NOTE ||
                                  num_played_notes > 0);
    
    // ...
    
    // If player is playing notes, extend the effect time to give them a chance to counter
    if (player_is_playing_notes && enemy_attack_effect_time >= calc_ticks(MAX_EFFECT_TIME_ELECTRIC) - 30) {
        // Keep the effect going a bit longer
        enemy_attack_effect_time = calc_ticks(MAX_EFFECT_TIME_ELECTRIC) - 30;
        kprintf("Player is playing notes - extending enemy attack time");
    }
}
```

## Conclusión

La implementación de la máquina de estados y el sistema de combate proporciona una arquitectura modular, mantenible y extensible para el juego. Los cambios realizados han corregido los problemas identificados y mejorado la funcionalidad general del sistema.

La arquitectura permite añadir fácilmente nuevos patrones y comportamientos en el futuro, y mantiene la compatibilidad con el código existente mientras añade la nueva funcionalidad basada en máquinas de estado.

Las correcciones adicionales han mejorado la detección de contraataques y la fiabilidad en la reproducción de notas, lo que proporciona una experiencia de juego más fluida y satisfactoria.

### 5. Prevención de Daño Durante Contraataques

Se ha modificado la función finish_electric_enemy_pattern_effect para que no haga daño al jugador si está tocando notas, dándole tiempo para completar un contraataque:

```c
void finish_electric_enemy_pattern_effect(void)    // Complete electric pattern and apply damage if not countered
{
    kprintf("FINISH_ELECTRIC_ENEMY_PATTERN_EFFECT called: enemy=%d", enemy_attacking);
    
    VDP_setHilightShadow(false);
    
    // Check if player is currently playing notes
    bool player_is_playing_notes = (obj_character[active_character].state == STATE_PLAYING_NOTE ||
                                  num_played_notes > 0);
    
    if (enemy_attacking != ENEMY_NONE) {
        if (player_is_playing_notes) {
            // Player is still trying to counter, give them more time
            kprintf("Player is still playing notes - delaying damage");
            
            // Extend the effect time to give them a chance to counter
            enemy_attack_effect_time = calc_ticks(MAX_EFFECT_TIME_ELECTRIC) - 30;
            
            // Don't apply damage yet
            return;
        } else {
            // Player failed to counter
            hit_caracter(active_character);
            show_or_hide_interface(false);
            show_or_hide_enemy_combat_interface(false);
            talk_dialog(&dialogs[ACT1_DIALOG3][2]); // (ES) "Eso ha dolido" - (EN) "That hurts"
            
            // Only show the hint if they haven't successfully countered before
            if (!counter_spell_success) {
                talk_dialog(&dialogs[ACT1_DIALOG3][3]); // (ES) "Quizá deba pensar|al revés" - (EN) "I should maybe|think backwards"
            }
            
            show_or_hide_interface(true);
            show_or_hide_enemy_combat_interface(true);
        }
    }
    
    kprintf("FINISH_ELECTRIC_ENEMY_PATTERN_EFFECT completed");
}
```

Este cambio asegura que el jugador tenga suficiente tiempo para completar un contraataque, y no reciba daño mientras está intentando tocar las notas del contraataque.

### 6. Corrección del Mensaje de Contraataque

Se ha modificado la función do_electric_enemy_pattern_effect para mostrar el mensaje correcto cuando se lanza un contraataque con éxito:

```c
void do_electric_enemy_pattern_effect(void)    // Process electric pattern effect and counter-spell checks
{
    // ...
    
    // Check for player counter-spell
    if (player_pattern_effect_in_progress == PTRN_ELECTRIC && player_pattern_effect_reversed == true) {
        // Set the counter-spell success flag
        counter_spell_success = true;
        
        // Stop all visual effects immediately
        VDP_setHilightShadow(false);
        
        // Show success message
        show_or_hide_interface(false);
        show_or_hide_enemy_combat_interface(false);
        talk_dialog(&dialogs[ACT1_DIALOG3][3]); // (ES) "¡Contraataque!" - (EN) "Counter-attack!"
        show_or_hide_enemy_combat_interface(true);
        show_or_hide_interface(true);
        
        // Damage the enemy
        hit_enemy(enemy_attacking);
        
        // ...
    }
    
    // ...
}
```

Este cambio asegura que se muestre el mensaje "¡Contraataque!" en lugar de "Quizá deba pensar al revés" cuando el jugador lanza un contraataque con éxito.

### 7. Corrección de la Bandera de Contraataque Exitoso

Se ha modificado la función check_active_character_state en character_patterns.c para asegurarnos de que se establezca correctamente la bandera counter_spell_success:

```c
// Handle thunder counter (reverse thunder during enemy thunder)
else if (matched_pattern == PTRN_ELECTRIC && is_reverse_match) {
    kprintf("Reverse thunder spell detected! Combat active: %d, Enemy attacking: %d, Effect in progress: %d",
            is_combat_active, enemy_attacking, enemy_attack_effect_in_progress);
    
    if (is_combat_active && enemy_attacking != ENEMY_NONE && enemy_attack_effect_in_progress) {
        kprintf("COUNTER-ATTACK ACTIVATED!");
        
        // Establecer la bandera de contraataque exitoso PRIMERO
        counter_spell_success = true;
        kprintf("Counter spell success flag set to: %d", counter_spell_success);
        
        // Mostrar mensaje de éxito
        show_or_hide_interface(false);
        show_or_hide_enemy_combat_interface(false);
        talk_dialog(&dialogs[ACT1_DIALOG3][3]); // (ES) "¡Contraataque!" - (EN) "Counter-attack!"
        show_or_hide_enemy_combat_interface(true);
        show_or_hide_interface(true);
        
        // ... resto del código ...
    }
}
```

Y también se ha modificado la función finish_electric_enemy_pattern_effect para que no haga nada si ya se ha realizado un contraataque exitoso:

```c
void finish_electric_enemy_pattern_effect(void)    // Complete electric pattern and apply damage if not countered
{
    kprintf("FINISH_ELECTRIC_ENEMY_PATTERN_EFFECT called: enemy=%d, counter_success=%d",
            enemy_attacking, counter_spell_success);
    
    // If counter-spell already succeeded, don't do anything
    if (counter_spell_success) {
        kprintf("Counter spell already successful, skipping damage and dialog");
        VDP_setHilightShadow(false);
        return;
    }
    
    // ... resto del código ...
}
```

Estos cambios aseguran que no se muestre el mensaje "Quizá deba pensar al revés" cuando el jugador ya ha realizado un contraataque exitoso.

================
File: memory_bank/productContext.md
================
# Product Context

## Project Purpose
The Weave is a fan game of LucasArts' Loom, being developed for the Sega Genesis/Megadrive console. It aims to recreate the magical musical gameplay mechanics of Loom while telling its own unique story.

## Problems Solved
- Creates a new adventure game experience for the Sega Genesis/Megadrive
- Provides a spiritual successor/homage to the classic game Loom
- Implements a unique musical pattern-based magic system
- Delivers a story-rich experience with character interactions and choices

## Core Functionality
- Musical pattern-based magic system where players learn and cast spells
- Character dialogue system with choice mechanics
- Combat system incorporating the musical magic patterns
- Scene-based progression through different acts and locations
- Character movement and interaction with environment objects
- Resource management for sprites, backgrounds, and sound effects

## Development Stack

### Core Technologies
- SGDK (Sega Genesis Development Kit)
- C programming language
- Motorola 68000 Assembly (boot code)
- Genesis VDP (Video Display Processor)
- YM2612 FM Synthesis & PSG Sound

### Development Tools
- Resource files (.res) for asset management
- Header files (.h) for system declarations
- Implementation files (.c) for core logic
- Python scripts for text processing (add_texts_comments.py)

## Asset Types
1. Graphics
- Background tiles and maps
- Character sprites
- Interface elements
- Font resources
- Palette files (.pal)

2. Audio
- VGM music files
- WAV sound effects
- FM synthesis patterns

3. Resource Files
- res_backgrounds
- res_characters
- res_enemies
- res_faces
- res_geesebumps
- res_interface
- res_intro
- res_items
- res_sound

## Project Structure
- src/ - Source code files
- res/ - Resource files and assets
  - Backgrounds/ - Background images and maps
  - Sound/ - Audio files
  - Sprites/ - Character and object sprites
- cline_docs/ - Project documentation

## Project Documentation
- `projectBrief.md`: Contains a high-level overview of the project goals, key features, and current status.

================
File: memory_bank/projectBrief.md
================
# Project Brief: The Weave

## Project Overview

The Weave is a fan game inspired by LucasArts' Loom, developed for the Sega Genesis/Megadrive. It aims to capture the essence of Loom's magical musical gameplay while presenting a unique narrative experience.

## Goals

*   Develop a complete adventure game for the Sega Genesis/Megadrive.
*   Recreate and enhance the musical pattern-based magic system from Loom.
*   Create a compelling story with engaging characters and meaningful choices.
*   Release a technical demo by late 2025.

## Key Features

*   Musical pattern-based magic system.
*   Character dialogue system with choices.
*   Combat system integrated with the musical magic patterns.
*   Scene-based progression through acts and locations.

## Current Status

The game is currently in the early stages of development, with a functional technical demo showcasing core gameplay mechanics and Act 1 content.

## Future Plans

*   Complete Act 1 and develop additional acts and scenes.
*   Enhance the combat system and add more enemy types.
*   Expand the musical pattern/spell system.
*   Optimize performance and memory usage.
*   Improve UI/UX and overall polish.

================
File: memory_bank/techContext.md
================
# Technical Context

## Development Stack

### Core Technologies
- SGDK (Sega Genesis Development Kit)
- C programming language
- Motorola 68000 Assembly (boot code)
- Genesis VDP (Video Display Processor)
- YM2612 FM Synthesis & PSG Sound

### Development Tools
- Resource files (.res) for asset management
- Header files (.h) for system declarations
- Implementation files (.c) for core logic
- Python scripts for text processing (add_texts_comments.py)

### Asset Types
1. Graphics
- Background tiles and maps
- Character sprites
- Interface elements
- Font resources
- Palette files (.pal)

2. Audio
- VGM music files
- WAV sound effects
- FM synthesis patterns

3. Resource Files
- res_backgrounds
- res_characters
- res_enemies
- res_faces
- res_geesebumps
- res_interface
- res_intro
- res_items
- res_sound

## Project Structure
- src/ - Source code files
- res/ - Resource files and assets
  - Backgrounds/ - Background images and maps
  - Sound/ - Audio files
  - Sprites/ - Character and object sprites
- cline_docs/ - Project documentation

## Development Setup
- Genesis/Megadrive development environment
- Resource compilation pipeline
- Build system for ROM generation
- Debugging tools for Genesis hardware

## Code Conventions
- Data types defined in Sega Genesis libraries are used: u8, u16, s8, s16, etc.
- All include statements are centralized in `globals.h`.
- Other header files (.h) do not require include statements.
- C files (.c) only include `globals.h`.

## Technical Constraints
- 16-bit architecture limitations
- Hardware sprite and tile restrictions
- Audio channel management
- Memory management for assets
- Performance optimization requirements

================
File: old_src/character_patterns.c
================
#include "globals.h"
#include "patterns_registry.h"
#include "counter_spell.h"
#include "pattern_types/electric_pattern.h"
#include "pattern_types/hide_pattern.h"
#include "pattern_types/sleep_pattern.h"
#include "pattern_types/open_pattern.h"

StateMachine player_state_machine;        // Global state machine for player character

bool player_has_rod;                      // Has the player the rod?
bool player_patterns_enabled;             // Whether pattern system is currently enabled
u8 note_playing;                          // Currently playing musical note (NOTE_NONE if none)
u16 note_playing_time;                    // Duration of current note in ticks
u16 time_since_last_note;                 // Time since last note in pattern sequence
u16 player_pattern_effect_in_progress;    // Active pattern effect type (PTRN_NONE if none)
bool player_pattern_effect_reversed;      // Whether current pattern is reversed
u16 player_pattern_effect_time;           // Duration of current pattern effect
u8 played_notes[4];                       // Sequence of notes played in current pattern
u8 num_played_notes;                      // Number of notes played in current pattern
Pattern obj_pattern[MAX_PATTERNS];        // Available pattern spells and their states

void activate_spell(u16 npattern)    // Unlock new pattern spell with visual/audio feedback
{
    // If pattern is already active, do nothing
    if (obj_pattern[npattern].active) {
        return;
    }
    
    // Show icon and play notes
    show_pattern_icon(PTRN_SLEEP, true, true);
    for (u8 i = 0; i < 4; i++) {
        show_note(obj_pattern[npattern].notes[i], true);
        wait_seconds(1);
        show_note(obj_pattern[npattern].notes[i], false);
    }
    show_pattern_icon(PTRN_SLEEP, false, false);

    // Activate the pattern
    obj_pattern[npattern].active = true;
    
    // Register the pattern with the registry
    Pattern* pattern = get_pattern(npattern, OWNER_PLAYER);
    if (pattern) {
        pattern->active = true;
    }
}

void play_note(u8 nnote)    // Handle new musical note input and update character state
{
    // Prevenir notas demasiado rápidas, pero permitir la primera nota
    // o si ha pasado suficiente tiempo desde la última nota
    if (note_playing_time < MIN_TIME_BETWEEN_NOTES && note_playing != 0) {
        kprintf("Rejecting note: too soon after previous note");
        return;
    }

    // Asegurarse de que la nota sea válida (1-6)
    if (nnote < 1 || nnote > 6) {
        kprintf("Invalid note: %d", nnote);
        return;
    }

    // Verificar si podemos reproducir una nota ahora
    if (!player_state_machine.pattern_system.is_note_playing) {
        kprintf("Playing note: %d, current count: %d", nnote, num_played_notes);
        
        // Añadir la nota al patrón actual
        if (num_played_notes < 4) {
            played_notes[num_played_notes] = nnote;
            num_played_notes++;
            
            // Sincronizar con la máquina de estados
            for (u8 i = 0; i < 4; i++) {
                player_state_machine.notes[i] = played_notes[i];
            }
            player_state_machine.note_count = num_played_notes;
        }
        
        // Mostrar la nota visualmente
        show_note(nnote, true);
        
        // Mantener la compatibilidad con el sistema actual
        note_playing = nnote;
        note_playing_time = 0;
        obj_character[active_character].state = STATE_PLAYING_NOTE;
        
        // Usar la nueva función de manejo de notas
        StateMachine_HandleNoteInput(&player_state_machine, nnote);
    }
}

void check_active_character_state(void)    // Process character states for pattern system
{
    // Actualizar la máquina de estados
    StateMachine_Update(&player_state_machine, NULL);
    
    // Solo actualizar el estado si no estamos en un estado de movimiento
    if (obj_character[active_character].state != STATE_WALKING) {
        update_character_from_sm_state(&obj_character[active_character],
                                    player_state_machine.current_state);
    }
    
    // Verificar si estamos en combate y hay un ataque enemigo en progreso
    if (is_combat_active && enemy_attacking != ENEMY_NONE && enemy_attack_effect_in_progress) {
        // Si tenemos 4 notas, verificar si es un contraataque
        if (num_played_notes == 4) {
            bool is_reverse_match = false;
            u8 matched_pattern = validate_player_pattern(played_notes, &is_reverse_match);
            
            if (matched_pattern == PTRN_ELECTRIC && is_reverse_match) {
                kprintf("COUNTER-ATTACK DETECTED DURING ENEMY ATTACK!");
                
                // Usar el sistema de contraataque
                execute_counter_spell(&player_state_machine,
                                      &enemy_state_machines[enemy_attacking],
                                      PTRN_ELECTRIC);
                
                // Limpiar el estado del patrón
                reset_pattern_state();
                
                // Actualizar sprites
                SPR_update();
                
                return;
            }
        }
    }
    
    // Mantener la lógica existente temporalmente
    bool is_reverse_match;
    u8 matched_pattern;

    switch (obj_character[active_character].state)
    {
        case STATE_PLAYING_NOTE:
            if (note_playing_time != 0) {
                if (note_playing_time == calc_ticks(MAX_NOTE_PLAYING_TIME)) {
                    kprintf("Note playing time reached max, updating pattern state");
                    update_pattern_state();
                }
                else {
                    note_playing_time++;
                }
            }
            break;

        case STATE_IDLE:
            handle_pattern_timeout();
            break;

        case STATE_PATTERN_CHECK:
            kprintf("Checking pattern. Notes played: %d %d %d %d (count: %d)",
                   played_notes[0], played_notes[1], played_notes[2], played_notes[3],
                   num_played_notes);
            
            if (num_played_notes == 4) {
                matched_pattern = validate_player_pattern(played_notes, &is_reverse_match);
                hide_rod_icons();

                if (matched_pattern != PTRN_NONE) {
                    player_pattern_effect_reversed = is_reverse_match;
                    player_state_machine.pattern_system.effect_reversed = is_reverse_match;
                    player_state_machine.is_reversed = is_reverse_match;
                    
                    // Get the pattern from the registry
                    Pattern* pattern = get_pattern(matched_pattern, OWNER_PLAYER);
                    
                    // Check if pattern can be used
                    bool can_use = true;
                    if (pattern && pattern->can_use) {
                        can_use = pattern->can_use();
                    } else {
                        // Fallback to old system
                        switch (matched_pattern) {
                            case PTRN_ELECTRIC:
                                can_use = can_use_electric_pattern();
                                break;
                            case PTRN_HIDE:
                                can_use = can_use_hide_pattern();
                                break;
                            case PTRN_SLEEP:
                                can_use = can_use_sleep_pattern();
                                break;
                            case PTRN_OPEN:
                                can_use = can_use_open_pattern();
                                break;
                            default:
                                can_use = false;
                                break;
                        }
                    }
                    
                    // Special case for direct thunder during enemy thunder attack
                    if (matched_pattern == PTRN_ELECTRIC && !is_reverse_match &&
                        is_combat_active && enemy_attacking != ENEMY_NONE &&
                        enemy_attack_effect_in_progress && enemy_attack_pattern == PTRN_EN_ELECTIC) {
                        
                        kprintf("Direct thunder during enemy thunder - checking if already shown hint");
                        
                        // Verificar si ya hemos tenido éxito con un contraataque
                        if (counter_spell_success) {
                            // Si ya hemos tenido éxito con un contraataque, tratar como un patrón normal
                            kprintf("Counter spell already successful, treating as normal pattern");
                            StateMachine_HandlePatternComplete(&player_state_machine, PTRN_ELECTRIC, false);
                        } else {
                            // Show hint dialog
                            show_or_hide_interface(false);
                            show_or_hide_enemy_combat_interface(false);
                            talk_dialog(&dialogs[ACT1_DIALOG3][6]); // (ES) "Si reproduzco al revés|las notas, podré|contraatacar este hechizo" - (EN) "If I play the notes backwards|I could be able to|counter the spell"
                            show_or_hide_enemy_combat_interface(true);
                            show_or_hide_interface(true);
                            
                            // Reset state without showing the "can't use pattern" dialog
                            play_pattern_sound(PTRN_NONE);
                            obj_character[active_character].state = STATE_IDLE;
                            
                            // Apply damage to player since they failed to counter
                            hit_caracter(active_character);
                            
                            // Directly reset enemy state variables to allow new attacks
                            u16 current_enemy = enemy_attacking;
                            u16 current_pattern = enemy_attack_pattern;
                            
                            // Reset visual effects
                            VDP_setHilightShadow(false);
                            
                            // Reset enemy state
                            if (current_enemy != ENEMY_NONE) {
                                anim_enemy(current_enemy, ANIM_IDLE);
                                obj_enemy[current_enemy].obj_character.state = STATE_IDLE;
                                
                                // Set cooldown to allow attacks after a delay
                                if (current_pattern != PTRN_EN_NONE) {
                                    obj_enemy[current_enemy].last_pattern_time[current_pattern] =
                                        obj_Pattern_Enemy[current_pattern].recharge_time / 2;
                                }
                            }
                        }
                        
                        // Reset global state variables
                        enemy_attack_effect_in_progress = false;
                        enemy_attack_effect_time = 0;
                        enemy_attack_pattern = PTRN_EN_NONE;
                        enemy_attacking = ENEMY_NONE;
                        
                        // Clean up any active notes
                        cleanup_enemy_notes();
                        
                        // Update sprites
                        SPR_update();
                    }
                    // Handle pattern if it can be used
                    else if (can_use) {
                        kprintf("Pattern %d can be used, sending pattern complete message", matched_pattern);
                        StateMachine_HandlePatternComplete(&player_state_machine, matched_pattern, is_reverse_match);
                    }
                    else {
                        kprintf("Pattern %d matched but not usable in current context", matched_pattern);
                        // Pattern matched but not usable in current context
                        show_pattern_icon(matched_pattern, true, true);
                        play_pattern_sound(PTRN_NONE);
                        show_or_hide_interface(false);
                        talk_dialog(&dialogs[SYSTEM_DIALOG][0]); // (ES) "No puedo usar ese patrón|ahora mismo" - (EN) "I can't use that pattern|right now"
                        show_or_hide_interface(true);
                        show_pattern_icon(matched_pattern, false, false);
                        obj_character[active_character].state = STATE_IDLE;
                    }
                }
                else {
                    // No pattern matched
                    kprintf("No pattern match");
                    play_pattern_sound(PTRN_NONE);
                    obj_character[active_character].state = STATE_IDLE;
                }
                
                reset_pattern_state();
                next_frame(false);
            } else {
                kprintf("Not enough notes yet (%d/4), waiting...", num_played_notes);
                obj_character[active_character].state = STATE_IDLE;
            }
            break;

        case STATE_PATTERN_EFFECT:
        case STATE_PATTERN_EFFECT_FINISH:
            // These states are now handled by the state machine
            break;

        default:
            break;
    }
}

void play_pattern_sound(u16 npattern)    // Play sound effect for given pattern type
{
    switch (npattern)
    {
    case PTRN_HIDE:
        play_sample(snd_pattern_hide,sizeof(snd_pattern_hide));
        break;
    case PTRN_OPEN:
        play_sample(snd_pattern_open,sizeof(snd_pattern_open));
        break;
    case PTRN_ELECTRIC:
        play_sample(snd_pattern_thunder,sizeof(snd_pattern_thunder));
        break;
    default:
        play_sample(snd_pattern_invalid,sizeof(snd_pattern_invalid));
        break;        
    }
}

void init_patterns(void)    // Setup initial pattern definitions and states
{
    kprintf("Initializing patterns");
    
    // Initialize pattern registry
    pattern_registry_init();
    
    // Inicializar patrones existentes
    obj_pattern[PTRN_ELECTRIC] = (Pattern) {
        .id = PTRN_ELECTRIC,
        .active = true,
        .notes = {1,2,3,4},
        .owner_type = OWNER_PLAYER,
        .can_use = electric_pattern_can_use,
        .launch = electric_pattern_launch,
        .do_effect = electric_pattern_do,
        .finish = electric_pattern_finish,
        .sd = NULL
    };
    
    obj_pattern[PTRN_HIDE] = (Pattern) {
        .id = PTRN_HIDE,
        .active = true,
        .notes = {2,5,3,6},
        .owner_type = OWNER_PLAYER,
        .can_use = hide_pattern_can_use,
        .launch = hide_pattern_launch,
        .do_effect = hide_pattern_do,
        .finish = hide_pattern_finish,
        .sd = NULL
    };
    
    obj_pattern[PTRN_OPEN] = (Pattern) {
        .id = PTRN_OPEN,
        .active = true,
        .notes = {2,3,3,2},
        .owner_type = OWNER_PLAYER,
        .can_use = open_pattern_can_use,
        .launch = open_pattern_launch,
        .do_effect = open_pattern_do,
        .finish = open_pattern_finish,
        .sd = NULL
    };
    
    obj_pattern[PTRN_SLEEP] = (Pattern) {
        .id = PTRN_SLEEP,
        .active = true,
        .notes = {2,1,6,4},
        .owner_type = OWNER_PLAYER,
        .can_use = sleep_pattern_can_use,
        .launch = sleep_pattern_launch,
        .do_effect = sleep_pattern_do,
        .finish = sleep_pattern_finish,
        .sd = NULL
    };

    // Register patterns with the registry
    for (u8 i = 0; i < MAX_PATTERNS; i++) {
        register_pattern(&obj_pattern[i]);
    }

    kprintf("Patterns initialized with active status: %d %d %d %d",
            obj_pattern[PTRN_ELECTRIC].active,
            obj_pattern[PTRN_HIDE].active,
            obj_pattern[PTRN_OPEN].active,
            obj_pattern[PTRN_SLEEP].active);

    // Inicializar máquina de estados
    StateMachine_Init(&player_state_machine, active_character);
    player_state_machine.owner_type = OWNER_PLAYER;
    
    // Configurar patrones disponibles - asignar el puntero al array
    player_state_machine.pattern_system.available_patterns = &obj_pattern[0];
    player_state_machine.pattern_system.pattern_count = MAX_PATTERNS;
    
    kprintf("State machine initialized with entity_id: %d", active_character);
}

// This function is now implemented in patterns_registry.c
// We provide this wrapper for backward compatibility
u8 validate_player_pattern(u8 *notes, bool *is_reverse)    // Check if notes match a player pattern
{
    return validate_pattern_sequence(notes, is_reverse, OWNER_PLAYER);
}

bool can_use_electric_pattern(void)
{
    // Permitir siempre el contraataque (patrón invertido)
    if (is_combat_active && enemy_attacking != ENEMY_NONE &&
        enemy_attack_effect_in_progress && enemy_attack_pattern == PTRN_EN_ELECTIC) {
        kprintf("Electric pattern can be used as counter-attack");
        return true;
    }
    // No permitir el patrón eléctrico normal durante un ataque eléctrico enemigo
    else if (is_combat_active && enemy_attacking != ENEMY_NONE &&
             enemy_attack_effect_in_progress && enemy_attack_pattern == PTRN_EN_ELECTIC) {
        kprintf("Cannot use normal electric pattern during enemy electric attack");
        return false;
    }
    else if (player_pattern_effect_in_progress == PTRN_HIDE) {
        // Can't use thunder while hidden
        show_or_hide_interface(false);
        show_or_hide_enemy_combat_interface(false);
        talk_dialog(&dialogs[ACT1_DIALOG3][9]); // (ES) "No puedo lanzar hechizos|si estoy escondido" - (EN) "I can't launch spells|while hiding"
        show_or_hide_enemy_combat_interface(true);
        show_or_hide_interface(true);
        return false;
    }
    return true;
}

bool can_use_hide_pattern(void)
{
    return true; // Currently no restrictions on hide pattern
}

bool can_use_sleep_pattern(void)
{
    return false; // You can't currently use the spell
}

bool can_use_open_pattern(void)
{
    return false; // You can't currently use the spell
}

void reset_pattern_state(void)    // Clear current pattern sequence state
{
    // Limpiar notas visuales (tanto en la vara como en el pentagrama)
    if (num_played_notes > 0) {
        kprintf("Clearing pattern state");
        
        // Limpiar notas visuales
        for (u8 i = 0; i < 4; i++) {
            if (i < num_played_notes) {
                show_note(played_notes[i], false);
            }
        }
        
        // Limpiar visuales del pentagrama
        hide_pentagram_icons();
        
        // Resetear contadores
        num_played_notes = 0;
        time_since_last_note = 0;
        player_state_machine.pattern_time = 0;
        player_state_machine.note_count = 0;
    }
    
    // Asegurarse de que note_playing_time se incremente para permitir nuevas notas
    if (note_playing_time < MIN_TIME_BETWEEN_NOTES) {
        note_playing_time = MIN_TIME_BETWEEN_NOTES;
    }
}

void handle_pattern_timeout(void)    // Check for pattern sequence timeout
{
    // Incrementar note_playing_time para permitir nuevas notas
    if (note_playing_time < 100) {
        note_playing_time++;
    }
    
    // Verificar si estamos en combate y hay un ataque enemigo en progreso
    if (is_combat_active && enemy_attacking != ENEMY_NONE && enemy_attack_effect_in_progress) {
        // Si tenemos 4 notas, verificar si es un contraataque
        if (num_played_notes == 4) {
            bool is_reverse_match = false;
            u8 matched_pattern = validate_player_pattern(played_notes, &is_reverse_match);
            
            kprintf("Checking for counter-attack in timeout: pattern=%d, is_reverse=%d", matched_pattern, is_reverse_match);
            
            if (matched_pattern == PTRN_ELECTRIC && is_reverse_match) {
                kprintf("COUNTER-ATTACK DETECTED IN handle_pattern_timeout!");
                
                // Usar el sistema de contraataque
                execute_counter_spell(&player_state_machine, 
                                     &enemy_state_machines[enemy_attacking - ENEMY_ENTITY_ID_BASE],
                                     PTRN_ELECTRIC);
                
                // Limpiar el estado del patrón
                reset_pattern_state();
                
                // Actualizar sprites
                SPR_update();
                
                return;
            }
        }
    }
    
    // Manejar timeout para patrones en progreso o a mitad de un patrón
    if (time_since_last_note != 0 || num_played_notes > 0) {
        // Si hay notas en progreso, incrementar el contador de tiempo
        if (time_since_last_note == 0 && num_played_notes > 0) {
            time_since_last_note = 1; // Iniciar el contador si hay notas pero no se ha iniciado
        } else {
            time_since_last_note++;
        }
        
        // Verificar si se ha alcanzado el tiempo máximo de espera
        if (time_since_last_note == calc_ticks(MAX_PATTERN_WAIT_TIME)) {
            kprintf("Pattern timeout detected - clearing %d notes", num_played_notes);
            
            // Limpiar estado primero
            reset_pattern_state();
            
            // Limpiar todas las visuales
            hide_rod_icons();
            hide_pentagram_icons();
            
            // Limpiar todas las notas posibles
            for (u8 i = 1; i <= 6; i++) {
                show_note(i, false);
            }
            
            // Reproducir sonido de patrón inválido
            play_pattern_sound(PTRN_NONE);
            
            // Notificar timeout a la máquina de estados
            StateMachine_HandlePatternTimeout(&player_state_machine);
        }
    }
    // Limpiar visuales incluso si no hay patrón en progreso
    else if (num_played_notes == 0 && note_playing == 0) {
        // Asegurarse de que no haya notas visibles
        hide_rod_icons();
        hide_pentagram_icons();
    }
}

void update_pattern_state(void)    // Process note completion and check for pattern match
{
    show_note(note_playing, false);
    
    // Actualizar estado actual
    note_playing = NOTE_NONE;
    time_since_last_note = 1;
    note_playing_time = 0;
    
    // Sincronizar con la máquina de estados
    player_state_machine.pattern_system.is_note_playing = false;
    player_state_machine.pattern_time = 1;
    
    // Verificar si estamos en combate y hay un ataque enemigo en progreso
    if (is_combat_active && enemy_attacking != ENEMY_NONE && enemy_attack_effect_in_progress) {
        kprintf("In update_pattern_state: Combat active with enemy %d attacking, pattern %d",
                enemy_attacking, enemy_attack_pattern);
        
        // Si tenemos 4 notas, verificar si es un contraataque
        if (num_played_notes == 4) {
            bool is_reverse_match = false;
            u8 matched_pattern = validate_player_pattern(played_notes, &is_reverse_match);
            
            kprintf("Checking for counter-attack: pattern=%d, is_reverse=%d", matched_pattern, is_reverse_match);
            
            if (matched_pattern == PTRN_ELECTRIC && is_reverse_match) {
                kprintf("COUNTER-ATTACK DETECTED IN update_pattern_state!");
                
                // Usar el sistema de contraataque
                execute_counter_spell(&player_state_machine, 
                                     &enemy_state_machines[enemy_attacking - ENEMY_ENTITY_ID_BASE],
                                     PTRN_ELECTRIC);
                
                // Limpiar el estado del patrón
                reset_pattern_state();
                
                // Actualizar sprites
                SPR_update();
                
                return;
            }
        }
    }
    
    if (num_played_notes == 4) {
        // La validación del patrón ahora se maneja en validate_pattern_sequence
        // que enviará MSG_PATTERN_COMPLETE si corresponde
        obj_character[active_character].state = STATE_PATTERN_CHECK;
    } else {
        obj_character[active_character].state = STATE_IDLE;
    }
    update_character_animation();
}

// These functions are now implemented in pattern_types/electric_pattern.c
void launch_electric_pattern(void) { /* Deprecated */ }
void do_electric_pattern_effect(void) { /* Deprecated */ }
void finish_electric_pattern_effect(void) { /* Deprecated */ }

// These functions are now implemented in pattern_types/hide_pattern.c
void launch_hide_pattern(void) { /* Deprecated */ }
void do_hide_pattern_effect(void) { /* Deprecated */ }
void finish_hide_pattern_effect(void) { /* Deprecated */ }

// These functions are now implemented in pattern_types/sleep_pattern.c
void launch_sleep_pattern(void) { /* Deprecated */ }
void do_sleep_pattern_effect(void) { /* Deprecated */ }
void finish_sleep_pattern_effect(void) { /* Deprecated */ }

// These functions are now implemented in pattern_types/open_pattern.c
void launch_open_pattern(void) { /* Deprecated */ }
void do_open_pattern_effect(void) { /* Deprecated */ }
void finish_open_pattern_effect(void) { /* Deprecated */ }

================
File: old_src/character_patterns.h
================
#ifndef _CHR_PATTERNS_H_
#define _CHR_PATTERNS_H_

// Notes
#define NOTE_NONE 0
#define NOTE_MI   1
#define NOTE_FA   2
#define NOTE_SOL  3
#define NOTE_LA   4
#define NOTE_SI   5
#define NOTE_DO   6

#define MAX_NOTE_PLAYING_TIME  500  // Note playing time in milliseconds
#define MAX_PATTERN_WAIT_TIME 2000   // Time to wait for a next note before cancelling the pattern in milliseconds
#define MIN_TIME_BETWEEN_NOTES 5     // Minimum ticks between consecutive notes to prevent too rapid input

extern StateMachine player_state_machine; // Global state machine for player character

extern bool player_has_rod; // Has the player the rod?
extern bool player_patterns_enabled; // Can the character play a pattern right now?

extern u8 note_playing; // The note the player is playing
extern u16 note_playing_time; // How long has the note been played (in ticks)
extern u16 time_since_last_note; // How long are we waiting for the pattern to finish
extern u16 player_pattern_effect_in_progress; // Is a pattern effect currently in progress? Which one?
extern bool player_pattern_effect_reversed; // Is the effect of a reverse pattern?
extern u16 player_pattern_effect_time; // How long is the effect been active?

// Patterns
#define MAX_PATTERNS 4
#define PTRN_NONE         254
#define PTRN_ELECTRIC      0   // Electricity spell
#define PTRN_HIDE          1   // Hide spell
#define PTRN_OPEN          2   // Open spell
#define PTRN_SLEEP         3   // Sleep spell

extern u8 played_notes[4]; // Notes played in the current pattern
extern u8 num_played_notes; // Number of notes of the current pattern

extern Pattern obj_pattern[MAX_PATTERNS]; // Patterns object

// Core pattern system functions
void play_note(u8 nnote); // Play a note
void check_active_character_state(void); // Main state machine for pattern system
void play_pattern_sound(u16 npattern); // Play the sound of a pattern spell
void init_patterns(void); // initialize patterns
void activate_spell(u16 npattern); // Activate a spell with animation and sound

// Pattern validation functions
// Use the new version from patterns_registry.h instead
u8 validate_player_pattern(u8 *notes, bool *is_reverse); // Check if notes match a player pattern
bool can_use_electric_pattern(void); // Check if thunder pattern can be used
bool can_use_hide_pattern(void); // Check if hide pattern can be used
bool can_use_sleep_pattern(void); // Check if sleep pattern can be used
bool can_use_open_pattern(void); // Check if open pattern can be used

// Pattern-specific effect functions
// These are now implemented in pattern_types/*.c files
void launch_electric_pattern(void); // Initialize thunder pattern effect
void do_electric_pattern_effect(void); // Process ongoing thunder pattern effect
void finish_electric_pattern_effect(void); // Complete thunder pattern effect

void launch_hide_pattern(void); // Initialize hide pattern effect
void do_hide_pattern_effect(void); // Process ongoing hide pattern effect
void finish_hide_pattern_effect(void); // Complete hide pattern effect

void launch_sleep_pattern(void); // Initialize sleep pattern effect
void do_sleep_pattern_effect(void); // Process ongoing sleep pattern effect
void finish_sleep_pattern_effect(void); // Complete sleep pattern effect

void launch_open_pattern(void); // Initialize sleep pattern effect
void do_open_pattern_effect(void); // Process ongoing sleep pattern effect
void finish_open_pattern_effect(void); // Complete sleep pattern effect

// Pattern state management
void reset_pattern_state(void); // Reset pattern input state
void handle_pattern_timeout(void); // Handle pattern input timeout
void update_pattern_state(void); // Update pattern state after note completion

#endif // _CHR_PATTERNS_H_

================
File: old_src/collisions.c
================
#include <genesis.h>
#include "globals.h"

u8 num_colls;    // Counter to prevent infinite collision loops

u16 char_distance(u16 char1, s16 x1, u8 y1, u16 char2)    // Calculate Manhattan distance between character collision boxes
{
    // Calculate char1's collision box boundaries
    s16 char1_left = x1 + obj_character[char1].collision_x_offset;
    s16 char1_right = char1_left + obj_character[char1].collision_width;
    s16 char1_top = y1 + obj_character[char1].collision_y_offset;
    s16 char1_bottom = char1_top + obj_character[char1].collision_height;

    // Calculate char2's collision box boundaries
    s16 char2_left = obj_character[char2].x + obj_character[char2].collision_x_offset;
    s16 char2_right = char2_left + obj_character[char2].collision_width;
    s16 char2_top = obj_character[char2].y + obj_character[char2].collision_y_offset;
    s16 char2_bottom = char2_top + obj_character[char2].collision_height;

    // Find closest x point on char2's box to char1's box
    s16 closest_x;
    if (char1_right < char2_left) closest_x = char2_left;
    else if (char1_left > char2_right) closest_x = char2_right;
    else closest_x = (char1_left + char1_right) / 2; // If boxes overlap in x, use midpoint

    // Find closest y point on char2's box to char1's box
    s16 closest_y;
    if (char1_bottom < char2_top) closest_y = char2_top;
    else if (char1_top > char2_bottom) closest_y = char2_bottom;
    else closest_y = (char1_top + char1_bottom) / 2; // If boxes overlap in y, use midpoint

    // If boxes overlap completely, return 0
    if (char1_left < char2_right && char1_right > char2_left &&
        char1_top < char2_bottom && char1_bottom > char2_top) {
        return 0;
    }

    // Calculate Manhattan distance to closest point
    return abs((char1_left + char1_right) / 2 - closest_x) + 
           abs((char1_top + char1_bottom) / 2 - closest_y);
}

u16 item_distance(u16 nitem, u16 x, u8 y)    // Calculate Manhattan distance from point to item collision box
{
    // Calculate item's collision box boundaries
    s16 item_left = obj_item[nitem].entity.x + obj_item[nitem].entity.collision_x_offset;
    s16 item_right = item_left + obj_item[nitem].entity.collision_width;
    s16 item_top = obj_item[nitem].entity.y + obj_item[nitem].entity.collision_y_offset;
    s16 item_bottom = item_top + obj_item[nitem].entity.collision_height;
    
    // Find closest x point on box
    s16 closest_x;
    if (x < item_left) closest_x = item_left;
    else if (x > item_right) closest_x = item_right;
    else closest_x = x;

    // Find closest y point on box
    s16 closest_y;
    if (y < item_top) closest_y = item_top;
    else if (y > item_bottom) closest_y = item_bottom;
    else closest_y = y;

    // If point is inside box, return 0
    if (x >= item_left && x <= item_right && y >= item_top && y <= item_bottom) {
        return 0;
    }

    // Calculate Manhattan distance to closest point
    return abs(x - closest_x) + abs(y - closest_y);
}

u16 detect_char_char_collision(u16 nchar, u16 x, u8 y)    // Check for collisions between character and other characters
{
    u16 other_char;

    if (obj_character[nchar].active == true) {
        // Compute character collision box
        u16 char_col_x1, char_col_x2;
        if (obj_character[nchar].flipH) {
            char_col_x1 = x + obj_character[nchar].x_size - obj_character[nchar].collision_x_offset - obj_character[nchar].collision_width;
            char_col_x2 = char_col_x1 + obj_character[nchar].collision_width;
        } else {
            char_col_x1 = x + obj_character[nchar].collision_x_offset;
            char_col_x2 = char_col_x1 + obj_character[nchar].collision_width;
        }
        u8 char_col_y1 = y + obj_character[nchar].collision_y_offset;
        u8 char_col_y2 = char_col_y1 + obj_character[nchar].collision_height;

        // Check collision with each active character (except itself)
        for (other_char = 0; other_char < MAX_CHR; other_char++) {
            if (other_char != nchar && obj_character[other_char].active == true) {
                // Compute other character collision box
                u16 other_col_x1, other_col_x2;
                if (obj_character[other_char].flipH) {
                    other_col_x1 = obj_character[other_char].x + obj_character[other_char].x_size - obj_character[other_char].collision_x_offset - obj_character[other_char].collision_width;
                    other_col_x2 = other_col_x1 + obj_character[other_char].collision_width;
                } else {
                    other_col_x1 = obj_character[other_char].x + obj_character[other_char].collision_x_offset;
                    other_col_x2 = other_col_x1 + obj_character[other_char].collision_width;
                }
                u8 other_col_y1 = obj_character[other_char].y + obj_character[other_char].collision_y_offset;
                u8 other_col_y2 = other_col_y1 + obj_character[other_char].collision_height;

                // Check if collision boxes overlap
                if (char_col_x1 < other_col_x2 &&
                    char_col_x2 > other_col_x1 &&
                    char_col_y1 < other_col_y2 &&
                    char_col_y2 > other_col_y1) {
                    if (num_colls < MAX_COLLISIONS) { // Prevent character from being trapped
                        num_colls++;
                        return other_char;
                    } else {
                        num_colls = 0;
                        return CHR_NONE;
                    }
                }
            }
        }
    }
    
    // No collision detected
    return CHR_NONE;
}

u16 detect_char_item_collision(u16 nchar, u16 x, u8 y)    // Check for collisions between character and items
{
    u16 nitem;
    s16 char_left, char_right, char_top, char_bottom;
    s16 item_left, item_right, item_top, item_bottom;

    // Calculate character's bounding box
    char_left = x + obj_character[nchar].collision_x_offset;
    char_right = char_left + obj_character[nchar].collision_width;
    char_top = y + obj_character[nchar].collision_y_offset;
    char_bottom = char_top + obj_character[nchar].collision_height;
    //kprintf("CAJA PERSONAJE: (%d,%d)-(%d,%d)",char_left,char_top,char_right,char_bottom);

    for (nitem = 0; nitem < MAX_ITEMS; nitem++)
    {
        if (obj_item[nitem].entity.active && obj_item[nitem].entity.visible)
        {
            //kprintf("Detectando colisión con %d", nitem);
            // Calculate item's bounding box
            item_left = obj_item[nitem].entity.x + obj_item[nitem].entity.collision_x_offset;
            item_right = item_left + obj_item[nitem].entity.collision_width;
            item_top = obj_item[nitem].entity.y + obj_item[nitem].entity.collision_y_offset;
            item_bottom = item_top + obj_item[nitem].entity.collision_height;
            //kprintf("DATOS OBJETO: (x,y)=(%d,%d), offset(x,y)=(%d,%d), tam(x,y)=(%d,%d)",obj_item[nitem].entity.x,obj_item[nitem].entity.y,obj_item[nitem].entity.collision_x_offset,obj_item[nitem].entity.collision_y_offset,obj_item[nitem].entity.collision_width,obj_item[nitem].entity.collision_height);
            //kprintf("CAJA OBJETO: (%d,%d)-(%d,%d)",item_left,item_top,item_right,item_bottom);

            // Check for collision
            if (char_left < item_right && char_right > item_left &&
                char_top < item_bottom && char_bottom > item_top)
            {
                //kprintf(" *** COLISION ***");
                return nitem; // Return the index of the collided item
            }
        }
    }

    return ITEM_NONE; // No collision detected
}

u16 detect_char_enemy_collision(u16 nchar, u16 x, u8 y)    // Check for collisions between character and enemies
{
    u16 nenemy;

    if (obj_character[nchar].active == true) {
        // Compute character collision box
        u16 char_col_x1, char_col_x2;
        if (obj_character[nchar].flipH) {
            char_col_x1 = x + obj_character[nchar].x_size - obj_character[nchar].collision_x_offset - obj_character[nchar].collision_width;
            char_col_x2 = char_col_x1 + obj_character[nchar].collision_width;
        } else {
            char_col_x1 = x + obj_character[nchar].collision_x_offset;
            char_col_x2 = char_col_x1 + obj_character[nchar].collision_width;
        }
        u8 char_col_y1 = y + obj_character[nchar].collision_y_offset;
        u8 char_col_y2 = char_col_y1 + obj_character[nchar].collision_height;

        // Check collision with each active enemy
        for (nenemy = 0; nenemy < MAX_ENEMIES; nenemy++) {
            if (obj_enemy[nenemy].obj_character.active == true) {
                // Compute enemy collision box
                u16 enemy_col_x1, enemy_col_x2;
                if (obj_enemy[nenemy].obj_character.flipH) {
                    enemy_col_x1 = obj_enemy[nenemy].obj_character.x + obj_enemy[nenemy].obj_character.x_size - obj_enemy[nenemy].obj_character.collision_x_offset - obj_enemy[nenemy].obj_character.collision_width;
                    enemy_col_x2 = enemy_col_x1 + obj_enemy[nenemy].obj_character.collision_width;
                } else {
                    enemy_col_x1 = obj_enemy[nenemy].obj_character.x + obj_enemy[nenemy].obj_character.collision_x_offset;
                    enemy_col_x2 = enemy_col_x1 + obj_enemy[nenemy].obj_character.collision_width;
                }
                u8 enemy_col_y1 = obj_enemy[nenemy].obj_character.y + obj_enemy[nenemy].obj_character.collision_y_offset;
                u8 enemy_col_y2 = enemy_col_y1 + obj_enemy[nenemy].obj_character.collision_height;

                // Check if collision boxes overlap
                if (char_col_x1 < enemy_col_x2 &&
                    char_col_x2 > enemy_col_x1 &&
                    char_col_y1 < enemy_col_y2 &&
                    char_col_y2 > enemy_col_y1) {
                    if (num_colls<MAX_COLLISIONS) { // Prevent player from being trapped by limiting consecutive collisions
                        num_colls++;
                        return nenemy;
                    } else {
                        num_colls=0;
                        return ENEMY_NONE;
                    }
                }
            }
        }
    }
    
    // No collision detected
    return ENEMY_NONE;
}

u16 detect_enemy_char_collision(u16 nenemy, u16 x, u8 y)    // Check for collisions between enemy and characters
{
    u16 nchar;

    if (obj_enemy[nenemy].obj_character.active == true) {
        // Compute enemy collision box
        u16 enemy_col_x1, enemy_col_x2;
        if (obj_enemy[nenemy].obj_character.flipH) {
            enemy_col_x1 = x + obj_enemy[nenemy].obj_character.x_size - obj_enemy[nenemy].obj_character.collision_x_offset - obj_enemy[nenemy].obj_character.collision_width;
            enemy_col_x2 = enemy_col_x1 + obj_enemy[nenemy].obj_character.collision_width;
        } else {
            enemy_col_x1 = x + obj_enemy[nenemy].obj_character.collision_x_offset;
            enemy_col_x2 = enemy_col_x1 + obj_enemy[nenemy].obj_character.collision_width;
        }
        u8 enemy_col_y1 = y + obj_enemy[nenemy].obj_character.collision_y_offset;
        u8 enemy_col_y2 = enemy_col_y1 + obj_enemy[nenemy].obj_character.collision_height;

        // Check collision with each active character
        for (nchar = 0; nchar < MAX_CHR; nchar++) {
            if (obj_character[nchar].active == true) {
                // Compute character collision box
                u16 char_col_x1, char_col_x2;
                if (obj_character[nchar].flipH) {
                    char_col_x1 = obj_character[nchar].x + obj_character[nchar].x_size - obj_character[nchar].collision_x_offset - obj_character[nchar].collision_width;
                    char_col_x2 = char_col_x1 + obj_character[nchar].collision_width;
                } else {
                    char_col_x1 = obj_character[nchar].x + obj_character[nchar].collision_x_offset;
                    char_col_x2 = char_col_x1 + obj_character[nchar].collision_width;
                }
                u8 char_col_y1 = obj_character[nchar].y + obj_character[nchar].collision_y_offset;
                u8 char_col_y2 = char_col_y1 + obj_character[nchar].collision_height;

                // Check if collision boxes overlap
                if (enemy_col_x1 < char_col_x2 &&
                    enemy_col_x2 > char_col_x1 &&
                    enemy_col_y1 < char_col_y2 &&
                    enemy_col_y2 > char_col_y1) {
                    return nchar;
                }
            }
        }
    }
    
    // No collision detected
    return CHR_NONE;
}

================
File: old_src/combat.c
================
#include "globals.h"
#include "patterns_registry.h"
#include "counter_spell.h"

// Referencia a la máquina de estados del jugador
extern StateMachine player_state_machine;
extern StateMachine enemy_state_machines[MAX_ENEMIES];

bool is_combat_active;    // Whether combat sequence is currently active

/**
 * Combat System
 * 
 * This module handles the core combat mechanics including:
 * - Combat initialization and cleanup
 * - Damage calculation and application
 * - Combat UI management (life counters, enemy faces, note indicators)
 * - State tracking for active combats
 */

void start_combat(bool start)    // Initialize or cleanup combat sequence with UI and enemy states
{
    u8 numenemy, npattern, nnote;

    if (start) {
        // Combat initialization
        setRandomSeed(frame_counter);
        is_combat_active = true;
        player_scroll_active = false;
        
        // Enviar mensaje a la máquina de estados del jugador
        StateMachine_SendMessage(&player_state_machine, MSG_COMBAT_START, 0);

        // Reset enemies to combat-ready state
        for (numenemy = 0; numenemy < MAX_ENEMIES; numenemy++) {
            if (obj_enemy[numenemy].obj_character.active) {
                // Reset enemy HP to max
                obj_enemy[numenemy].hitpoints = obj_enemy[numenemy].class.max_hitpoints;

                // Randomize pattern cooldowns to prevent synchronized attacks
                for (npattern = 0; npattern < MAX_PATTERN_ENEMY; npattern++) {
                    if (obj_enemy[numenemy].class.has_pattern[npattern]) {
                        u16 max_initial_cooldown = obj_Pattern_Enemy[npattern].recharge_time / 2;
                        obj_enemy[numenemy].last_pattern_time[npattern] = random() % max_initial_cooldown;
                    }
                }
            }
            
            // Inicializar la máquina de estados del enemigo
            StateMachine_Init(&enemy_state_machines[numenemy], ENEMY_ENTITY_ID_BASE + numenemy);
            enemy_state_machines[numenemy].owner_type = OWNER_ENEMY;
        }

        // Initialize combat state
        enemy_attacking = ENEMY_NONE;
        enemy_attack_pattern_notes = 0;
        enemy_attack_time = 0;
        enemy_attack_effect_in_progress = false;
        for (nnote = 0; nnote < 6; nnote++) {
            enemy_note_active[nnote] = false;
        }

        // Reset counter-spell state
        counter_spell_success = false;
        pending_counter_hit_enemy = ENEMY_NONE;

        // Setup combat UI
        spr_int_life_counter = SPR_addSprite(&int_life_counter_sprite, 164, 180, TILE_ATTR(PAL2, false, false, false));
        SPR_setVisibility(spr_int_life_counter, HIDDEN);
    }
    else {
        // Combat cleanup
        is_combat_active = false;
        player_scroll_active = true;
        
        // Enviar mensaje a la máquina de estados del jugador
        StateMachine_SendMessage(&player_state_machine, MSG_COMBAT_END, 0);
        
        // Reset all enemy state machines
        for (numenemy = 0; numenemy < MAX_ENEMIES; numenemy++) {
            if (obj_enemy[numenemy].obj_character.active) {
                StateMachine_SendMessage(&enemy_state_machines[numenemy], MSG_COMBAT_END, 0);
            }
        }
        
        // Cleanup life counter sprite
        if (spr_int_life_counter != NULL) {
            SPR_releaseSprite(spr_int_life_counter);
            spr_int_life_counter = NULL;
        }
    }
}

void hit_enemy(u16 nenemy)    // Apply damage to enemy, handle defeat, and update UI
{
    u16 remaining_enemies = 0;

    // Play hit sound effect
    play_sample(snd_player_hit_enemy,sizeof(snd_player_hit_enemy));

    // If enemy was attacking, clean up combat state
    if (enemy_attacking == nenemy) {
        // Clean up all active notes
        cleanup_enemy_notes();
        
        // Reset enemy state
        anim_enemy(nenemy, ANIM_IDLE);
        enemy_attack_effect_in_progress = false;
        obj_enemy[nenemy].obj_character.state = STATE_IDLE;
        if (enemy_attack_pattern < MAX_PATTERN_ENEMY) {
            obj_enemy[nenemy].last_pattern_time[enemy_attack_pattern] = 0;
        }
        enemy_attacking = ENEMY_NONE;
        
        // Hide combat interface
        show_or_hide_enemy_combat_interface(false);
    }

    // Apply damage and check for defeat
    obj_enemy[nenemy].hitpoints--;
    
    // Enviar mensaje a la máquina de estados del enemigo
    StateMachine_SendMessage(&enemy_state_machines[nenemy], MSG_ENEMY_HIT, 0);
    
    if (obj_enemy[nenemy].hitpoints == 0) {
        // Enemy defeated
        SPR_setVisibility(spr_int_life_counter, HIDDEN);
        
        // Enviar mensaje de enemigo derrotado
        StateMachine_SendMessage(&enemy_state_machines[nenemy], MSG_ENEMY_DEFEATED, 0);
        
        release_enemy(nenemy);

        // Check if all enemies defeated
        for (u16 i = 0; i < MAX_ENEMIES; i++) {
            if (obj_enemy[i].obj_character.active) {
                remaining_enemies++;
            }
        }
        
        if (remaining_enemies == 0) {
            start_combat(false);  // End combat when all enemies defeated
        }
    }
    else {
        // Enemy survived - Update UI
        if (spr_int_life_counter != NULL) {
            // Show damage animation
            if (nenemy != enemy_attacking && spr_enemy_face[nenemy] != NULL) {
                SPR_setVisibility(spr_enemy_face[nenemy], VISIBLE);
            }

            // Flash life counter to indicate damage
            SPR_setVisibility(spr_int_life_counter, VISIBLE);
            for (u8 frame = 0; frame < SCREEN_FPS; frame++) {
                // Alternate between current and previous HP for flash effect
                SPR_setAnim(spr_int_life_counter, obj_enemy[nenemy].hitpoints);
                SPR_update();
                SYS_doVBlankProcess();
                SPR_setAnim(spr_int_life_counter, obj_enemy[nenemy].hitpoints - 1);
                SPR_update();
                SYS_doVBlankProcess();
            }

            // Reset UI visibility
            if (nenemy != enemy_attacking && spr_enemy_face[nenemy] != NULL) {
                SPR_setVisibility(spr_enemy_face[nenemy], HIDDEN);
                SPR_setVisibility(spr_int_life_counter, HIDDEN);
            }
        }
    }
}

void hit_caracter(u16 nchar)    // Handle player character damage (currently just sound)
{
    play_sample(snd_player_hurt,sizeof(snd_player_hurt));
    
    // Enviar mensaje a la máquina de estados del jugador
    StateMachine_SendMessage(&player_state_machine, MSG_PLAYER_HIT, 0);
}

void show_or_hide_enemy_combat_interface(bool show)    // Toggle combat UI elements (faces, life counter, notes)
{
    if (show && interface_active && is_combat_active && enemy_attacking != ENEMY_NONE) {
        // Show attacking enemy's interface
        if (spr_enemy_face[enemy_attacking] != NULL) {
            SPR_setVisibility(spr_enemy_face[enemy_attacking], VISIBLE);
        }

        // Hide other enemy faces
        for (u16 i = 0; i < MAX_ENEMIES; i++) {
            if (i != enemy_attacking && spr_enemy_face[i] != NULL) {
                SPR_setVisibility(spr_enemy_face[i], HIDDEN);
            }
        }

        // Update life counter
        if (spr_int_life_counter != NULL) {
            SPR_setVisibility(spr_int_life_counter, VISIBLE);
            SPR_setAnim(spr_int_life_counter, obj_enemy[enemy_attacking].hitpoints - 1);
        }

        // Update note indicators
        for (u8 note = 0; note < 6; note++) {
            show_enemy_note(note + 1, enemy_note_active[note], false);
        }
    }
    else {
        // Hide all interface elements
        for (u16 i = 0; i < MAX_ENEMIES; i++) {
            if (spr_enemy_face[i] != NULL) {
                SPR_setVisibility(spr_enemy_face[i], HIDDEN);
            }
        }

        if (spr_int_life_counter != NULL) {
            SPR_setVisibility(spr_int_life_counter, HIDDEN);
        }

        for (u8 note = 0; note < 6; note++) {
            show_enemy_note(note + 1, false, false);
        }
    }

    SPR_update();
}

/**
 * Actualiza todas las máquinas de estado en combate.
 * Esta función debe llamarse en cada frame durante el combate.
 */
void combat_update(void)
{
    if (!is_combat_active) {
        return;
    }
    
    // Actualizar máquina de estado del jugador
    StateMachine_Update(&player_state_machine, NULL);
    
    // Actualizar máquinas de estado de enemigos
    for (u8 i = 0; i < MAX_ENEMIES; i++) {
        if (obj_enemy[i].obj_character.active) {
            StateMachine_Update(&enemy_state_machines[i], NULL);
        }
    }
}

================
File: old_src/counter_spell.c
================
#include "counter_spell.h"
#include "statemachine.h"
#include "patterns_registry.h"
#include "combat.h"
#include "dialogs.h"
#include "interface.h"

// Global flag for counter-spell success - already defined in enemies_patterns.c
// bool counter_spell_success = false;
// u16 pending_counter_hit_enemy = ENEMY_NONE;

bool can_counter_spell(u16 player_pattern, u16 enemy_pattern, bool is_reverse) {
    // Currently only electric pattern can counter electric enemy pattern when reversed
    if (player_pattern == PTRN_ELECTRIC && 
        enemy_pattern == PTRN_EN_ELECTIC && 
        is_reverse) {
        return true;
    }
    return false;
}

// Helper function to completely reset all state after a counter-spell
void reset_all_states_after_counter_spell(u16 enemy_id) {
    kprintf("Performing complete state reset after counter-spell");
    
    // Reset global flags
    counter_spell_success = false;
    enemy_attack_effect_in_progress = false;
    enemy_attack_pattern = PTRN_EN_NONE;
    enemy_attack_pattern_notes = 0;
    enemy_attack_time = 0;
    enemy_attack_effect_time = 0;
    enemy_attacking = ENEMY_NONE;
    
    // Reset player pattern effect flags
    player_pattern_effect_in_progress = PTRN_NONE;
    player_pattern_effect_reversed = false;
    player_pattern_effect_time = 0;
    
    // Reset player state
    obj_character[active_character].state = STATE_IDLE;
    
    // Reset player state machine - use the global character_state_machines array
    player_state_machine.current_state = SM_STATE_IDLE;
    player_state_machine.pattern_system.effect_in_progress = false;
    player_state_machine.pattern_system.effect_type = PTRN_NONE;
    player_state_machine.pattern_system.effect_duration = 0;
    player_state_machine.pattern_system.effect_reversed = false;
    
    // Reset enemy state
    if (enemy_id != ENEMY_NONE && enemy_id < MAX_ENEMIES) {
        obj_enemy[enemy_id].obj_character.state = STATE_IDLE;
        enemy_state_machines[enemy_id].current_state = SM_STATE_IDLE;
        enemy_state_machines[enemy_id].pattern_system.effect_in_progress = false;
        enemy_state_machines[enemy_id].pattern_system.effect_type = PTRN_NONE;
        enemy_state_machines[enemy_id].pattern_system.effect_duration = 0;
        
        // Reset animations
        anim_enemy(enemy_id, ANIM_IDLE);
    }
    
    // Reset all other enemies too
    for (u8 i = 0; i < MAX_ENEMIES; i++) {
        if (i != enemy_id && obj_enemy[i].obj_character.active) {
            obj_enemy[i].obj_character.state = STATE_IDLE;
            enemy_state_machines[i].current_state = SM_STATE_IDLE;
        }
    }
    
    // Reset visual effects
    VDP_setHilightShadow(false);
    show_pattern_icon(PTRN_ELECTRIC, false, false);
    
    // Update sprites
    SPR_update();
}

void execute_counter_spell(StateMachine* player_sm, StateMachine* enemy_sm, u16 pattern_id) {
    // Set counter-spell success flag
    counter_spell_success = true;
    
    // Update player state machine
    player_sm->current_state = SM_STATE_PATTERN_EFFECT;
    player_sm->active_pattern = pattern_id;
    player_sm->is_reversed = true;
    player_sm->pattern_system.effect_reversed = true;
    
    // Set global player pattern effect flags
    player_pattern_effect_in_progress = pattern_id;
    player_pattern_effect_reversed = true;
    
    // Configure callbacks
    Pattern* pattern = get_pattern(pattern_id, OWNER_PLAYER);
    if (pattern) {
        player_sm->launch_effect = pattern->launch;
        player_sm->do_effect = pattern->do_effect;
        player_sm->finish_effect = pattern->finish;
        
        // Launch the effect
        if (player_sm->launch_effect) {
            player_sm->launch_effect(player_sm);
        }
    }
    
    // Reset all enemy pattern cooldowns to a reasonable value
    // This ensures enemies will attack again soon after a counter-spell
    u16 enemy_id = enemy_sm->entity_id - ENEMY_ENTITY_ID_BASE;
    for (u8 i = 0; i < MAX_PATTERN_ENEMY; i++) {
        if (obj_enemy[enemy_id].obj_character.active) {
            // Set cooldown to 75% of max to allow for a reasonable delay
            obj_enemy[enemy_id].last_pattern_time[i] = obj_Pattern_Enemy[i].recharge_time * 3 / 4;
            kprintf("Reset pattern %d cooldown for enemy %d to %d",
                    i, enemy_id, obj_enemy[enemy_id].last_pattern_time[i]);
        }
    }
    
    // Also reset cooldowns for other enemies
    for (u8 other_enemy = 0; other_enemy < MAX_ENEMIES; other_enemy++) {
        if (other_enemy != enemy_id && obj_enemy[other_enemy].obj_character.active) {
            for (u8 i = 0; i < MAX_PATTERN_ENEMY; i++) {
                // Set cooldown to 50% of max for other enemies to allow them to attack sooner
                obj_enemy[other_enemy].last_pattern_time[i] = obj_Pattern_Enemy[i].recharge_time / 2;
            }
        }
    }
    
    // Hit the enemy - entity_id already includes ENEMY_ENTITY_ID_BASE
    kprintf("Counter spell hitting enemy %d (entity_id: %d)", enemy_id, enemy_sm->entity_id);
    hit_enemy(enemy_id);
    
    // Reset enemy attack state
    enemy_sm->current_state = SM_STATE_IDLE;
    enemy_sm->pattern_system.effect_in_progress = false;
    
    // Visual cleanup
    VDP_setHilightShadow(false);
}

void handle_counter_spell_result(bool success, u16 enemy_id, u16 pattern_id) {
    if (success) {
        // Show success message
        show_or_hide_interface(false);
        show_or_hide_enemy_combat_interface(false);
        talk_dialog(&dialogs[ACT1_DIALOG3][3]); // (ES) "Quizá deba pensar|al revés" - (EN) "I should maybe|think backwards"
        show_or_hide_enemy_combat_interface(true);
        show_or_hide_interface(true);
        
        // Perform a complete reset of all states
        reset_all_states_after_counter_spell(enemy_id);
    } else {
        // Reset counter-spell flag
        counter_spell_success = false;
    }
}

================
File: old_src/counter_spell.h
================
#ifndef COUNTER_SPELL_H
#define COUNTER_SPELL_H

#include "globals.h"

// Forward declarations
struct StateMachine;

// Counter-spell system functions
bool can_counter_spell(u16 player_pattern, u16 enemy_pattern, bool is_reverse);
void reset_all_states_after_counter_spell(u16 enemy_id);
void execute_counter_spell(struct StateMachine* player_sm, struct StateMachine* enemy_sm, u16 pattern_id);
void handle_counter_spell_result(bool success, u16 enemy_id, u16 pattern_id);

// Global flags and variables
extern bool counter_spell_success;
extern u16 pending_counter_hit_enemy;
extern u16 player_pattern_effect_in_progress;
extern bool player_pattern_effect_reversed;

#endif // COUNTER_SPELL_H

================
File: old_src/enemies_patterns.c
================
#include "globals.h"
#include "patterns_registry.h"
#include "counter_spell.h"
#include "pattern_types/enemy_electric_pattern.h"
#include "pattern_types/enemy_bite_pattern.h"

// Referencia a la máquina de estados del jugador
extern StateMachine player_state_machine;

Pattern_Enemy obj_Pattern_Enemy[MAX_PATTERN_ENEMY];    // Stores all enemy pattern definitions
u16 enemy_attacking;                                   // Currently attacking enemy ID
u16 enemy_attack_pattern;                             // Current attack pattern type
u8 enemy_attack_pattern_notes;                        // Index in current note sequence
u16 enemy_attack_time;                                // Attack state timer
bool enemy_attack_effect_in_progress;                 // If attack effect is active
u16 enemy_attack_effect_time;                         // Effect duration timer
bool enemy_note_active[6];                            // Active note indicators
bool counter_spell_success = false;                   // Flag for successful counter-spell
u16 pending_counter_hit_enemy = ENEMY_NONE;           // Enemigo pendiente de recibir contraataque

// State machines for enemies
StateMachine enemy_state_machines[MAX_ENEMIES];       // State machines for each enemy

// Enemy patterns in the registry format
Pattern enemy_patterns[MAX_PATTERN_ENEMY];

void init_enemy_patterns(void)    // Setup enemy attack patterns and timings
{
    // Initialize old pattern system for compatibility
    // Make sure the notes array is properly initialized with all 4 values
    obj_Pattern_Enemy[PTRN_EN_ELECTIC].numnotes = 4;
    obj_Pattern_Enemy[PTRN_EN_ELECTIC].notes[0] = 1;
    obj_Pattern_Enemy[PTRN_EN_ELECTIC].notes[1] = 2;
    obj_Pattern_Enemy[PTRN_EN_ELECTIC].notes[2] = 3;
    obj_Pattern_Enemy[PTRN_EN_ELECTIC].notes[3] = 4;
    obj_Pattern_Enemy[PTRN_EN_ELECTIC].recharge_time = 150;
    
    obj_Pattern_Enemy[PTRN_EN_BITE].numnotes = 3;
    obj_Pattern_Enemy[PTRN_EN_BITE].notes[0] = 2;
    obj_Pattern_Enemy[PTRN_EN_BITE].notes[1] = 3;
    obj_Pattern_Enemy[PTRN_EN_BITE].notes[2] = 2;
    obj_Pattern_Enemy[PTRN_EN_BITE].notes[3] = 0; // Padding
    obj_Pattern_Enemy[PTRN_EN_BITE].recharge_time = 150;
    
    // Debug log the pattern initialization
    kprintf("Enemy patterns initialized (explicit initialization):");
    kprintf("  Electric: %d notes [%d,%d,%d,%d], recharge: %d",
            obj_Pattern_Enemy[PTRN_EN_ELECTIC].numnotes,
            obj_Pattern_Enemy[PTRN_EN_ELECTIC].notes[0],
            obj_Pattern_Enemy[PTRN_EN_ELECTIC].notes[1],
            obj_Pattern_Enemy[PTRN_EN_ELECTIC].notes[2],
            obj_Pattern_Enemy[PTRN_EN_ELECTIC].notes[3],
            obj_Pattern_Enemy[PTRN_EN_ELECTIC].recharge_time);
    kprintf("  Bite: %d notes [%d,%d,%d,%d], recharge: %d",
            obj_Pattern_Enemy[PTRN_EN_BITE].numnotes,
            obj_Pattern_Enemy[PTRN_EN_BITE].notes[0],
            obj_Pattern_Enemy[PTRN_EN_BITE].notes[1],
            obj_Pattern_Enemy[PTRN_EN_BITE].notes[2],
            obj_Pattern_Enemy[PTRN_EN_BITE].notes[3],
            obj_Pattern_Enemy[PTRN_EN_BITE].recharge_time);
    
    // Initialize new pattern system
    enemy_patterns[PTRN_EN_ELECTIC] = (Pattern) {
        .id = PTRN_EN_ELECTIC,
        .active = true,
        .notes = {1,2,3,4},
        .owner_type = OWNER_ENEMY,
        .recharge_time = 150,
        .launch = enemy_electric_pattern_launch,
        .do_effect = enemy_electric_pattern_do,
        .finish = enemy_electric_pattern_finish,
        .sd = NULL
    };
    
    enemy_patterns[PTRN_EN_BITE] = (Pattern) {
        .id = PTRN_EN_BITE,
        .active = true,
        .notes = {2,3,2,0},
        .owner_type = OWNER_ENEMY,
        .recharge_time = 150,
        .launch = bite_pattern_launch,
        .do_effect = bite_pattern_do,
        .finish = bite_pattern_finish,
        .sd = NULL
    };
    
    // Register enemy patterns with the registry
    for (u8 i = 0; i < MAX_PATTERN_ENEMY; i++) {
        register_pattern(&enemy_patterns[i]);
    }
    
    // Initialize state machines for enemies
    for (u8 i = 0; i < MAX_ENEMIES; i++) {
        kprintf("Initializing state machine for enemy %d", i);
        StateMachine_Init(&enemy_state_machines[i], ENEMY_ENTITY_ID_BASE + i);
        enemy_state_machines[i].owner_type = OWNER_ENEMY;
        
        // Debug the initial state
        kprintf("  Enemy %d state machine initial state: %d",
                i, enemy_state_machines[i].current_state);
    }
}

/**
 * Enemy Pattern System
 * 
 * This module handles the enemy attack pattern system, including:
 * - Enemy attack state management
 * - Pattern execution and timing
 * - Visual and sound effects for attacks
 * - Pattern-specific behaviors (thunder, bite)
 * 
 * Enemy attacks flow through several states:
 * 1. STATE_PLAYING_NOTE: Playing attack notes sequence
 * 2. STATE_PATTERN_EFFECT: Executing attack effect
 * 3. STATE_PATTERN_EFFECT_FINISH: Concluding effect
 * 4. STATE_ATTACK_FINISHED: Post-attack cooldown
 * 5. STATE_IDLE: Ready for next attack
 */

void check_enemy_state(void)    // Main state machine for enemy pattern system
{
    u8 numenemy, npattern;
    u16 max_effect_time;
    
    // Process counter spell if still pending
    if (counter_spell_success && pending_counter_hit_enemy != ENEMY_NONE) {
        kprintf("Delayed counter-hit to enemy %d", pending_counter_hit_enemy);
        hit_enemy(pending_counter_hit_enemy);
        pending_counter_hit_enemy = ENEMY_NONE;
        counter_spell_success = false;
        player_pattern_effect_in_progress = PTRN_NONE;
        player_pattern_effect_reversed = false;
        player_state_machine.pattern_system.effect_type = PTRN_NONE;
        player_state_machine.pattern_system.effect_in_progress = false;
        player_state_machine.pattern_system.effect_reversed = false;
        player_state_machine.pattern_system.effect_duration = 0;
    }

    // Log the current state every 60 frames
    if (frame_counter % 60 == 0) {
        kprintf("ENEMY STATE CHECK: enemy=%d, pattern=%d, effect_in_progress=%d",
                enemy_attacking, enemy_attack_pattern, enemy_attack_effect_in_progress);
    }
    
    // Update all enemy state machines
    for (u8 i = 0; i < MAX_ENEMIES; i++) {
        if (obj_enemy[i].obj_character.active) {
            // Debug state before update
            if (i == enemy_attacking) {
                kprintf("Enemy %d state BEFORE state machine update: %d",
                        i, obj_enemy[i].obj_character.state);
            }
            
            StateMachine_Update(&enemy_state_machines[i], NULL);
            
            // Debug state machine state
            if (i == enemy_attacking) {
                kprintf("Enemy %d state machine state AFTER update: %d",
                        i, enemy_state_machines[i].current_state);
            }
            
            // Update entity state from state machine
            if (i == enemy_attacking) {
                kprintf("Enemy %d state BEFORE applying state machine state: %d",
                        i, obj_enemy[i].obj_character.state);
            }
            
            update_character_from_sm_state(&obj_enemy[i].obj_character,
                                          enemy_state_machines[i].current_state);
            
            // Debug state after update
            if (i == enemy_attacking) {
                kprintf("Enemy %d state AFTER applying state machine state: %d",
                        i, obj_enemy[i].obj_character.state);
            }
        }
    }
    
    // We're now handling counter-spell cooldowns in counter_spell.c
    
    // Check for new attack opportunities when no attack is in progress
    if (!enemy_attack_effect_in_progress && enemy_attacking == ENEMY_NONE) {
        // Check if player is currently casting a spell or has an active effect
        bool player_is_casting = (obj_character[active_character].state == STATE_PLAYING_NOTE ||
                                obj_character[active_character].state == STATE_PATTERN_CHECK ||
                                obj_character[active_character].state == STATE_PATTERN_EFFECT ||
                                obj_character[active_character].state == STATE_PATTERN_EFFECT_FINISH);
        
        // Check if player has an active counter-spell
        bool player_has_counter = (player_pattern_effect_in_progress != PTRN_NONE &&
                                 player_pattern_effect_reversed);
        
        // Log when we're checking for new attacks (less frequently)
        if (frame_counter % 180 == 0) {
            kprintf("CHECKING FOR NEW ATTACKS: player_casting=%d, player_counter=%d",
                    player_is_casting, player_has_counter);
        }
        
        // Only allow enemy attacks if player is not casting and has no counter active
        if (!player_is_casting && !player_has_counter) {
            for (numenemy = 0; numenemy < MAX_ENEMIES; numenemy++) {
                if (obj_enemy[numenemy].obj_character.active) {
                    for (npattern = 0; npattern < MAX_PATTERN_ENEMY; npattern++) {
                        if (obj_enemy[numenemy].class.has_pattern[npattern]) {
                            // Check if pattern cooldown is complete
                            if (obj_enemy[numenemy].last_pattern_time[npattern] == obj_Pattern_Enemy[npattern].recharge_time) {
                                if (player_pattern_effect_in_progress == PTRN_HIDE) {
                                    // Reduce cooldown if player is hidden
                                    obj_enemy[numenemy].last_pattern_time[npattern] -= 50;
                                } else {
                                    // Start new attack sequence using state machine
                                    enemy_attack_pattern_notes = 0;
                                    enemy_attack_time = 0;
                                    enemy_attack_pattern = npattern;
                                    enemy_attacking = numenemy;
                                    
                                    // Get pattern from registry
                                    Pattern* pattern = get_pattern(npattern, OWNER_ENEMY);
                                    
                                    // Configure state machine with pattern callbacks
                                    if (pattern) {
                                        enemy_state_machines[numenemy].launch_effect = pattern->launch;
                                        enemy_state_machines[numenemy].do_effect = pattern->do_effect;
                                        enemy_state_machines[numenemy].finish_effect = pattern->finish;
                                    }
                                    
                                    // Start with playing notes instead of going directly to effect
                                    // Maintain compatibility with existing code
                                    kprintf("Starting enemy attack sequence: enemy=%d, pattern=%d", numenemy, npattern);
                                    kprintf("Enemy state before: %d", obj_enemy[numenemy].obj_character.state);
                                    
                                    anim_enemy(numenemy, ANIM_ACTION);
                                    
                                    // Set the state in both the character and the state machine
                                    obj_enemy[numenemy].obj_character.state = STATE_PLAYING_NOTE;
                                    enemy_state_machines[numenemy].current_state = SM_STATE_PLAYING_NOTE;
                                    
                                    kprintf("Enemy state after setting to STATE_PLAYING_NOTE (%d): %d",
                                            STATE_PLAYING_NOTE,
                                            obj_enemy[numenemy].obj_character.state);
                                    kprintf("Enemy state machine state after setting: %d",
                                            enemy_state_machines[numenemy].current_state);
                                    
                                    // Prevent state machine from overriding our state
                                    enemy_state_machines[numenemy].note_time = 0;
                                    
                                    show_enemy_note(obj_Pattern_Enemy[enemy_attack_pattern].notes[0], true, true);
                                    show_or_hide_enemy_combat_interface(true);
                                    
                                    // Configure state machine with pattern callbacks
                                    // But don't send the pattern complete message yet - that happens after notes
                                }
                            } else {
                                // Random cooldown progression
                                if ((random() % 2) == 0) {
                                    obj_enemy[numenemy].last_pattern_time[npattern]++;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Process active attack states
    if (enemy_attacking != ENEMY_NONE) {
        // Debug the enemy state less frequently (every 180 frames)
        if (frame_counter % 180 == 0) {
            kprintf("Enemy %d active attack state: %d, pattern: %d, note: %d/%d, time: %d",
                    enemy_attacking,
                    obj_enemy[enemy_attacking].obj_character.state,
                    enemy_attack_pattern,
                    enemy_attack_pattern_notes + 1,
                    obj_Pattern_Enemy[enemy_attack_pattern].numnotes,
                    enemy_attack_time);
        }
        
        switch (obj_enemy[enemy_attacking].obj_character.state)
        {
            case STATE_PLAYING_NOTE:
                // Handle note duration
                u16 max_time = calc_ticks(MAX_ATTACK_NOTE_PLAYING_TIME);
                
                // Debug the calculation and current state
                if (enemy_attack_time == 0) {
                    kprintf("ENEMY NOTE START: MAX_ATTACK_NOTE_PLAYING_TIME = %d ms, calculated ticks = %d",
                            MAX_ATTACK_NOTE_PLAYING_TIME, max_time);
                    kprintf("ENEMY NOTE INFO: enemy=%d, pattern=%d, note_index=%d, note_value=%d",
                            enemy_attacking,
                            enemy_attack_pattern,
                            enemy_attack_pattern_notes,
                            obj_Pattern_Enemy[enemy_attack_pattern].notes[enemy_attack_pattern_notes]);
                }
                
                // Force the state machine to stay in PLAYING_NOTE state
                enemy_state_machines[enemy_attacking].current_state = SM_STATE_PLAYING_NOTE;
                
                // Safety check - if we've been in this state for too long, reset
                if (enemy_attack_time > max_time * 3) {
                    kprintf("WARNING: Enemy stuck in STATE_PLAYING_NOTE for too long, resetting");
                    obj_enemy[enemy_attacking].obj_character.state = STATE_IDLE;
                    enemy_state_machines[enemy_attacking].current_state = SM_STATE_IDLE;
                    enemy_attacking = 254; // ENEMY_NONE
                    enemy_attack_effect_in_progress = false;
                    show_enemy_note(obj_Pattern_Enemy[enemy_attack_pattern].notes[enemy_attack_pattern_notes], false, false);
                    show_or_hide_enemy_combat_interface(false);
                    break;
                }
                
                if (enemy_attack_time < max_time) {
                    enemy_attack_time++;
                    
                    // Log less frequently (every 10 frames)
                    if (enemy_attack_time % 10 == 0) {
                        kprintf("Enemy note playing time: %d/%d",
                                enemy_attack_time, max_time);
                    }
                } else {
                    // Current note finished
                    kprintf("Enemy note time reached max (%d frames), finishing note", max_time);
                    show_enemy_note(obj_Pattern_Enemy[enemy_attack_pattern].notes[enemy_attack_pattern_notes], false, false);
                    
                    // Debug log with more details
                    kprintf("Enemy note %d finished, pattern has %d notes total",
                            enemy_attack_pattern_notes + 1,
                            obj_Pattern_Enemy[enemy_attack_pattern].numnotes);
                    
                    // Dump the entire pattern for debugging
                    kprintf("Full pattern: [%d,%d,%d,%d], current position: %d",
                            obj_Pattern_Enemy[enemy_attack_pattern].notes[0],
                            obj_Pattern_Enemy[enemy_attack_pattern].notes[1],
                            obj_Pattern_Enemy[enemy_attack_pattern].notes[2],
                            obj_Pattern_Enemy[enemy_attack_pattern].notes[3],
                            enemy_attack_pattern_notes);
                    
                    if (enemy_attack_pattern_notes < obj_Pattern_Enemy[enemy_attack_pattern].numnotes - 1) {
                        // Continue to next note in sequence
                        enemy_attack_pattern_notes++;
                        enemy_attack_time = 0;
                        
                        // Debug log with more details
                        kprintf("Playing next enemy note: %d (index %d of %d)",
                                obj_Pattern_Enemy[enemy_attack_pattern].notes[enemy_attack_pattern_notes],
                                enemy_attack_pattern_notes + 1,
                                obj_Pattern_Enemy[enemy_attack_pattern].numnotes);
                        
                        // Make sure the note is valid
                        u8 next_note = obj_Pattern_Enemy[enemy_attack_pattern].notes[enemy_attack_pattern_notes];
                        if (next_note >= 1 && next_note <= 6) {
                            show_enemy_note(next_note, true, true);
                        } else {
                            kprintf("ERROR: Invalid note value: %d", next_note);
                        }
                    } else {
                        // All notes complete, start effect
                        kprintf("All enemy notes complete (%d/%d), transitioning to effect phase",
                                enemy_attack_pattern_notes + 1,
                                obj_Pattern_Enemy[enemy_attack_pattern].numnotes);
                        
                        // Debug the pattern one more time
                        kprintf("Final pattern state: notes played = %d, pattern length = %d",
                                enemy_attack_pattern_notes + 1,
                                obj_Pattern_Enemy[enemy_attack_pattern].numnotes);
                        
                        // Debug the enemy state
                        kprintf("Enemy %d state before transition: %d",
                                enemy_attacking,
                                obj_enemy[enemy_attacking].obj_character.state);
                                
                        // Set both the entity state and the state machine state
                        obj_enemy[enemy_attacking].obj_character.state = STATE_PATTERN_EFFECT;
                        enemy_state_machines[enemy_attacking].current_state = SM_STATE_PATTERN_EFFECT;
                        
                        // Set the effect flags
                        enemy_attack_effect_in_progress = true;
                        enemy_attack_effect_time = 0;
                        enemy_state_machines[enemy_attacking].pattern_system.effect_in_progress = true;
                        enemy_state_machines[enemy_attacking].pattern_system.effect_type = enemy_attack_pattern;
                        enemy_state_machines[enemy_attacking].pattern_system.effect_duration = 0;
                        
                        // Debug the enemy state after transition
                        kprintf("Enemy %d state after transition: %d, state machine state: %d",
                                enemy_attacking,
                                obj_enemy[enemy_attacking].obj_character.state,
                                enemy_state_machines[enemy_attacking].current_state);
                        
                        // Get pattern from registry
                        Pattern* pattern = get_pattern(enemy_attack_pattern, OWNER_ENEMY);
                        
                        // Debug log
                        kprintf("Got pattern from registry: %s",
                                pattern ? "SUCCESS" : "FAILED");
                        
                        // Launch effect using pattern callbacks
                        if (pattern && pattern->launch) {
                            kprintf("Launching enemy pattern effect using registry callback");
                            pattern->launch(&enemy_state_machines[enemy_attacking]);
                        } else {
                            // Fallback to old system
                            kprintf("Using fallback (old system) for enemy pattern effect");
                            switch (enemy_attack_pattern) {
                                case PTRN_EN_ELECTIC:
                                    kprintf("Launching electric enemy pattern (fallback)");
                                    launch_electric_enemy_pattern();
                                    break;
                                case PTRN_EN_BITE:
                                    kprintf("Launching bite enemy pattern (fallback)");
                                    launch_bite_enemy_pattern();
                                    break;
                                default:
                                    kprintf("ERROR: Unknown enemy pattern type: %d", enemy_attack_pattern);
                                    break;
                            }
                        }
                    }
                    show_or_hide_enemy_combat_interface(true);
                }
                break;

            case STATE_PATTERN_EFFECT:
                // Force the state machine to stay in PATTERN_EFFECT state
                enemy_state_machines[enemy_attacking].current_state = SM_STATE_PATTERN_EFFECT;
                
                // Safety check - if we've been in this state for too long, reset
                if (enemy_attack_effect_time > 300) {  // ~5 seconds at 60fps
                    kprintf("WARNING: Enemy stuck in STATE_PATTERN_EFFECT for too long, resetting");
                    obj_enemy[enemy_attacking].obj_character.state = STATE_IDLE;
                    enemy_state_machines[enemy_attacking].current_state = SM_STATE_IDLE;
                    enemy_attacking = 254; // ENEMY_NONE
                    enemy_attack_effect_in_progress = false;
                    VDP_setHilightShadow(false); // Ensure visual effects are disabled
                    show_or_hide_enemy_combat_interface(false);
                    break;
                }
                
                // Set effect duration based on pattern type
                switch (enemy_attack_pattern) {
                    case PTRN_EN_ELECTIC:
                        max_effect_time = calc_ticks(MAX_EFFECT_TIME_ELECTRIC);
                        break;
                    case PTRN_EN_BITE:
                        max_effect_time = calc_ticks(MAX_EFFECT_TIME_BITE);
                        break;
                    default:
                        max_effect_time = 100;
                }

                // Apply effect while duration not exceeded
                if (enemy_attack_effect_time < max_effect_time) {
                    // Log less frequently (every 60 frames)
                    if (enemy_attack_effect_time % 60 == 0) {
                        kprintf("Enemy effect in progress: %d/%d",
                                enemy_attack_effect_time,
                                max_effect_time);
                    }
                    
                    // Get pattern from registry
                    Pattern* pattern = get_pattern(enemy_attack_pattern, OWNER_ENEMY);
                    
                    // Process effect using pattern callbacks
                    if (pattern && pattern->do_effect) {
                        // Only log on first frame
                        if (enemy_attack_effect_time == 0) {
                            kprintf("Starting pattern effect for enemy %d, pattern %d",
                                    enemy_attacking, enemy_attack_pattern);
                        }
                        pattern->do_effect(&enemy_state_machines[enemy_attacking]);
                    } else {
                        // Fallback to old system
                        switch (enemy_attack_pattern) {
                            case PTRN_EN_ELECTIC:
                                do_electric_enemy_pattern_effect();
                                break;
                            case PTRN_EN_BITE:
                                do_bite_enemy_pattern_effect();
                                break;
                            default:
                                kprintf("ERROR: Unknown enemy pattern type in effect phase: %d", enemy_attack_pattern);
                                break;
                        }
                    }
                    enemy_attack_effect_time++;
                }

                // Check for effect completion
                if (enemy_attack_effect_time == max_effect_time) {
                    if (num_played_notes != 0) {
                        // Wait for player to finish their pattern
                        enemy_attack_effect_time--;
                    } else {
                        // Move to effect completion
                        obj_enemy[enemy_attacking].obj_character.state = STATE_PATTERN_EFFECT_FINISH;
                    }
                }
                break;

            case STATE_PATTERN_EFFECT_FINISH:
                // Clean up effect and transition to post-attack state
                // Get pattern from registry
                Pattern* pattern = get_pattern(enemy_attack_pattern, OWNER_ENEMY);
                
                // Finish effect using pattern callbacks
                if (pattern && pattern->finish) {
                    pattern->finish(&enemy_state_machines[enemy_attacking]);
                } else {
                    // Fallback to old system
                    finish_enemy_pattern_effect();
                }
                
                obj_enemy[enemy_attacking].obj_character.state = STATE_ATTACK_FINISHED;
                enemy_attack_time = 0;
                break;

            case STATE_ATTACK_FINISHED:
                // Wait in finished state before returning to idle
                if (enemy_attack_time < calc_ticks(MAX_TIME_AFTER_ATTACK)) {
                    enemy_attack_time++;
                } else {
                    obj_enemy[enemy_attacking].obj_character.state = STATE_IDLE;
                    enemy_attacking = ENEMY_NONE;
                    show_or_hide_enemy_combat_interface(false);
                }
                break;

            default:
                break;
        }
    }
}

void show_enemy_note(u8 nnote, bool visible, bool play)    // Display/play enemy note (1-6:MI-DO), manage sprites and sound
{
    Sprite **rodsprite;
    const SpriteDefinition *rodspritedef;
    const u8 *notesong;
    u16 rod_x;

    // Configure sprite and sound based on note
    switch (nnote) 
    {
    case NOTE_MI:
        rodsprite = &spr_int_enemy_rod_1;
        rodspritedef = &int_enemy_rod_1_sprite;
        notesong = snd_enemy_note_mi;
        rod_x = 24;
        break;
    case NOTE_FA:
        rodsprite = &spr_int_enemy_rod_2;
        rodspritedef = &int_enemy_rod_2_sprite;
        notesong = snd_enemy_note_fa;
        rod_x = 24 + 32;
        break;
    case NOTE_SOL:
        rodsprite = &spr_int_enemy_rod_3;
        rodspritedef = &int_enemy_rod_3_sprite;
        notesong = snd_enemy_note_sol;
        rod_x = 24 + 64;
        break;
    case NOTE_LA:
        rodsprite = &spr_int_enemy_rod_4;
        rodspritedef = &int_enemy_rod_4_sprite;
        notesong = snd_enemy_note_la;
        rod_x = 24 + 96;
        break;
    case NOTE_SI:
        rodsprite = &spr_int_enemy_rod_5;
        rodspritedef = &int_enemy_rod_5_sprite;
        notesong = snd_enemy_note_si;
        rod_x = 24 + 128;
        break;
    default: // NOTE_DO
        rodsprite = &spr_int_enemy_rod_6;
        rodspritedef = &int_enemy_rod_6_sprite;
        notesong = snd_enemy_note_do;
        rod_x = 24 + 160;
        break;
    }

    if (visible) {
        // Show note sprite and play sound
        if (*rodsprite == NULL) {
            *rodsprite = SPR_addSpriteSafe(rodspritedef, rod_x, 184, TILE_ATTR(PAL2, false, false, false));
            if (*rodsprite == NULL) return;
        }
        SPR_setVisibility(*rodsprite, VISIBLE);
        enemy_note_active[nnote - 1] = true;
        if (play) play_music(notesong);
    } else {
        // Hide and cleanup note sprite
        if (*rodsprite != NULL) {
            SPR_releaseSprite(*rodsprite);
            *rodsprite = NULL;
            enemy_note_active[nnote - 1] = false;
        }
    }
}

void finish_enemy_pattern_effect(void)    // Clean up and finish enemy attack pattern effects
{
    kprintf("FINISH_ENEMY_PATTERN_EFFECT called: enemy=%d, pattern=%d",
            enemy_attacking, enemy_attack_pattern);
    
    // Reset enemy state
    anim_enemy(enemy_attacking, ANIM_IDLE);
    
    // Set the cooldown to 50% of the recharge time to allow the enemy to attack again after a delay
    // This is less than the 75% used for counter-spells, so enemies will attack sooner after normal attacks
    if (enemy_attacking != ENEMY_NONE && enemy_attack_pattern != PTRN_EN_NONE) {
        obj_enemy[enemy_attacking].last_pattern_time[enemy_attack_pattern] = obj_Pattern_Enemy[enemy_attack_pattern].recharge_time / 2;
        kprintf("  - Set cooldown for enemy %d pattern %d to %d",
                enemy_attacking, enemy_attack_pattern, obj_Pattern_Enemy[enemy_attack_pattern].recharge_time / 2);
    }
    
    enemy_attack_effect_time = 0;
    enemy_attack_effect_in_progress = false;

    // Apply final pattern effects
    switch (enemy_attack_pattern) {
        case PTRN_EN_ELECTIC:
            finish_electric_enemy_pattern_effect();
            break;
        case PTRN_EN_BITE:
            finish_bite_enemy_pattern_effect();
            break;
    }
}

/******************************************************************************
 *                        Pattern-Specific Effects                             *
 ******************************************************************************/

// These functions are now implemented in pattern_types/enemy_electric_pattern.c
void launch_electric_enemy_pattern(void) { /* Deprecated */ }
void do_electric_enemy_pattern_effect(void) { /* Deprecated */ }
void finish_electric_enemy_pattern_effect(void) { /* Deprecated */ }

// These functions are now implemented in pattern_types/bite_pattern.c
void launch_bite_enemy_pattern(void) { /* Deprecated */ }
void do_bite_enemy_pattern_effect(void) { /* Deprecated */ }
void finish_bite_enemy_pattern_effect(void) { /* Deprecated */ }

void cleanup_enemy_notes(void)    // Clean up all active enemy notes when resetting combat
{
    // Clean up all note sprites and states
    for (u8 note = 0; note < 6; note++) {
        if (enemy_note_active[note]) {
            show_enemy_note(note + 1, false, false);
            enemy_note_active[note] = false;
        }
    }
}

================
File: old_src/enemies_patterns.h
================
#ifndef _ENM_PATTERNS_H_
#define _ENM_PATTERNS_H_

#include "globals.h"

// Enemy Patterns
#define MAX_PATTERN_ENEMY 2

#define PTRN_EN_NONE         254
#define PTRN_EN_ELECTIC      0   // Electricity spell
#define PTRN_EN_BITE         1   // Bite Spell

#define MAX_ATTACK_NOTE_PLAYING_TIME  300  // Attack note playing time (in milliseconds)
#define MAX_TIME_AFTER_ATTACK        1000  // Time to stay in STATE_ATTACK_FINISHED (in milliseconds)

// Pattern-specific max effect times (in milliseconds)
#define MAX_EFFECT_TIME_ELECTRIC 1600
#define MAX_EFFECT_TIME_BITE     1400

// Enemy pattern struct
typedef struct
{
    u8 numnotes;
    u8 notes[4];
    u16 recharge_time;
} Pattern_Enemy;
extern Pattern_Enemy obj_Pattern_Enemy[MAX_PATTERN_ENEMY]; // Enemie pattern object

// ********  OLD COMBAT SYSTEM (replace with context) **********
// Enemy pattern state variables
extern u16 enemy_attacking; // Which enemy is attacking?
extern u16 enemy_attack_pattern; // Which pattern is the enemy using?
extern u8 enemy_attack_pattern_notes; // How many notes has the enemy launched yet?
extern u16 enemy_attack_time; // How long is the enemy attacking?
extern bool enemy_attack_effect_in_progress; // An enemy pattern attack effect is in progress
extern u16 enemy_attack_effect_time; // How long has been the enemy pattern effect working?
extern bool enemy_note_active[6]; // Is the note # MI-DO active?
extern bool counter_spell_success; // Flag indicating a counter-spell has successfully hit
extern u16 pending_counter_hit_enemy; // Enemigo pendiente de recibir contraataque

// ******* OLD COMBAT SYSTEM (replace with context) **********
// State machines for enemies
extern StateMachine enemy_state_machines[MAX_ENEMIES];

// Initialization function
void init_enemy_patterns(void); // initialize enemy patterns

// Main state machine function
void check_enemy_state(void); // Main state machine for enemy pattern system

// Helper functions
void show_enemy_note(u8 nnote, bool visible, bool play); // Show and play (or not) an enemy note
void finish_enemy_pattern_effect(void); // Finish the enemy pattern effect
void cleanup_enemy_notes(void); //Clean up all active enemy notes

// Pattern-specific effect functions
void launch_electric_enemy_pattern(void);
void do_electric_enemy_pattern_effect(void);
void finish_electric_enemy_pattern_effect(void);

void launch_bite_enemy_pattern(void);
void do_bite_enemy_pattern_effect(void);
void finish_bite_enemy_pattern_effect(void);

#endif

================
File: old_src/pattern_types/electric_pattern.c
================
#include "electric_pattern.h"
#include "../statemachine.h"
#include "../counter_spell.h"
#include "../combat.h"
#include "../dialogs.h"
#include "../interface.h"
#include "../characters.h"
#include "../enemies.h"

// External variables needed
extern bool is_combat_active;
extern u16 enemy_attacking;
extern u16 enemy_attack_pattern;
extern bool enemy_attack_effect_in_progress;
extern u16 player_pattern_effect_in_progress;
extern u16 player_pattern_effect_time;
extern bool player_pattern_effect_reversed;
extern u16 active_character;

bool electric_pattern_can_use(void) {
    // Check if we're in combat with an enemy using electric attack
    if (is_combat_active && enemy_attacking != ENEMY_NONE &&
        enemy_attack_effect_in_progress && enemy_attack_pattern == PTRN_EN_ELECTIC) {
        return true;
    }
    
    // Check if player is hidden
    if (player_pattern_effect_in_progress == PTRN_HIDE) {
        // Can't use thunder while hidden
        show_or_hide_interface(false);
        show_or_hide_enemy_combat_interface(false);
        talk_dialog(&dialogs[ACT1_DIALOG3][9]); // (ES) "No puedo lanzar hechizos|si estoy escondido" - (EN) "I can't launch spells|while hiding"
        show_or_hide_enemy_combat_interface(true);
        show_or_hide_interface(true);
        return false;
    }
    
    return true;
}

void electric_pattern_launch(StateMachine* sm) {
    // Visual and sound effects
    anim_character(sm->entity_id, ANIM_MAGIC);
    show_pattern_icon(PTRN_ELECTRIC, true, true);
    play_pattern_sound(PTRN_ELECTRIC);
    
    // Update state machine
    sm->pattern_system.effect_type = PTRN_ELECTRIC;
    sm->pattern_system.effect_in_progress = true;
    sm->pattern_system.effect_duration = 0;
    
    // For compatibility with existing code
    player_pattern_effect_in_progress = PTRN_ELECTRIC;
    player_pattern_effect_time = 0;
    player_pattern_effect_reversed = sm->is_reversed;
}

void electric_pattern_do(StateMachine* sm) {
    // If a counter-spell has succeeded, finish immediately
    if (counter_spell_success && sm->is_reversed) {
        kprintf("Counter spell succeeded, finishing electric pattern effect");
        
        // Reset state machine
        sm->current_state = SM_STATE_IDLE;
        sm->timer = 0;
        sm->effect_time = 0;
        sm->pattern_system.effect_in_progress = false;
        sm->pattern_system.effect_type = PTRN_NONE;
        sm->pattern_system.effect_duration = 0;
        
        // Reset visual effects
        VDP_setHilightShadow(false);
        show_pattern_icon(PTRN_ELECTRIC, false, false);
        
        // Reset global state
        player_pattern_effect_in_progress = PTRN_NONE;
        player_pattern_effect_time = 0;
        player_pattern_effect_reversed = false;
        
        // Update character animation
        obj_character[active_character].state = STATE_IDLE;
        anim_character(active_character, ANIM_IDLE);
        
        return;
    }
    
    // Visual thunder effect
    VDP_setHilightShadow((sm->pattern_system.effect_duration % 2) == 0);
    SPR_update();
    SYS_doVBlankProcess();
    
    // Apply combat effects
    if (is_combat_active && sm->pattern_system.effect_duration == 10) {
        for (u16 nenemy = 0; nenemy < MAX_ENEMIES; nenemy++) {
            if (obj_enemy[nenemy].obj_character.active &&
                obj_enemy[nenemy].class_id == ENEMY_CLS_3HEADMONKEY &&
                obj_enemy[nenemy].hitpoints > 0) {
                hit_enemy(nenemy);
                if (enemy_attack_pattern == PTRN_EN_BITE) {
                    enemy_attack_pattern = PTRN_EN_NONE;
                    finish_enemy_pattern_effect();
                }
            }
        }
    }
    
    // Update duration
    sm->pattern_system.effect_duration++;
    
    // For compatibility with existing code
    player_pattern_effect_time++;
    
    // Check if effect is complete
    if (sm->pattern_system.effect_duration >= 20) {
        // Ensure visual effect is disabled
        VDP_setHilightShadow(false);
        show_pattern_icon(PTRN_ELECTRIC, false, false);
        SPR_update();
        sm->current_state = SM_STATE_PATTERN_EFFECT_FINISH;
    }
}

void electric_pattern_finish(StateMachine* sm) {
    // Ensure visual effect is disabled
    VDP_setHilightShadow(false);
    show_pattern_icon(PTRN_ELECTRIC, false, false);
    SPR_update();
    
    // Reset state
    sm->pattern_system.effect_type = PTRN_NONE;
    sm->pattern_system.effect_in_progress = false;
    sm->pattern_system.effect_duration = 0;
    
    // For compatibility with existing code
    player_pattern_effect_in_progress = PTRN_NONE;
    player_pattern_effect_time = 0;
    player_pattern_effect_reversed = false;
    
    // Update character animation
    obj_character[active_character].state = STATE_IDLE;
    anim_character(active_character, ANIM_IDLE);
    update_character_animation();
}

================
File: old_src/pattern_types/electric_pattern.h
================
#ifndef ELECTRIC_PATTERN_H
#define ELECTRIC_PATTERN_H

#include "../globals.h"

// Forward declarations
struct StateMachine;

// Electric pattern functions
bool electric_pattern_can_use(void);
void electric_pattern_launch(struct StateMachine* sm);
void electric_pattern_do(struct StateMachine* sm);
void electric_pattern_finish(struct StateMachine* sm);

#endif // ELECTRIC_PATTERN_H

================
File: old_src/pattern_types/enemy_bite_pattern.c
================
#include "enemy_bite_pattern.h"
#include "../statemachine.h"
#include "../characters.h"
#include "../enemies.h"
#include "../combat.h"
#include "../dialogs.h"
#include "../interface.h"

// External variables needed
extern u16 player_pattern_effect_in_progress;
extern u16 active_character;

void bite_pattern_launch(StateMachine* sm) {
    // Visual effect - enemy animation
    u16 enemy_id = sm->entity_id - ENEMY_ENTITY_ID_BASE;
    anim_enemy(enemy_id, ANIM_MAGIC);
}

void bite_pattern_do(StateMachine* sm) {
    // If player is hidden, extend the effect time to avoid damage
    if (player_pattern_effect_in_progress == PTRN_HIDE) {
        // Keep the effect going but don't apply damage
        if (sm->pattern_system.effect_duration >= calc_ticks(MAX_EFFECT_TIME_BITE) - 1) {
            sm->pattern_system.effect_duration = calc_ticks(MAX_EFFECT_TIME_BITE) - 1;
        }
    }
    
    // Update duration
    sm->pattern_system.effect_duration++;
}

void bite_pattern_finish(StateMachine* sm) {
    kprintf("bite_pattern_finish called for enemy %d", sm->entity_id - ENEMY_ENTITY_ID_BASE);
    
    // If player is hidden, skip damage
    if (player_pattern_effect_in_progress == PTRN_HIDE) {
        kprintf("Player is hidden, skipping damage");
        return;
    }

    // Player failed to hide - apply damage
    kprintf("Player failed to hide, applying damage");
    show_character(active_character, true);
    hit_caracter(active_character);
    
    // Show dialog
    show_or_hide_interface(false);
    show_or_hide_enemy_combat_interface(false);
    talk_dialog(&dialogs[ACT1_DIALOG3][2]); // (ES) "Eso ha dolido" - (EN) "That hurts"
    talk_dialog(&dialogs[ACT1_DIALOG3][4]); // (ES) "Puedo probar a esconderme|o tratar de invocar|al trueno" - (EN) "I could try to hide|or attempt to summon|the thunder"
    show_or_hide_interface(true);
    show_or_hide_enemy_combat_interface(true);
    
    // Reset enemy state
    u16 enemy_id = sm->entity_id - ENEMY_ENTITY_ID_BASE;
    anim_enemy(enemy_id, ANIM_IDLE);
    
    // Reset all effect flags
    enemy_attack_effect_in_progress = false;
    sm->pattern_system.effect_in_progress = false;
    sm->pattern_system.effect_type = PTRN_NONE;
    sm->pattern_system.effect_duration = 0;
    
    // Reset enemy state
    obj_enemy[enemy_id].obj_character.state = STATE_IDLE;
    sm->current_state = SM_STATE_IDLE;
    
    // Reset attack state
    if (enemy_attacking == enemy_id) {
        kprintf("Resetting enemy_attacking from %d to ENEMY_NONE", enemy_attacking);
        enemy_attacking = 254; // ENEMY_NONE value (254)
    }
}

================
File: old_src/pattern_types/enemy_bite_pattern.h
================
#ifndef BITE_PATTERN_H
#define BITE_PATTERN_H

#include "../globals.h"

// Forward declarations
struct StateMachine;

// External variables needed
extern u16 enemy_attacking;
extern bool enemy_attack_effect_in_progress;
// ENEMY_NONE is a macro defined in enemies.h

// Bite pattern functions
void bite_pattern_launch(struct StateMachine* sm);
void bite_pattern_do(struct StateMachine* sm);
void bite_pattern_finish(struct StateMachine* sm);

#endif // BITE_PATTERN_H

================
File: old_src/pattern_types/enemy_electric_pattern.c
================
#include "enemy_electric_pattern.h"
#include "../statemachine.h"
#include "../counter_spell.h"
#include "../characters.h"
#include "../enemies.h"
#include "../combat.h"
#include "../dialogs.h"
#include "../interface.h"

// External variables needed
extern u16 player_pattern_effect_in_progress;
extern bool player_pattern_effect_reversed;
extern u16 active_character;
extern u16 enemy_attack_pattern;
extern u16 enemy_attack_effect_time;
extern bool enemy_attack_effect_in_progress;

void enemy_electric_pattern_launch(StateMachine* sm) {
    // Visual effect - enemy animation and sound
    u16 enemy_id = sm->entity_id - ENEMY_ENTITY_ID_BASE;
    anim_enemy(enemy_id, ANIM_MAGIC);
    play_pattern_sound(PTRN_ELECTRIC);
}

void enemy_electric_pattern_do(StateMachine* sm) {
    // Only log every 60 frames to reduce spam
    if (sm->pattern_system.effect_duration % 60 == 0) {
        kprintf("enemy_electric_pattern_do: effect_duration=%d", sm->pattern_system.effect_duration);
    }
    
    // Visual thunder effect
    VDP_setHilightShadow((sm->pattern_system.effect_duration % 2) == 0);
    SPR_update();
    
    // Increment the effect duration
    sm->pattern_system.effect_duration++;

    // If counter-spell already succeeded, don't do anything
    if (counter_spell_success) {
        return;
    }
    
    // Check if player is currently playing notes
    bool player_is_playing_notes = (obj_character[active_character].state == STATE_PLAYING_NOTE ||
                                  num_played_notes > 0);
    
    // Create lightning flash effect
    kprintf("Creating lightning flash effect");
    if (sm->pattern_system.effect_duration % 2 == 0) {
        VDP_setHilightShadow(true);
    } else {
        VDP_setHilightShadow(false);
    }
    SPR_update();
    
    // Check for player counter-spell
    if (player_pattern_effect_in_progress == PTRN_ELECTRIC && player_pattern_effect_reversed == true) {
        // Set the counter-spell success flag
        counter_spell_success = true;
        
        // Stop all visual effects immediately
        VDP_setHilightShadow(false);
        
        // Show success message
        show_or_hide_interface(false);
        show_or_hide_enemy_combat_interface(false);
        talk_dialog(&dialogs[ACT1_DIALOG3][3]); // (ES) "Quizá deba pensar|al revés" - (EN) "I should maybe|think backwards"
        show_or_hide_enemy_combat_interface(true);
        show_or_hide_interface(true);
        
        // Damage the enemy
        hit_enemy(sm->entity_id - ENEMY_ENTITY_ID_BASE);
        
        // Clean up all active notes
        cleanup_enemy_notes();
        
        // Reset enemy state
        u16 enemy_id = sm->entity_id - ENEMY_ENTITY_ID_BASE;
        anim_enemy(enemy_id, ANIM_IDLE);
        enemy_attack_effect_in_progress = false;
        obj_enemy[enemy_id].obj_character.state = STATE_IDLE;
        
        // Set the cooldown to 75% of the recharge time to allow the enemy to attack again after a delay
        u16 current_pattern = enemy_attack_pattern;
        obj_enemy[enemy_id].last_pattern_time[current_pattern] = obj_Pattern_Enemy[current_pattern].recharge_time * 3 / 4;
        
        // Reset attack state
        enemy_attack_pattern = PTRN_EN_NONE;
        
        // Reset player state
        player_pattern_effect_in_progress = PTRN_NONE;
        player_pattern_effect_reversed = false;
        obj_character[active_character].state = STATE_IDLE;
        anim_character(active_character, ANIM_IDLE);
        
        // Hide combat interface
        show_or_hide_enemy_combat_interface(false);
        
        // Update sprites to reflect changes
        SPR_update();
        
        return;
    }
    
    // If player is playing notes, extend the effect time to give them a chance to counter
    if (player_is_playing_notes && sm->pattern_system.effect_duration >= calc_ticks(MAX_EFFECT_TIME_ELECTRIC) - 30) {
        // Keep the effect going a bit longer
        sm->pattern_system.effect_duration = calc_ticks(MAX_EFFECT_TIME_ELECTRIC) - 30;
    }
    
    // Update duration
    sm->pattern_system.effect_duration++;
}

void enemy_electric_pattern_finish(StateMachine* sm) {
    kprintf("enemy_electric_pattern_finish called for enemy %d", sm->entity_id - ENEMY_ENTITY_ID_BASE);
    
    // If counter-spell already succeeded, don't do anything
    if (counter_spell_success) {
        VDP_setHilightShadow(false);
        kprintf("Counter spell succeeded, skipping damage");
        return;
    }
    
    VDP_setHilightShadow(false);
    
    // Check if player is currently playing notes
    bool player_is_playing_notes = (obj_character[active_character].state == STATE_PLAYING_NOTE ||
                                  num_played_notes > 0);
    
    if (player_is_playing_notes) {
        // Player is still trying to counter, give them more time
        kprintf("Player is still trying to counter, extending effect time");
        
        // Extend the effect time to give them a chance to counter
        sm->pattern_system.effect_duration = calc_ticks(MAX_EFFECT_TIME_ELECTRIC) - 30;
        
        // Don't apply damage yet
        return;
    }
    
    // Player failed to counter - apply damage
    kprintf("Player failed to counter, applying damage");
    hit_caracter(active_character);
    show_or_hide_interface(false);
    show_or_hide_enemy_combat_interface(false);
    talk_dialog(&dialogs[ACT1_DIALOG3][2]); // (ES) "Eso ha dolido" - (EN) "That hurts"
    
    // Only show the hint if they haven't successfully countered before
    if (!counter_spell_success) {
        talk_dialog(&dialogs[ACT1_DIALOG3][3]); // (ES) "Quizá deba pensar|al revés" - (EN) "I should maybe|think backwards"
    }
    
    show_or_hide_interface(true);
    show_or_hide_enemy_combat_interface(true);
    
    // Reset enemy state
    u16 enemy_id = sm->entity_id - ENEMY_ENTITY_ID_BASE;
    anim_enemy(enemy_id, ANIM_IDLE);
    
    // Reset all effect flags
    enemy_attack_effect_in_progress = false;
    sm->pattern_system.effect_in_progress = false;
    sm->pattern_system.effect_type = PTRN_NONE;
    sm->pattern_system.effect_duration = 0;
    
    // Reset enemy state
    obj_enemy[enemy_id].obj_character.state = STATE_IDLE;
    sm->current_state = SM_STATE_IDLE;
    
    // Reset attack state
    if (enemy_attacking == enemy_id) {
        kprintf("Resetting enemy_attacking from %d to ENEMY_NONE", enemy_attacking);
        enemy_attacking = 254; // ENEMY_NONE value (254)
    }
}

================
File: old_src/pattern_types/enemy_electric_pattern.h
================
#ifndef ENEMY_ELECTRIC_PATTERN_H
#define ENEMY_ELECTRIC_PATTERN_H

#include "../globals.h"

// Forward declarations
struct StateMachine;

// External variables needed
extern u16 enemy_attacking;
extern bool enemy_attack_effect_in_progress;
extern bool counter_spell_success;
// ENEMY_NONE is a macro defined in enemies.h

// Enemy electric pattern functions
void enemy_electric_pattern_launch(struct StateMachine* sm);
void enemy_electric_pattern_do(struct StateMachine* sm);
void enemy_electric_pattern_finish(struct StateMachine* sm);

#endif // ENEMY_ELECTRIC_PATTERN_H

================
File: old_src/pattern_types/hide_pattern.c
================
#include "hide_pattern.h"
#include "../statemachine.h"
#include "../characters.h"
#include "../interface.h"

// External variables needed
extern u16 player_pattern_effect_in_progress;
extern u16 player_pattern_effect_time;
extern bool player_pattern_effect_reversed;
extern u16 active_character;
extern bool movement_active;

bool hide_pattern_can_use(void) {
    // Currently no restrictions on hide pattern
    return true;
}

void hide_pattern_launch(StateMachine* sm) {
    // Visual and sound effects
    anim_character(sm->entity_id, ANIM_MAGIC);
    show_pattern_icon(PTRN_HIDE, true, true);
    play_pattern_sound(PTRN_HIDE);
    
    // Update state machine
    sm->pattern_system.effect_type = PTRN_HIDE;
    sm->pattern_system.effect_in_progress = true;
    sm->pattern_system.effect_duration = 0;
    
    // Allow movement while hidden
    movement_active = true;
    
    // For compatibility with existing code
    player_pattern_effect_in_progress = PTRN_HIDE;
    player_pattern_effect_time = 1;
    player_pattern_effect_reversed = sm->is_reversed;
}

void hide_pattern_do(StateMachine* sm) {
    u16 max_effect_time = 400;
    
    // Create flickering effect
    if (sm->pattern_system.effect_duration % 2 == 0) {
        show_character(sm->entity_id, true);
    } else {
        show_character(sm->entity_id, false);
    }
    
    // Update duration
    sm->pattern_system.effect_duration++;
    
    // For compatibility with existing code
    player_pattern_effect_time++;
    
    // Check if effect is complete
    if (sm->pattern_system.effect_duration >= max_effect_time) {
        // Ensure character is visible
        show_character(sm->entity_id, true);
        show_pattern_icon(PTRN_HIDE, false, false);
        sm->current_state = SM_STATE_PATTERN_EFFECT_FINISH;
    }
}

void hide_pattern_finish(StateMachine* sm) {
    // Ensure character is visible
    show_character(sm->entity_id, true);
    show_pattern_icon(PTRN_HIDE, false, false);
    
    // Reset state
    sm->pattern_system.effect_type = PTRN_NONE;
    sm->pattern_system.effect_in_progress = false;
    sm->pattern_system.effect_duration = 0;
    
    // For compatibility with existing code
    player_pattern_effect_in_progress = PTRN_NONE;
    player_pattern_effect_time = 0;
    player_pattern_effect_reversed = false;
    
    // Disable movement
    movement_active = false;
    
    // Update character animation
    obj_character[active_character].state = STATE_IDLE;
    anim_character(active_character, ANIM_IDLE);
}

================
File: old_src/pattern_types/hide_pattern.h
================
#ifndef HIDE_PATTERN_H
#define HIDE_PATTERN_H

#include "../globals.h"

// Forward declarations
struct StateMachine;

// Hide pattern functions
bool hide_pattern_can_use(void);
void hide_pattern_launch(struct StateMachine* sm);
void hide_pattern_do(struct StateMachine* sm);
void hide_pattern_finish(struct StateMachine* sm);

#endif // HIDE_PATTERN_H

================
File: old_src/pattern_types/open_pattern.c
================
#include "open_pattern.h"
#include "../statemachine.h"
#include "../characters.h"
#include "../enemies.h"
#include "../interface.h"

// External variables needed
extern bool is_combat_active;
extern u16 player_pattern_effect_in_progress;
extern u16 player_pattern_effect_time;
extern bool player_pattern_effect_reversed;
extern u16 active_character;

bool open_pattern_can_use(void) {
    // Currently not usable - this is a placeholder for future implementation
    return false;
}

void open_pattern_launch(StateMachine* sm) {
    // Visual and sound effects
    anim_character(sm->entity_id, ANIM_MAGIC);
    show_pattern_icon(PTRN_OPEN, true, true);
    play_pattern_sound(PTRN_OPEN);
    
    // Update state machine
    sm->pattern_system.effect_type = PTRN_OPEN;
    sm->pattern_system.effect_in_progress = true;
    sm->pattern_system.effect_duration = 0;
    
    // For compatibility with existing code
    player_pattern_effect_in_progress = PTRN_OPEN;
    player_pattern_effect_time = 1;
    player_pattern_effect_reversed = sm->is_reversed;
}

void open_pattern_do(StateMachine* sm) {
    // Do nothing by now, just wait for the effect to finish

    // Update duration
    sm->pattern_system.effect_duration++;
    
    // For compatibility with existing code
    player_pattern_effect_time++;
    
    // Brief visual effect
    if (sm->pattern_system.effect_duration >= 30) {
        show_pattern_icon(PTRN_OPEN, false, false);
        sm->current_state = SM_STATE_PATTERN_EFFECT_FINISH;
    }
}

void open_pattern_finish(StateMachine* sm) {
    // Clean up visual effects
    show_pattern_icon(PTRN_OPEN, false, false);
    
    // Reset state
    sm->pattern_system.effect_type = PTRN_NONE;
    sm->pattern_system.effect_in_progress = false;
    sm->pattern_system.effect_duration = 0;
    
    // For compatibility with existing code
    player_pattern_effect_in_progress = PTRN_NONE;
    player_pattern_effect_time = 0;
    player_pattern_effect_reversed = false;
    
    // Update character animation
    obj_character[active_character].state = STATE_IDLE;
    anim_character(active_character, ANIM_IDLE);
}

================
File: old_src/pattern_types/open_pattern.h
================
#ifndef OPEN_PATTERN_H
#define OPEN_PATTERN_H

#include "../globals.h"

// Forward declarations
struct StateMachine;

// Open pattern functions
bool open_pattern_can_use(void);
void open_pattern_launch(struct StateMachine* sm);
void open_pattern_do(struct StateMachine* sm);
void open_pattern_finish(struct StateMachine* sm);

#endif // OPEN_PATTERN_H

================
File: old_src/pattern_types/sleep_pattern.c
================
#include "sleep_pattern.h"
#include "../statemachine.h"
#include "../characters.h"
#include "../enemies.h"
#include "../interface.h"

// External variables needed
extern bool is_combat_active;
extern u16 player_pattern_effect_in_progress;
extern u16 player_pattern_effect_time;
extern bool player_pattern_effect_reversed;
extern u16 active_character;

bool sleep_pattern_can_use(void) {
    // Currently not usable - this is a placeholder for future implementation
    return false;
}

void sleep_pattern_launch(StateMachine* sm) {
    // Visual and sound effects
    anim_character(sm->entity_id, ANIM_MAGIC);
    show_pattern_icon(PTRN_SLEEP, true, true);
    play_pattern_sound(PTRN_SLEEP);
    
    // Update state machine
    sm->pattern_system.effect_type = PTRN_SLEEP;
    sm->pattern_system.effect_in_progress = true;
    sm->pattern_system.effect_duration = 0;
    
    // For compatibility with existing code
    player_pattern_effect_in_progress = PTRN_SLEEP;
    player_pattern_effect_time = 1;
    player_pattern_effect_reversed = sm->is_reversed;
}

void sleep_pattern_do(StateMachine* sm) {
    // Do nothing by now, just wait for the effect to finish
    
    // Update duration
    sm->pattern_system.effect_duration++;
    
    // For compatibility with existing code
    player_pattern_effect_time++;
    
    // Brief visual effect
    if (sm->pattern_system.effect_duration >= 30) {
        show_pattern_icon(PTRN_SLEEP, false, false);
        sm->current_state = SM_STATE_PATTERN_EFFECT_FINISH;
    }
}

void sleep_pattern_finish(StateMachine* sm) {
    // Clean up visual effects
    show_pattern_icon(PTRN_SLEEP, false, false);
    
    // Reset state
    sm->pattern_system.effect_type = PTRN_NONE;
    sm->pattern_system.effect_in_progress = false;
    sm->pattern_system.effect_duration = 0;
    
    // For compatibility with existing code
    player_pattern_effect_in_progress = PTRN_NONE;
    player_pattern_effect_time = 0;
    player_pattern_effect_reversed = false;
    
    // Update character animation
    obj_character[active_character].state = STATE_IDLE;
    anim_character(active_character, ANIM_IDLE);
}

================
File: old_src/pattern_types/sleep_pattern.h
================
#ifndef SLEEP_PATTERN_H
#define SLEEP_PATTERN_H

#include "../globals.h"

// Forward declarations
struct StateMachine;

// Sleep pattern functions
bool sleep_pattern_can_use(void);
void sleep_pattern_launch(struct StateMachine* sm);
void sleep_pattern_do(struct StateMachine* sm);
void sleep_pattern_finish(struct StateMachine* sm);

#endif // SLEEP_PATTERN_H

================
File: old_src/patterns_registry.c
================
#include "patterns_registry.h"

// Registry storage
static Pattern registered_patterns[MAX_REGISTERED_PATTERNS];
static u16 pattern_count = 0;

void pattern_registry_init(void) {
    pattern_count = 0;
    // Initialize with empty patterns
    for (u16 i = 0; i < MAX_REGISTERED_PATTERNS; i++) {
        registered_patterns[i].id = PTRN_NONE;
        registered_patterns[i].active = false;
    }
}

void register_pattern(Pattern* pattern) {
    if (pattern_count < MAX_REGISTERED_PATTERNS) {
        registered_patterns[pattern_count] = *pattern;
        pattern_count++;
    }
}

Pattern* get_pattern(u16 pattern_id, u16 owner_type) {
    for (u16 i = 0; i < pattern_count; i++) {
        if (registered_patterns[i].id == pattern_id && 
            registered_patterns[i].owner_type == owner_type) {
            return &registered_patterns[i];
        }
    }
    return NULL;
}

u8 validate_pattern_sequence(u8* notes, bool* is_reverse, u16 owner_type) {
    u8 matches, reverse_matches;
    
    for (u16 i = 0; i < pattern_count; i++) {
        if (registered_patterns[i].owner_type != owner_type) {
            continue;
        }
        
        matches = 0;
        reverse_matches = 0;
        
        // Check forward match
        for (u8 j = 0; j < 4; j++) {
            if (notes[j] == registered_patterns[i].notes[j]) {
                matches++;
            }
            if (notes[j] == registered_patterns[i].notes[3-j]) {
                reverse_matches++;
            }
        }
        
        // Pattern found if all notes match and pattern is active
        if (matches == 4 && registered_patterns[i].active) {
            *is_reverse = false;
            return registered_patterns[i].id;
        }
        else if (reverse_matches == 4 && registered_patterns[i].active) {
            *is_reverse = true;
            return registered_patterns[i].id;
        }
    }
    
    return PTRN_NONE;
}

================
File: old_src/patterns_registry.h
================
#ifndef PATTERNS_REGISTRY_H
#define PATTERNS_REGISTRY_H

#include "globals.h"

#define MAX_REGISTERED_PATTERNS 10
#define OWNER_PLAYER 0
#define OWNER_ENEMY 1

// Forward declarations
struct StateMachine;

// Pattern registry functions
void pattern_registry_init(void);
void register_pattern(Pattern* pattern);
Pattern* get_pattern(u16 pattern_id, u16 owner_type);
u8 validate_pattern_sequence(u8* notes, bool* is_reverse, u16 owner_type);

#endif // PATTERNS_REGISTRY_H

================
File: old_src/patterns.h
================
#ifndef PATTERNS_H
#define PATTERNS_H

// Forward declarations
struct StateMachine;

// Pattern structure for spell patterns
typedef struct Pattern {
    u16 id;                     // Pattern identifier
    bool active;                // Whether pattern is available
    u8 notes[4];                // Sequence of notes for this pattern
    u16 owner_type;             // OWNER_PLAYER or OWNER_ENEMY
    u16 recharge_time;          // Time before pattern can be used again (for enemies)
    bool (*can_use)(void);      // Function to check if pattern can be used
    void (*launch)(struct StateMachine*);    // Function to launch pattern effect
    void (*do_effect)(struct StateMachine*); // Function to process ongoing effect
    void (*finish)(struct StateMachine*);    // Function to finish effect
    Sprite *sd;                 // Sprite data for pattern visualization
} Pattern;

#endif // PATTERNS_H

================
File: old_src/statemachine.c
================
#include "globals.h"
#include "patterns_registry.h"
#include "counter_spell.h"

// Mapeo entre estados del personaje y estados de la máquina
SM_State convert_to_sm_state(u16 current_state) {
    switch(current_state) {
        case STATE_IDLE:
            return SM_STATE_IDLE;
        case STATE_PLAYING_NOTE:
            return SM_STATE_PLAYING_NOTE;
        case STATE_PATTERN_CHECK:
            return SM_STATE_PATTERN_CHECK;
        case STATE_PATTERN_EFFECT:
            return SM_STATE_PATTERN_EFFECT;
        case STATE_PATTERN_EFFECT_FINISH:
            return SM_STATE_PATTERN_EFFECT_FINISH;
        default:
            return SM_STATE_IDLE;
    }
}

void update_character_from_sm_state(Entity* entity, SM_State state) {
    // Debug log for enemy entities
    bool is_enemy = false;
    u16 entity_id = 0;
    
    // Check if this is an enemy entity
    for (u16 i = 0; i < MAX_ENEMIES; i++) {
        if (entity == &obj_enemy[i].obj_character) {
            is_enemy = true;
            entity_id = i;
            break;
        }
    }
    
    if (is_enemy && entity_id == enemy_attacking) {
        kprintf("update_character_from_sm_state: enemy=%d, current_state=%d, new_state=%d, walking=%d",
                entity_id, entity->state, state, (entity->state == STATE_WALKING));
    }
    
    // Solo actualizar si no estamos en movimiento o si es un estado de efecto
    // Also skip updating if the entity is an enemy that's currently attacking and in a special state
    bool skip_update = false;
    
    // Only skip if the entity state and state machine state are different
    if (is_enemy && entity_id == enemy_attacking &&
        (entity->state == STATE_PLAYING_NOTE || entity->state == STATE_PATTERN_EFFECT) &&
        ((entity->state == STATE_PLAYING_NOTE && state != SM_STATE_PLAYING_NOTE) ||
         (entity->state == STATE_PATTERN_EFFECT && state != SM_STATE_PATTERN_EFFECT))) {
        kprintf("  SKIPPING state update for attacking enemy in state %d (sm_state: %d)", entity->state, state);
        skip_update = true;
    }
    
    if (!skip_update && (entity->state != STATE_WALKING ||
        state == SM_STATE_PATTERN_EFFECT ||
        state == SM_STATE_PATTERN_EFFECT_FINISH)) {
        
        // Actualizar el estado de la entidad
        switch(state) {
            case SM_STATE_IDLE:
                if (entity->state != STATE_WALKING) {
                    entity->state = STATE_IDLE;
                    if (is_enemy && entity_id == enemy_attacking) {
                        kprintf("  Setting enemy state to IDLE");
                    }
                }
                break;
            case SM_STATE_PLAYING_NOTE:
                entity->state = STATE_PLAYING_NOTE;
                if (is_enemy && entity_id == enemy_attacking) {
                    kprintf("  Setting enemy state to PLAYING_NOTE");
                }
                break;
            case SM_STATE_PATTERN_CHECK:
                entity->state = STATE_PATTERN_CHECK;
                if (is_enemy && entity_id == enemy_attacking) {
                    kprintf("  Setting enemy state to PATTERN_CHECK");
                }
                break;
            case SM_STATE_PATTERN_EFFECT:
                entity->state = STATE_PATTERN_EFFECT;
                if (is_enemy && entity_id == enemy_attacking) {
                    kprintf("  Setting enemy state to PATTERN_EFFECT");
                }
                break;
            case SM_STATE_PATTERN_EFFECT_FINISH:
                entity->state = STATE_PATTERN_EFFECT_FINISH;
                if (is_enemy && entity_id == enemy_attacking) {
                    kprintf("  Setting enemy state to PATTERN_EFFECT_FINISH");
                }
                break;
            default:
                if (is_enemy && entity_id == enemy_attacking) {
                    kprintf("  Unknown state: %d", state);
                }
                break;
        }
        
        // Actualizar la animación si es un personaje
        if (entity == &obj_character[active_character]) {
            update_character_animation();
        }
    }
}

/**
 * Inicializa una máquina de estados.
 * 
 * @param sm Puntero a la estructura StateMachine a inicializar
 * @param entity_id ID de la entidad asociada a esta máquina de estados
 */
void StateMachine_Init(StateMachine *sm, u16 entity_id) {
    kprintf("Initializing state machine - MAX_NOTE_PLAYING_TIME ticks: %d", calc_ticks(MAX_NOTE_PLAYING_TIME));
    // Inicializar campos base
    sm->current_state = SM_STATE_IDLE;
    sm->timer = 0;
    sm->note_count = 0;
    sm->current_note = 0;
    sm->note_time = 0;
    sm->pattern_time = 0;
    sm->active_pattern = 0;
    sm->is_reversed = false;
    sm->is_counter_spell = false;
    sm->effect_time = 0;
    sm->entity_id = entity_id;
    sm->owner_type = OWNER_PLAYER; // Default to player
    
    // Inicializar array de notas
    for (u8 i = 0; i < 4; i++) {
        sm->notes[i] = 0;
    }
    
    // Inicializar sistema de patrones
    sm->pattern_system.enabled = true;
    sm->pattern_system.is_note_playing = false;
    sm->pattern_system.time_since_last_note = 0;
    sm->pattern_system.effect_in_progress = false;
    sm->pattern_system.effect_type = PTRN_NONE;
    sm->pattern_system.effect_reversed = false;
    sm->pattern_system.effect_duration = 0;
    sm->pattern_system.available_patterns = NULL;
    sm->pattern_system.pattern_count = 0;
    
    // Inicializar callbacks
    sm->launch_effect = NULL;
    sm->do_effect = NULL;
    sm->finish_effect = NULL;
    sm->validate_pattern = NULL;
    sm->pattern_complete = NULL;
}

/**
 * Actualiza el estado de una máquina de estados basado en un mensaje.
 * 
 * @param sm Puntero a la estructura StateMachine a actualizar
 * @param msg Puntero al mensaje que se procesará (puede ser NULL)
 */
void StateMachine_Update(StateMachine *sm, Message *msg) {
    // Lógica de actualización para cada estado
    switch (sm->current_state) {
        case SM_STATE_IDLE:
            // Manejar mensajes en estado IDLE
            if (msg != NULL) {
                switch (msg->type) {
                    case MSG_COMBAT_START:
                        sm->current_state = SM_STATE_PLAYING_NOTE;
                        sm->timer = 0;
                        break;
                    case MSG_NOTE_PLAYED:
                        if (msg->param > 0) {
                            kprintf("Note played: %d", msg->param);
                        }
                        sm->current_state = SM_STATE_PLAYING_NOTE;
                        sm->current_note = msg->param;
                        sm->note_time = 0;
                        // Asegurarse de que el sistema de patrones sepa que estamos reproduciendo una nota
                        sm->pattern_system.is_note_playing = true;
                        break;
                    default:
                        break;
                }
            }
            break;
            
        case SM_STATE_PLAYING_NOTE:
            // Lógica para reproducir notas
            sm->note_time++;
            if (sm->note_time == calc_ticks(MAX_NOTE_PLAYING_TIME)) {
                sm->current_state = SM_STATE_PATTERN_CHECK;
                sm->note_time = 0;
                // Marcar que ya no estamos reproduciendo una nota
                sm->pattern_system.is_note_playing = false;
            }
            break;
            
        case SM_STATE_PATTERN_CHECK:
            // Verificar patrones y configurar callbacks según el tipo
            if (msg != NULL && msg->type == MSG_PATTERN_COMPLETE) {
                kprintf("Pattern complete: %d", msg->param);
                sm->current_state = SM_STATE_PATTERN_EFFECT;
                sm->active_pattern = msg->param;
                sm->effect_time = 0;
                
                // Obtener el patrón del registro
                Pattern* pattern = get_pattern(msg->param, sm->owner_type);
                if (pattern) {
                    // Configurar callbacks desde el patrón
                    sm->launch_effect = pattern->launch;
                    sm->do_effect = pattern->do_effect;
                    sm->finish_effect = pattern->finish;
                    
                    // Iniciar el efecto si hay un callback registrado
                    if (sm->launch_effect != NULL) {
                        sm->launch_effect(sm);
                    }
                } else {
                    // Configurar callbacks según el tipo de patrón (para compatibilidad)
                    switch (msg->param) {
                        case PTRN_ELECTRIC:
                            sm->launch_effect = electric_pattern_launch;
                            sm->do_effect = electric_pattern_do;
                            sm->finish_effect = electric_pattern_finish;
                            break;
                        case PTRN_HIDE:
                            // Asignar callbacks para el patrón de esconderse
                            sm->launch_effect = hide_pattern_launch;
                            sm->do_effect = hide_pattern_do;
                            sm->finish_effect = hide_pattern_finish;
                            break;
                        case PTRN_OPEN:
                            // Asignar callbacks para el patrón de abrir
                            sm->launch_effect = open_pattern_launch;
                            sm->do_effect = open_pattern_do;
                            sm->finish_effect = open_pattern_finish;
                            break;
                        case PTRN_SLEEP:
                            // Asignar callbacks para el patrón de dormir
                            sm->launch_effect = sleep_pattern_launch;
                            sm->do_effect = sleep_pattern_do;
                            sm->finish_effect = sleep_pattern_finish;
                            break;
                        default:
                            sm->launch_effect = NULL;
                            sm->do_effect = NULL;
                            sm->finish_effect = NULL;
                            break;
                    }
                    
                    // Iniciar el efecto si hay un callback registrado
                    if (sm->launch_effect != NULL) {
                        sm->launch_effect(sm);
                    }
                }
            } else {
                // Solo volver a IDLE si no hay patrón completo
                sm->current_state = SM_STATE_IDLE;
            }
            break;
            
        case SM_STATE_PATTERN_EFFECT:
            // Ejecutar efecto si hay un callback registrado
            if (sm->do_effect != NULL && sm->pattern_system.effect_in_progress) {
                sm->do_effect(sm);
            }
            
            // Incrementar el tiempo de efecto
            sm->effect_time++;
            
            // Forzar la transición después de un tiempo
            if (sm->pattern_system.effect_duration > 100 || sm->effect_time > calc_ticks(MAX_EFFECT_TIME)) {
                sm->current_state = SM_STATE_PATTERN_EFFECT_FINISH;
                sm->effect_time = 0;
                
                // Llamar al callback de finalización si existe
                if (sm->finish_effect != NULL) {
                    sm->finish_effect(sm);
                }
            }
            break;
            
        case SM_STATE_PATTERN_EFFECT_FINISH:
            // Lógica para finalizar efectos
            sm->timer++;
            if (sm->timer > 20) {
                sm->current_state = SM_STATE_IDLE;
                sm->timer = 0;
                sm->active_pattern = 0;
                sm->is_counter_spell = false;
                
                // Limpiar callbacks y estado del sistema de patrones
                sm->launch_effect = NULL;
                sm->do_effect = NULL;
                sm->finish_effect = NULL;
                sm->pattern_system.effect_in_progress = false;
                sm->pattern_system.effect_type = PTRN_NONE;
            }
            break;
            
        case SM_STATE_ATTACK_FINISHED:
            // Lógica para el estado post-ataque
            sm->timer++;
            if (sm->timer > MAX_TIME_AFTER_ATTACK) {
                sm->current_state = SM_STATE_IDLE;
                sm->timer = 0;
            }
            break;
            
        default:
            // Manejar estado desconocido
            sm->current_state = SM_STATE_IDLE;
            sm->timer = 0;
            break;
    }
}

/**
 * Envía un mensaje a una máquina de estados para su procesamiento.
 * 
 * @param sm Puntero a la estructura StateMachine que recibirá el mensaje
 * @param type Tipo de mensaje a enviar
 * @param param Parámetro adicional del mensaje
 */
void StateMachine_SendMessage(StateMachine *sm, MessageType type, u16 param) {
    // Debug log for enemy state machines
    bool is_enemy = false;
    u16 entity_id = 0;
    
    // Check if this is an enemy state machine
    for (u16 i = 0; i < MAX_ENEMIES; i++) {
        if (sm->entity_id == ENEMY_ENTITY_ID_BASE + i) {
            is_enemy = true;
            entity_id = i;
            break;
        }
    }
    
    if (is_enemy && entity_id == enemy_attacking) {
        kprintf("StateMachine_SendMessage: enemy=%d, type=%d, param=%d, current_state=%d",
                entity_id, type, param, sm->current_state);
    }
    
    Message msg;
    msg.type = type;
    msg.param = param;
    StateMachine_Update(sm, &msg);
    
    if (is_enemy && entity_id == enemy_attacking) {
        kprintf("StateMachine_SendMessage: enemy=%d, new_state=%d after message",
                entity_id, sm->current_state);
    }
}

/**
 * Maneja la finalización de un patrón y la transición al estado de efecto.
 * 
 * @param sm Puntero a la estructura StateMachine
 * @param pattern_id ID del patrón completado
 * @param is_reverse Si el patrón se ejecutó en reversa
 */
void StateMachine_HandlePatternComplete(StateMachine* sm, u16 pattern_id, bool is_reverse) {
    // Debug log for enemy state machines
    bool is_enemy = false;
    u16 entity_id = 0;
    
    // Check if this is an enemy state machine
    for (u16 i = 0; i < MAX_ENEMIES; i++) {
        if (sm->entity_id == ENEMY_ENTITY_ID_BASE + i) {
            is_enemy = true;
            entity_id = i;
            break;
        }
    }
    
    if (is_enemy && entity_id == enemy_attacking) {
        kprintf("StateMachine_HandlePatternComplete: enemy=%d, pattern=%d, is_reverse=%d, current_state=%d",
                entity_id, pattern_id, is_reverse, sm->current_state);
    }
    
    // Actualizar estado
    sm->current_state = SM_STATE_PATTERN_EFFECT;
    sm->active_pattern = pattern_id;
    sm->is_reversed = is_reverse;
    sm->effect_time = 0;
    
    if (is_enemy && entity_id == enemy_attacking) {
        kprintf("  State updated: current_state=%d, active_pattern=%d, is_reversed=%d",
                sm->current_state, sm->active_pattern, sm->is_reversed);
    }
    
    // Obtener el patrón del registro
    Pattern* pattern = get_pattern(pattern_id, sm->owner_type);
    
    if (is_enemy && entity_id == enemy_attacking) {
        kprintf("  Got pattern from registry: %s", pattern ? "SUCCESS" : "FAILED");
    }
    
    if (pattern) {
        // Configurar callbacks desde el patrón
        sm->launch_effect = pattern->launch;
        sm->do_effect = pattern->do_effect;
        sm->finish_effect = pattern->finish;
        
        if (is_enemy && entity_id == enemy_attacking) {
            kprintf("  Callbacks configured: launch=%s, do_effect=%s, finish=%s",
                    sm->launch_effect ? "YES" : "NO",
                    sm->do_effect ? "YES" : "NO",
                    sm->finish_effect ? "YES" : "NO");
        }
        
        // Iniciar el efecto
        if (sm->launch_effect) {
            if (is_enemy && entity_id == enemy_attacking) {
                kprintf("  Launching effect");
            }
            sm->launch_effect(sm);
        }
    }
}

/**
 * Maneja la entrada de una nueva nota en el patrón.
 * 
 * @param sm Puntero a la estructura StateMachine
 * @param note Nota reproducida (1-6)
 */
void StateMachine_HandleNoteInput(StateMachine* sm, u8 note) {
    // Verificar si la nota es válida
    if (note < 1 || note > 6) {
        return;
    }
    
    // Actualizar estado
    sm->current_state = SM_STATE_PLAYING_NOTE;
    sm->current_note = note;
    sm->note_time = 0;
    sm->pattern_system.is_note_playing = true;
    
    // Añadir la nota al patrón actual
    if (sm->note_count < 4) {
        sm->notes[sm->note_count] = note;
        sm->note_count++;
    }
}

/**
 * Maneja el timeout de un patrón en progreso.
 * 
 * @param sm Puntero a la estructura StateMachine
 */
void StateMachine_HandlePatternTimeout(StateMachine* sm) {
    // Resetear el estado del patrón
    sm->note_count = 0;
    sm->pattern_time = 0;
    sm->current_state = SM_STATE_IDLE;
    
    // Limpiar notas
    for (u8 i = 0; i < 4; i++) {
        sm->notes[i] = 0;
    }
}

================
File: old_src/statemachine.h
================
#ifndef STATEMACHINE_H
#define STATEMACHINE_H

#include "globals.h"
#include "patterns.h"

// Forward declarations
struct StateMachine;

// Definición de constantes para tiempos máximos
#define MAX_NOTE_PLAYING_TIME  500  // Tiempo máximo de reproducción de nota en milisegundos
#define MAX_PATTERN_WAIT_TIME 2000  // Tiempo máximo de espera para la siguiente nota en milisegundos
#define MAX_EFFECT_TIME       1600  // Tiempo máximo para efectos de patrón en milisegundos
#define MAX_TIME_AFTER_ATTACK 1000  // Tiempo máximo después de un ataque en milisegundos

// Owner types for patterns
#define OWNER_PLAYER 0
#define OWNER_ENEMY 1

// Estados de la máquina de estados
typedef enum {
    SM_STATE_IDLE,               // Sistema inactivo
    SM_STATE_PLAYING_NOTE,       // Reproduciendo una nota
    SM_STATE_PATTERN_CHECK,      // Verificando si el patrón es válido
    SM_STATE_PATTERN_EFFECT,     // Ejecutando el efecto del patrón
    SM_STATE_PATTERN_EFFECT_FINISH, // Finalizando el efecto del patrón
    SM_STATE_ATTACK_FINISHED     // Ataque finalizado, en enfriamiento
} SM_State;

// Tipos de mensajes para comunicación entre componentes
typedef enum {
    MSG_PATTERN_COMPLETE,        // Patrón completado
    MSG_COMBAT_START,            // Inicio de combate
    MSG_COMBAT_END,              // Fin de combate
    MSG_ENEMY_DEFEATED,          // Enemigo derrotado
    MSG_PLAYER_HIT,              // Jugador golpeado
    MSG_ENEMY_HIT,               // Enemigo golpeado
    MSG_NOTE_PLAYED,             // Nota reproducida
    MSG_PATTERN_TIMEOUT          // Tiempo de espera del patrón agotado
} MessageType;

// Estructura de mensaje para comunicación
typedef struct {
    MessageType type;            // Tipo de mensaje
    u16 param;                   // Parámetro adicional (depende del tipo de mensaje)
} Message;

// Tipos de callbacks para efectos de patrones
typedef void (*EffectCallback)(struct StateMachine*);

// Sistema de patrones
typedef struct {
    bool enabled;               // Si el sistema de patrones está activo
    bool is_note_playing;       // Si hay una nota reproduciéndose
    u16 time_since_last_note;   // Tiempo desde la última nota
    bool effect_in_progress;    // Si hay un efecto en progreso
    u16 effect_type;           // Tipo de efecto activo (PTRN_NONE, PTRN_ELECTRIC, etc.)
    bool effect_reversed;       // Si el efecto está invertido
    u16 effect_duration;        // Duración del efecto actual
    Pattern* available_patterns;  // Array de patrones disponibles
    u8 pattern_count;          // Número de patrones disponibles
} PatternSystem;

// Estructura principal de la máquina de estados
typedef struct StateMachine {
    // Estados y temporizadores base
    SM_State current_state;      // Estado actual
    u16 timer;                   // Temporizador general
    
    // Sistema de notas
    u8 notes[4];                 // Notas del patrón actual
    u8 note_count;               // Número de notas reproducidas
    u8 current_note;             // Nota actual que se está reproduciendo
    u16 note_time;               // Tiempo que lleva reproduciendo la nota
    u16 pattern_time;            // Tiempo desde la última nota
    
    // Sistema de patrones base
    u16 active_pattern;          // Patrón activo (si hay alguno)
    bool is_reversed;            // Si el patrón es invertido
    bool is_counter_spell;       // Si el patrón es un contraataque
    u16 effect_time;             // Tiempo que lleva el efecto activo
    u16 entity_id;               // ID de la entidad (jugador o enemigo)
    u16 owner_type;              // Tipo de propietario (OWNER_PLAYER o OWNER_ENEMY)
    
    // Sistema de patrones expandido
    PatternSystem pattern_system;
    
    // Callbacks para efectos específicos
    EffectCallback launch_effect;  // Función para iniciar un efecto
    EffectCallback do_effect;      // Función para procesar un efecto
    EffectCallback finish_effect;  // Función para finalizar un efecto
    
    // Funciones de validación de patrones
    bool (*validate_pattern)(u8* notes, bool* is_reverse);
    void (*pattern_complete)(struct StateMachine* sm, u16 pattern_id, bool is_reverse);
} StateMachine;

// Funciones de conversión de estados
SM_State convert_to_sm_state(u16 current_state);
void update_character_from_sm_state(Entity* entity, SM_State state);

// Funciones de la máquina de estados
void StateMachine_Init(StateMachine *sm, u16 entity_id);
void StateMachine_Update(StateMachine *sm, Message *msg);
void StateMachine_SendMessage(StateMachine *sm, MessageType type, u16 param);

// Nuevas funciones para manejo de patrones
void StateMachine_HandlePatternComplete(StateMachine* sm, u16 pattern_id, bool is_reverse);
void StateMachine_HandleNoteInput(StateMachine* sm, u8 note);
void StateMachine_HandlePatternTimeout(StateMachine* sm);

// Funciones de efectos para el patrón eléctrico
void electric_pattern_launch(StateMachine* sm);
void electric_pattern_do(StateMachine* sm);
void electric_pattern_finish(StateMachine* sm);

// Funciones de efectos para el patrón de esconderse (HIDE)
void hide_pattern_launch(StateMachine* sm);
void hide_pattern_do(StateMachine* sm);
void hide_pattern_finish(StateMachine* sm);

// Funciones de efectos para el patrón de dormir (SLEEP)
void sleep_pattern_launch(StateMachine* sm);
void sleep_pattern_do(StateMachine* sm);
void sleep_pattern_finish(StateMachine* sm);

// Funciones de efectos para el patrón de abrir (OPEN)
void open_pattern_launch(StateMachine* sm);
void open_pattern_do(StateMachine* sm);
void open_pattern_finish(StateMachine* sm);

#endif // STATEMACHINE_H

================
File: old_src/test.h
================
#ifndef _TEST_H_
#define _TEST_H_

/**
 * Test Framework for The Weave
 *
 * This header unifies all test-related includes and provides
 * common test functionality. All test files should include
 * this header instead of individual test headers.
 */

// Include globals.h which already has all necessary includes
#include "globals.h"

// Forward declarations
struct _test_result;

// Test result structure
typedef struct _test_result {
    const char* test_name;    // Name of the test
    bool passed;              // Test result
    const char* message;      // Error message if failed
    u16 line_number;         // Line where test failed
    const char* file_name;   // File where test failed
} TestResult;

// Test assertion macros
#define TEST_ASSERT(condition) \
    if (!(condition)) { \
        result.passed = FALSE; \
        result.message = #condition; \
        result.line_number = __LINE__; \
        result.file_name = __FILE__; \
        return result; \
    }

#define TEST_ASSERT_MESSAGE(condition, msg) \
    if (!(condition)) { \
        result.passed = FALSE; \
        result.message = (msg); \
        result.line_number = __LINE__; \
        result.file_name = __FILE__; \
        return result; \
    }

// Test utilities
void setup_test_environment();
void cleanup_test_environment();
void print_test_result(TestResult result);

// Main test runners
void run_state_machine_tests();
void run_basic_state_machine_tests();

#endif // _TEST_H_

================
File: README.md
================
The Weave is a fangame of LucasArts' Loom, that I'm developing for Sega Genesis/Megadrive

It's still in early stages of development, but you can follow the game development in Geesebumps Studio social network accounts:
https://x.com/GeeseBumpsGames
https://bsky.app/profile/geesebumpsgames.bsky.social

More info: http://www.geesebumps.com

================
File: res/Backgrounds/Act1/bedroom_daylight.pal
================
JASC-PAL
0100
16
0 0 0
230 49 0
117 29 17
68 38 23
122 77 46
158 110 70
176 127 67
255 255 255
162 162 162
77 80 78
48 49 46
0 0 0
75 108 47
0 72 12
56 103 119
23 48 158

================
File: res/Backgrounds/Act1/bedroom_midnight.pal
================
JASC-PAL
0100
16
0 0 0
34 40 66
32 12 64
29 23 28
37 27 101
65 57 109
81 73 140
112 112 112
65 65 65
31 32 45
21 21 20
0 0 0
22 23 53
16 23 40
42 35 81
27 34 64

================
File: res/Backgrounds/Act1/forest_dark.pal
================
JASC-PAL
0100
16
0 0 0 0
0 0 0 255
80 80 80 255
78 39 0 255
7 35 49 255
111 111 111 255
121 13 121 255
0 86 0 255
49 30 10 255
255 0 242 255
2 45 12 255
64 37 7 255
36 36 36 255
47 95 47 255
29 15 5 255
49 49 49 255

================
File: res/Backgrounds/Act1/hall.pal
================
JASC-PAL
0100
16
0 0 0 0
0 0 0 255
75 23 13 255
152 74 36 255
152 112 10 255
181 107 61 255
234 221 60 255
230 198 141 255
43 178 92 255
230 0 0 255
152 49 10 255
255 0 248 255
238 0 255 255
255 0 242 255
255 0 242 255
56 67 98 255

================
File: res/Backgrounds/Act1/OLD_bedroom_night.pal
================
JASC-PAL
0100
16
0 0 0
13 16 38
8 15 51
8 7 13
16 18 26
12 30 76
23 21 36
28 34 74
21 21 48
27 22 74
15 20 54
22 39 102
39 44 95
19 20 31
40 46 84
58 67 107

================
File: res/resources.res
================
#Font
IMAGE font "font.png" BEST none

================
File: res/Sound/Effects/source.txt
================
https://freesound.org/people/hjohnl/sounds/61521/

================
File: src/boot/rom_head.c
================
#include "genesis.h"

__attribute__((externally_visible))
const ROMHeader rom_header = {
#if (ENABLE_BANK_SWITCH != 0)
    "SEGA SSF        ",
#elif (MODULE_MEGAWIFI != 0)
    "SEGA MEGAWIFI   ",
#else
    "SEGA MEGA DRIVE ",
#endif
    "Geesebumps 2024 ",
    "The Weave                                       ",
    "The Weave                                       ",
    "GM 00000000-00",
    0x000,
    "JD              ",
    0x00000000,
#if (ENABLE_BANK_SWITCH != 0)
    0x003FFFFF,
#else
    0x000FFFFF,
#endif
    0xE0FF0000,
    0xE0FFFFFF,
    "RA",
    0xF820,
    0x00200000,
    0x0020FFFF,
    "            ",
    "The Weave                               ",
    "JUE             "
};

================
File: src/boot/sega.s
================
#include "task_cst.h"

.section .text.keepboot

*-------------------------------------------------------
*
*       Sega startup code for the GNU Assembler
*       Translated from:
*       Sega startup code for the Sozobon C compiler
*       Written by Paul W. Lee
*       Modified by Charles Coty
*       Modified by Stephane Dallongeville
*
*-------------------------------------------------------

    .globl  rom_header

    .org    0x00000000

_Start_Of_Rom:
_Vecteurs_68K:
        dc.l    __stack                 /* Stack address */
        dc.l    _Entry_Point            /* Program start address */
        dc.l    _Bus_Error
        dc.l    _Address_Error
        dc.l    _Illegal_Instruction
        dc.l    _Zero_Divide
        dc.l    _Chk_Instruction
        dc.l    _Trapv_Instruction
        dc.l    _Privilege_Violation
        dc.l    _Trace
        dc.l    _Line_1010_Emulation
        dc.l    _Line_1111_Emulation
        dc.l     _Error_Exception, _Error_Exception, _Error_Exception, _Error_Exception
        dc.l     _Error_Exception, _Error_Exception, _Error_Exception, _Error_Exception
        dc.l     _Error_Exception, _Error_Exception, _Error_Exception, _Error_Exception
        dc.l    _Error_Exception
        dc.l    _INT
        dc.l    _EXTINT
        dc.l    _INT
        dc.l    hintCaller
        dc.l    _INT
        dc.l    _VINT
        dc.l    _INT
        dc.l    _trap_0                 /* Resume supervisor task */
        dc.l    _INT,_INT,_INT,_INT,_INT,_INT,_INT
        dc.l    _INT,_INT,_INT,_INT,_INT,_INT,_INT,_INT
        dc.l    _INT,_INT,_INT,_INT,_INT,_INT,_INT,_INT
        dc.l    _INT,_INT,_INT,_INT,_INT,_INT,_INT,_INT

rom_header:
        .incbin "out/rom_head.bin", 0, 0x100

_Entry_Point:
* disable interrupts
        move    #0x2700,%sr

* Configure a USER_STACK_LENGTH bytes user stack at bottom, and system stack on top of it
        move    %sp, %usp
        sub     #USER_STACK_LENGTH, %sp

* Halt Z80 (need to be done as soon as possible on reset)
        move.l  #0xA11100,%a0       /* Z80_HALT_PORT */
        move.w  #0x0100,%d0
        move.w  %d0,(%a0)           /* HALT Z80 */
        move.w  %d0,0x0100(%a0)     /* END RESET Z80 */

        tst.l   0xa10008
        bne.s   SkipInit

        tst.w   0xa1000c
        bne.s   SkipInit

* Check Version Number
        move.b  -0x10ff(%a0),%d0
        andi.b  #0x0f,%d0
        beq.s   NoTMSS

* Sega Security Code (SEGA)
        move.l  #0x53454741,0x2f00(%a0)

NoTMSS:
        jmp     _start_entry

SkipInit:
        jmp     _reset_entry


*------------------------------------------------
*
*       interrupt functions
*
*------------------------------------------------

_INT:
        movem.l %d0-%d1/%a0-%a1,-(%sp)
        move.l  intCB, %a0
        jsr    (%a0)
        movem.l (%sp)+,%d0-%d1/%a0-%a1
        rte

_EXTINT:
        movem.l %d0-%d1/%a0-%a1,-(%sp)
        move.l  eintCB, %a0
        jsr    (%a0)
        movem.l (%sp)+,%d0-%d1/%a0-%a1
        rte

_VINT:
        btst    #5, (%sp)       /* Skip context switch if not in user task */
        bne.s   no_user_task

        tst.w   task_lock
        bne.s   1f
        move.w  #0, -(%sp)      /* TSK_superPend() will return 0 */
        bra.s   unlock          /* If lock == 0, supervisor task is not locked */

1:
        bcs.s   no_user_task    /* If lock < 0, super is locked with infinite wait */
        subq.w  #1, task_lock   /* Locked with wait, subtract 1 to the frame count */
        bne.s   no_user_task    /* And do not unlock if we did not reach 0 */
        move.w  #1, -(%sp)      /* TSK_superPend() will return 1 */

unlock:
        /* Save bg task registers (excepting a7, that is stored in usp) */
        move.l  %a0, task_regs
        lea     (task_regs + UTSK_REGS_LEN), %a0
        movem.l %d0-%d7/%a1-%a6, -(%a0)

        move.w  (%sp)+, %d0     /* Load return value previously pushed to stack */

        move.w  (%sp)+, task_sr /* Pop user task sr and pc, and save them, */
        move.l  (%sp)+, task_pc /* so they can be restored later.          */
        movem.l (%sp)+, %d2-%d7/%a2-%a6 /* Restore non clobberable registers */

no_user_task:
        /* At this point, we always have in the stack the SR and PC of the task */
        /* we want to jump after processing the interrupt, that might be the    */
        /* point where we came from (if there is no context switch) or the      */
        /* supervisor task (if we unlocked it).                                 */

        movem.l %d0-%d1/%a0-%a1,-(%sp)
        ori.w   #0x0001, intTrace           /* in V-Int */
        addq.l  #1, vtimer                  /* increment frame counter (more a vint counter) */
        btst    #3, VBlankProcess+1         /* PROCESS_XGM_TASK ? (use VBlankProcess+1 as btst is a byte operation) */
        beq.s   no_xgm_task

        jsr     XGM_doVBlankProcess         /* do XGM vblank task */

no_xgm_task:
        btst    #1, VBlankProcess+1         /* PROCESS_BITMAP_TASK ? (use VBlankProcess+1 as btst is a byte operation) */
        beq.s   no_bmp_task

        jsr     BMP_doVBlankProcess         /* do BMP vblank task */

no_bmp_task:
        move.l  vintCB, %a0                 /* load user callback */
        jsr    (%a0)                        /* call user callback */
        andi.w  #0xFFFE, intTrace           /* out V-Int */
        movem.l (%sp)+,%d0-%d1/%a0-%a1
        rte

*------------------------------------------------
*
* Copyright (c) 1988 by Sozobon, Limited.  Author: Johann Ruegg
*
* Permission is granted to anyone to use this software for any purpose
* on any computer system, and to redistribute it freely, with the
* following restrictions:
* 1) No charge may be made other than reasonable charges for reproduction.
* 2) Modified versions must be clearly marked as such.
* 3) The authors are not responsible for any harmful consequences
*    of using this software, even if they result from defects in it.
*
*------------------------------------------------

ldiv:
        move.l  4(%a7),%d0
        bpl     ld1
        neg.l   %d0
ld1:
        move.l  8(%a7),%d1
        bpl     ld2
        neg.l   %d1
        eor.b   #0x80,4(%a7)
ld2:
        bsr     i_ldiv          /* d0 = d0/d1 */
        tst.b   4(%a7)
        bpl     ld3
        neg.l   %d0
ld3:
        rts

lmul:
        move.l  4(%a7),%d0
        bpl     lm1
        neg.l   %d0
lm1:
        move.l  8(%a7),%d1
        bpl     lm2
        neg.l   %d1
        eor.b   #0x80,4(%a7)
lm2:
        bsr     i_lmul          /* d0 = d0*d1 */
        tst.b   4(%a7)
        bpl     lm3
        neg.l   %d0
lm3:
        rts

lrem:
        move.l  4(%a7),%d0
        bpl     lr1
        neg.l   %d0
lr1:
        move.l  8(%a7),%d1
        bpl     lr2
        neg.l   %d1
lr2:
        bsr     i_ldiv          /* d1 = d0%d1 */
        move.l  %d1,%d0
        tst.b   4(%a7)
        bpl     lr3
        neg.l   %d0
lr3:
        rts

ldivu:
        move.l  4(%a7),%d0
        move.l  8(%a7),%d1
        bsr     i_ldiv
        rts

lmulu:
        move.l  4(%a7),%d0
        move.l  8(%a7),%d1
        bsr     i_lmul
        rts

lremu:
        move.l  4(%a7),%d0
        move.l  8(%a7),%d1
        bsr     i_ldiv
        move.l  %d1,%d0
        rts
*
* A in d0, B in d1, return A*B in d0
*
i_lmul:
        move.l  %d3,%a2           /* save d3 */
        move.w  %d1,%d2
        mulu    %d0,%d2           /* d2 = Al * Bl */

        move.l  %d1,%d3
        swap    %d3
        mulu    %d0,%d3           /* d3 = Al * Bh */

        swap    %d0
        mulu    %d1,%d0           /* d0 = Ah * Bl */

        add.l   %d3,%d0           /* d0 = (Ah*Bl + Al*Bh) */
        swap    %d0
        clr.w   %d0               /* d0 = (Ah*Bl + Al*Bh) << 16 */

        add.l   %d2,%d0           /* d0 = A*B */
        move.l  %a2,%d3           /* restore d3 */
        rts
*
*A in d0, B in d1, return A/B in d0, A%B in d1
*
i_ldiv:
        tst.l   %d1
        bne     nz1

*       divide by zero
*       divu    #0,%d0            /* cause trap */
        move.l  #0x80000000,%d0
        move.l  %d0,%d1
        rts
nz1:
        move.l  %d3,%a2           /* save d3 */
        cmp.l   %d1,%d0
        bhi     norm
        beq     is1
*       A<B, so ret 0, rem A
        move.l  %d0,%d1
        clr.l   %d0
        move.l  %a2,%d3           /* restore d3 */
        rts
*       A==B, so ret 1, rem 0
is1:
        moveq.l #1,%d0
        clr.l   %d1
        move.l  %a2,%d3           /* restore d3 */
        rts
*       A>B and B is not 0
norm:
        cmp.l   #1,%d1
        bne     not1
*       B==1, so ret A, rem 0
        clr.l   %d1
        move.l  %a2,%d3           /* restore d3 */
        rts
*  check for A short (implies B short also)
not1:
        cmp.l   #0xffff,%d0
        bhi     slow
*  A short and B short -- use 'divu'
        divu    %d1,%d0           /* d0 = REM:ANS */
        swap    %d0               /* d0 = ANS:REM */
        clr.l   %d1
        move.w  %d0,%d1           /* d1 = REM */
        clr.w   %d0
        swap    %d0
        move.l  %a2,%d3           /* restore d3 */
        rts
* check for B short
slow:
        cmp.l   #0xffff,%d1
        bhi     slower
* A long and B short -- use special stuff from gnu
        move.l  %d0,%d2
        clr.w   %d2
        swap    %d2
        divu    %d1,%d2           /* d2 = REM:ANS of Ahi/B */
        clr.l   %d3
        move.w  %d2,%d3           /* d3 = Ahi/B */
        swap    %d3

        move.w  %d0,%d2           /* d2 = REM << 16 + Alo */
        divu    %d1,%d2           /* d2 = REM:ANS of stuff/B */

        move.l  %d2,%d1
        clr.w   %d1
        swap    %d1               /* d1 = REM */

        clr.l   %d0
        move.w  %d2,%d0
        add.l   %d3,%d0           /* d0 = ANS */
        move.l  %a2,%d3           /* restore d3 */
        rts
*       A>B, B > 1
slower:
        move.l  #1,%d2
        clr.l   %d3
moreadj:
        cmp.l   %d0,%d1
        bhs     adj
        add.l   %d2,%d2
        add.l   %d1,%d1
        bpl     moreadj
* we shifted B until its >A or sign bit set
* we shifted #1 (d2) along with it
adj:
        cmp.l   %d0,%d1
        bhi     ltuns
        or.l    %d2,%d3
        sub.l   %d1,%d0
ltuns:
        lsr.l   #1,%d1
        lsr.l   #1,%d2
        bne     adj
* d3=answer, d0=rem
        move.l  %d0,%d1
        move.l  %d3,%d0
        move.l  %a2,%d3           /* restore d3 */
        rts

================
File: src/collisions.h
================
#ifndef _COLLISIONS_H_
#define _COLLISIONS_H_

#define MAX_INTERACTIVE_DISTANCE 20 // Distance in pixels with items you can interact

#define MAX_COLLISIONS 100 // Maximimum number of collisions to check before fixing position
extern u8 num_colls; // Number of collisions that already happened

// Distances
u16 char_distance(u16 char1, s16 x1, u8 y1, u16 char2); // Calculate distance between two characters at given coordinates
u16 item_distance(u16 nitem, u16 x, u8 y); // Calculate distance between coordinates and an item's collision box center

// Collisions
u16 detect_char_char_collision(u16 nchar, u16 x, u8 y); // Detect collisions between a character and all other characters at given coordinates
u16 detect_char_item_collision(u16 nchar, u16 x, u8 y); // Detect collisions between a character and every item, given some new coordinates
u16 detect_char_enemy_collision(u16 nchar, u16 x, u8 y); // Detect collisons between a character in every enemy, given some new coordinates
u16 detect_enemy_char_collision(u16 nenemy, u16 x, u8 y); // Detect collisions between an enemy and every character, given some new coordinates


#endif

================
File: src/controller.h
================
#ifndef _CONTROLLER_H_
#define _CONTROLLER_H_

void joy_check(void); // Main function to check and handle joystick input
void handle_movement(u16 joy_value); // Handle character movement based on joystick input
void handle_character_movement(s16 dx, s16 dy); // Move the character if there's no collision and it's within the screen limits. This function also handles background scrolling if the character is at the screen edge.
void update_character_animation(void); //Update the character's animation based on its current state
void handle_action_buttons(u16 joy_value); // Handle action button inputs (A, B, C, X, Y, Z)
void update_action_animation(void); // Update the character's animation when playing a musical note
void handle_pause_button(u16 joy_value); // Handle the pause button input

#endif // _CONTROLLER_H_

================
File: src/init.h
================
#ifndef _INIT_H_
#define _INIT_H_

void initialize(bool first_time); // Initialize engine
void new_level(const TileSet *tile_bg, const MapDefinition *map_bg, const TileSet *tile_front, const MapDefinition *map_front, Palette new_pal, u16 new_background_width, u8 new_scroll_mode, u8 new_scroll_speed); // Initialize level 
void end_level(void); // Free all resources used by the level

#endif

================
File: src/interface.h
================
#ifndef _INTERFACE_H_
#define _INTERFACE_H_

// Define a type to store visibility state (for hidding them all in pause screen)
typedef struct {
    Sprite* sprite;
    SpriteVisibility visibility;
} SpriteState;

// Interface sprites
extern Sprite *spr_face_left; // Left face BG
extern Sprite *spr_face_right; // Right face BG
extern Sprite *spr_int_button_A; // Button with an A
extern Map *map_int_rod; // Rod
extern Sprite *spr_int_rod_1,*spr_int_rod_2,*spr_int_rod_3,*spr_int_rod_4,*spr_int_rod_5,*spr_int_rod_6; // Rod (notes)
extern Sprite *spr_int_enemy_rod_1,*spr_int_enemy_rod_2,*spr_int_enemy_rod_3,*spr_int_enemy_rod_4,*spr_int_enemy_rod_5,*spr_int_enemy_rod_6; // Rod (enemy notes)
extern Sprite *spr_int_pentagram_1,*spr_int_pentagram_2,*spr_int_pentagram_3,*spr_int_pentagram_4,*spr_int_pentagram_5,*spr_int_pentagram_6; // Pentagram (notes)
extern Sprite *spr_int_life_counter; // Life counter

// Pause screen sprites
extern Sprite *spr_pause_icon[5]; // Icon list
extern Sprite *spr_pattern_list_note[4]; // The 4 notes in right of the pattern list

// Others
extern bool interface_active; // Do we have to show the interface?

void show_or_hide_interface(bool visible); // Show or hide the bottom interface
void show_note(u8 nnote, bool visible); // Show or hide notes
void hide_rod_icons(void); // Hide icons in the rod
void hide_pentagram_icons(void); // Hide icons in the pentagram
void hide_pattern_icons(void); // Hide all pattern icons
void show_pattern_icon(u16 npattern, bool show, bool priority); // Show or hide the icon of a pattern spell
void restoreSpritesVisibility(SpriteState* states, u16 count); // Function to restore the visibility of sprites
SpriteState* hideAllSprites(u16* count); // Function to hide all sprites and save their state
void pause_screen(void); // Pause / State screen
void show_pause_pattern_list(bool show, u8 active_pattern); // Show or hide pattern list (Pause screen)
void show_note_in_pause_pattern_list(u8 npattern, u8 nnote, bool show); // Show one of the notes of a pattern in the pattern list (Pause screen)
void show_icon_in_pause_list(u16 npattern, u8 nicon, u16 x, bool show, bool priority); // Show one of the notes of a pattern in the pattern list (Pause screen)
void check_pattern_status(void); // Check the status of the current pattern, including note playing and expiration


#endif

================
File: src/patterns/pattern_en_bite.c
================
#include "globals.h"

// Launch callback — currently does nothing
void enemyBiteLaunch(u8 enemyId)
{
    (void)enemyId;    // unused for now
}

// Update callback — returns true when finished
bool enemyBiteUpdate(u8 enemyId)
{
    const u16 duration = enemyPatterns[enemyId][0].baseDuration;

    if (++combatContext.effectTimer >= duration)
        return true;     // finished
    return false;        // keep running
}

================
File: src/patterns/pattern_en_bite.h
================
#ifndef PATTERN_EN_BITE_H
#define PATTERN_EN_BITE_H

#include "globals.h"


// Launch the spell
void enemyBiteLaunch(u8 enemyId);

// Update the ongoing spell
bool enemyBiteUpdate(u8 enemyId);

#endif

================
File: src/patterns/pattern_en_thunder.c
================
#include "globals.h"

// Launch callback — currently does nothing
void enemyThunderLaunch(u8 enemyId)
{
    (void)enemyId;    // unused for now
}

// Update callback — returns true when finished
bool enemyThunderUpdate(u8 enemyId)
{
    const u16 duration = enemyPatterns[enemyId][0].baseDuration; // slot 0 = Electric/Thunder

    if (++combatContext.effectTimer >= duration)
        return true;     // finished
    return false;        // keep running
}

// Called when the pattern is countered — currently does nothing
void enemyThunderOnCounter(u8 enemyId)
{
    (void)enemyId;
}

================
File: src/patterns/pattern_en_thunder.h
================
#ifndef PATTERN_EN_THUNDER_H
#define PATTERN_EN_THUNDER_H

#include "globals.h"


// Launch the spell
void enemyThunderLaunch(u8 enemyId);

// Update the ongoing spell
bool enemyThunderUpdate(u8 enemyId);

// Pattern has been countered
void enemyThunderOnCounter(u8 enemyId);     // opcional (solo si counterable)

#endif /* PATTERN_EN_THUNDER_H */

================
File: src/patterns/pattern_hide.c
================
#include "globals.h"

// Launch callback — currently does nothing
void playerHideLaunch(void)
{
}

// Update callback
bool playerHideUpdate(void)
{
    const u16 duration = playerPatterns[PATTERN_HIDE].baseDuration;

    if (++combatContext.effectTimer >= duration)
        return true;        // finished
    return false;           // keep running
}

// C
bool playerHideCanUse(void)
{
    return false;           // never available
}

================
File: src/patterns/pattern_hide.h
================
#ifndef PATTERN_HIDE_H
#define PATTERN_HIDE_H

#include "globals.h"

// Launch the spell
void playerHideLaunch(void);

// Update the ongoing spell.
// Returns true when the effect is finished.
bool playerHideUpdate(void);

// Check if the pattern can be used
bool playerHideCanUse(void);

#endif // PATTERN_HIDE_H

================
File: src/patterns/pattern_open.c
================
#include "globals.h"

// Launch callback — currently does nothing
void playerOpenLaunch(void)
{
}

// Update callback
bool playerOpenUpdate(void)
{
    const u16 duration = playerPatterns[PATTERN_OPEN].baseDuration;

    if (++combatContext.effectTimer >= duration)
        return true;        // finished
    return false;           // keep running
}

bool playerOpenCanUse(void)
{
    return false;           // never available
}

================
File: src/patterns/pattern_open.h
================
#ifndef PATTERN_OPEN_H
#define PATTERN_OPEN_H

#include "globals.h"

// Launch the spell
void playerOpenLaunch(void);

// Update the ongoing spell.
// Returns true when the effect is finished.
bool playerOpenUpdate(void);

// Check if the pattern can be used
bool playerOpenCanUse(void);

#endif // PATTERN_OPEN_H

================
File: src/patterns/pattern_sleep.c
================
#include "globals.h"

// Launch callback — currently does nothing
void playerSleepLaunch(void)
{
}

// Update callback
bool playerSleepUpdate(void)
{
    const u16 duration = playerPatterns[PATTERN_HIDE].baseDuration;

    if (++combatContext.effectTimer >= duration)
        return true;        // finished
    return false;           // keep running
}

bool playerSleepCanUse(void)
{
    return false;           // never available
}

================
File: src/patterns/pattern_sleep.h
================
#ifndef PATTERN_SLEEP_H
#define PATTERN_SLEEP_H

#include "globals.h"

// Launch the spell
void playerSleepLaunch(void);

// Update the ongoing spell.
// Returns true when the effect is finished.
bool playerSleepUpdate(void);

// Check if the pattern can be used
bool playerSleepCanUse(void);

#endif // PATTERN_SLEEP_H

================
File: memory_bank/activeContext.md
================
# Active Context

## Current Development Status
The game is in early stages of development, currently functioning as a technical demo targeting a late 2025 release.

## Recent Changes
- Implementation of Act 1 with multiple scenes
- Basic combat system with enemy encounters
- Musical pattern/spell system implementation
- Character dialogue system with choice mechanics
- Scene transitions and environment interactions
- Created `projectBrief.md` to document project requirements
- Initiated Memory Bank update

## Current Focus
- Act 1 implementation and polish
- Core gameplay mechanics refinement
- Technical demo development
- Updating Memory Bank with current project state

## Development Setup
- Genesis/Megadrive development environment
- Resource compilation pipeline
- Build system for ROM generation
- Debugging tools for Genesis hardware

## Code Conventions
- Data types defined in Sega Genesis libraries are used: u8, u16, s8, s16, etc.
- All include statements are centralized in `globals.h`.
- Other header files (.h) do not require include statements.
- C files (.c) only include `globals.h`.

## Next Steps
1. Complete remaining Act 1 scenes
2. Polish existing gameplay mechanics
3. Implement additional spells and patterns
4. Enhance combat system
    - Refactor Combat System (Propuesta 1: Sistema de Estados y Mensajes)
        - Phase 1: Preparation ✅ (Document current system, identify dependencies, create basic tests, backup code)
            - Dependencies:
                - `character_patterns.c`: `genesis.h`, `globals.h`
                - `enemies_patterns.c`: `genesis.h`, `globals.h`
                - `combat.c`: `genesis.h`, `globals.h`
                - `enemies.c`: `genesis.h`, `globals.h`
            - Global Variables:
                - `character_patterns.c`: `player_patterns_enabled`, `note_playing`, `note_playing_time`, `time_since_last_note`, `player_pattern_effect_in_progress`, `player_pattern_effect_reversed`, `player_pattern_effect_time`, `played_notes[4]`, `num_played_notes`, `obj_pattern[MAX_PATTERNS]`
                - `enemies_patterns.c`: `obj_Pattern_Enemy[MAX_PATTERN_ENEMY]`, `enemy_attacking`, `enemy_attack_pattern`, `enemy_attack_pattern_notes`, `enemy_attack_time`, `enemy_attack_effect_in_progress`, `enemy_attack_effect_time`, `enemy_note_active[6]`
                - `combat.c`: `is_combat_active`
                - `enemies.c`: `obj_enemy[MAX_ENEMIES]`, `spr_enemy[MAX_ENEMIES]`, `spr_enemy_face[MAX_ENEMIES]`, `spr_enemy_shadow[MAX_ENEMIES]`, `obj_enemy_class[MAX_ENEMY_CLASSES]`
        - Phase 2: Refactorización Base 🔄 (En progreso)
            - ✅ Creación inicial de la biblioteca de máquina de estados en `statemachine.h` y `statemachine.c`
            - ✅ Expandir la implementación actual de `statemachine.h` y `statemachine.c`:
                - ✅ Actualizar el enum `SM_State` para incluir: `SM_STATE_IDLE`, `SM_STATE_PLAYING_NOTE`, `SM_STATE_PATTERN_CHECK`, `SM_STATE_PATTERN_EFFECT`, `SM_STATE_PATTERN_EFFECT_FINISH`, `SM_STATE_ATTACK_FINISHED`
                - ✅ Expandir el enum `MessageType` para incluir: `MSG_PATTERN_COMPLETE`, `MSG_COMBAT_START`, `MSG_COMBAT_END`, `MSG_ENEMY_DEFEATED`, `MSG_PLAYER_HIT`, `MSG_ENEMY_HIT`, `MSG_NOTE_PLAYED`, `MSG_PATTERN_TIMEOUT`
                - ✅ Expandir la estructura `StateMachine` para incluir: `current_state`, `timer`, `notes[4]`, `note_count`, `current_note`, `note_time`, `pattern_time`, `active_pattern`, `is_reversed`, `effect_time`, `entity_id`
                - ✅ Actualizar las funciones `StateMachine_Init` y `StateMachine_Update`
                - ✅ Añadir función `StateMachine_SendMessage`
            - ✅ Crear documentación detallada de la máquina de estados (ver `memory_bank/state_machine_implementation_plan.md`)
            - 🔄 Pendiente: Mover variables globales relacionadas con el combate a la estructura `StateMachine`
            - 🔄 Pendiente: Incluir los archivos de cabecera necesarios
        - Phase 3: Implementación Core ⏳ (Pendiente)
            - Modificar `character_patterns.c`, `enemies_patterns.c`, y `combat.c` para usar la máquina de estados
            - Implementar función `combat_update` para manejar transiciones de estado basadas en mensajes
            - Implementar funciones para enviar mensajes
            - Modificar `enemies.c` para reaccionar a mensajes de combate
        - Phase 4: Finalization ⏳ (Pendiente)
            - Pruebas exhaustivas de todos los escenarios de combate
            - Asegurar compatibilidad con SGDK
            - Optimizar rendimiento
            - Documentación final y limpieza de código
5. Add more character interactions and story elements

================
File: memory_bank/progress.md
================
# Progress Tracking

## Completed Features

### Core Systems
- ✅ Basic game engine implementation
- ✅ Scene management system
- ✅ Character movement and control
- ✅ Dialog system with choices
- ✅ Basic combat system
- ✅ Musical pattern/spell system
- ✅ Resource management system

### Act 1 Progress
- ✅ Scene 1: Bedroom scene with dream sequence
- ✅ Scene 2: Historians corridor with book interactions
- ✅ Scene 3: Main hall with character dialogues
- ✅ Scene 5: Combat demonstration scene

### Technical Features
- ✅ Background scrolling
- ✅ Character animations
- ✅ Multi-language support
- ✅ Sound effects system
- ✅ Music playback
- ✅ Sprite management
- ✅ Palette management

## In Progress
- 🔄 Act 1 polish and refinement
- 🔄 Combat system enhancement
  - 🔄 Refactorización del sistema de combate usando máquina de estados
  - 🔄 Expansión de la implementación de statemachine.c/h
- 🔄 Additional spell patterns
- 🔄 Character interaction improvements
- 🔄 Memory Bank Update

## Remaining Work

### Content
- ⏳ Complete Act 1 missing scenes (Scene 4)
- ⏳ Additional acts and scenes
- ⏳ More enemy types
- ⏳ Additional spell patterns
- ⏳ Extended dialogue and story content

### Technical
- ⏳ Performance optimization
- ⏳ Memory usage optimization
- ⏳ Additional gameplay mechanics
- ⏳ Enhanced visual effects
- ⏳ Audio system improvements
- 🔄 Combat system refactoring
  - ✅ Phase 1: Preparation (documentación, identificación de dependencias)
  - 🔄 Phase 2: Refactorización Base
    - ✅ Creación inicial de la biblioteca de máquina de estados
    - ✅ Expansión de statemachine.c/h con estados y mensajes adicionales
    - 🔄 Integración con sistemas existentes
  - ⏳ Phase 3: Implementación Core
  - ⏳ Phase 4: Finalization

### Polish
- ⏳ UI/UX improvements
- ⏳ Balance adjustments
- ⏳ Bug fixes and refinements
- ⏳ Asset quality improvements

## Technical Constraints
- 16-bit architecture limitations
- Hardware sprite and tile restrictions
- Audio channel management
- Memory management for assets
- Performance optimization requirements

## Current Status
Technical demo in development, targeting January 2025 release. Core gameplay systems are functional with Act 1 serving as the primary demonstration of features. `projectBrief.md` was created to document project requirements.

## Próximos Pasos Inmediatos
1. ✅ Implementar los cambios en statemachine.c/h según las instrucciones en `statemachine_implementation_instructions.md`
2. 🔄 Integrar la máquina de estados con el sistema de patrones del personaje (character_patterns.c)
3. ⏳ Integrar la máquina de estados con el sistema de patrones de enemigos (enemies_patterns.c)
4. ⏳ Crear una función combat_update en combat.c que utilice la máquina de estados

================
File: memory_bank/systemPatterns.md
================
# Default Collision Box Pattern

Unless explicitly defined otherwise, collision boxes for all entities (characters, items, enemies) should follow this pattern:

- Width: 50% of sprite width (x_size/2)
- X offset: 25% of sprite width (x_size/4) to center the collision box horizontally
- Height: 2 pixels
- Y offset: At the bottom of sprite (y_size-1)

This creates a small collision area at the feet of the sprite, which is ideal for:
- Character-to-character interactions
- Item pickups
- Combat collision detection

================
File: res/Backgrounds/Act1/forest.pal
================
JASC-PAL
0100
16
0 0 0 0
0 0 0 255
115 115 115 255
168 84 0 255
15 73 104 255
252 252 252 255
121 13 121 255
0 168 0 255
180 112 37 255
255 0 242 255
6 107 28 255
98 55 9 255
36 36 36 255
100 213 101 255
54 27 8 255
75 75 75 255

================
File: res/res_enemies.res
================
# Weaver Ghost
SPRITE weaver_ghost_sprite "Sprites/Enemies/weaver_ghost.png" 6 8 BEST 15
SPRITE weaver_ghost_sprite_face "Sprites/Enemies/weaver_ghost_face.png" 2 2 BEST

# Three Head Monkey
SPRITE three_head_monkey_sprite "Sprites/Enemies/3_head_monkey.png" 8 7 BEST 5
SPRITE three_head_monkey_sprite_face "Sprites/Enemies/3_head_monkey_face.png" 2 2 BEST
SPRITE three_head_monkey_sprite_shadow "Sprites/Enemies/3_head_monkey_shadow.png" 8 1 BEST 5

================
File: res/res_intro.res
================
# Logo
IMAGE intro_logo_bg "Intro/Logo_bg.png" BEST

# Stars
SPRITE intro_stars_sprite "Intro/Stars.png" 2 2 BEST 10

# Intro Music
XGM2 music_intro "Sound/Music/TheWeave_intro.vgm"

================
File: res/res_sound.res
================
# Player notes
XGM2 snd_note_mi "Sound/Notes/01-FM_note_E4.vgm"
XGM2 snd_note_fa "Sound/Notes/02-FM_note_F4.vgm"
XGM2 snd_note_sol "Sound/Notes/03-FM_note_G4.vgm"
XGM2 snd_note_la "Sound/Notes/04-FM_note_A4.vgm"
XGM2 snd_note_si "Sound/Notes/05-FM_note_B4.vgm"
XGM2 snd_note_do "Sound/Notes/06-FM_note_C5.vgm"

# Enemy notes
XGM2 snd_enemy_note_mi "Sound/Notes/07-Enemy_note_E3.vgm"
XGM2 snd_enemy_note_fa "Sound/Notes/08-Enemy_note_F3.vgm"
XGM2 snd_enemy_note_sol "Sound/Notes/09-Enemy_note_G3.vgm"
XGM2 snd_enemy_note_la "Sound/Notes/10-Enemy_note_A3.vgm"
XGM2 snd_enemy_note_si "Sound/Notes/11-Enemy_note_B3.vgm"
XGM2 snd_enemy_note_do "Sound/Notes/12-Enemy_note_C4.vgm"

# Pattern effect sounds
WAV snd_pattern_thunder "Sound/Patterns/pattern_thunder.wav" XGM2
WAV snd_pattern_hide "Sound/Patterns/pattern_hide.wav" XGM2
WAV snd_pattern_open "Sound/Patterns/pattern_open.wav" XGM2
WAV snd_pattern_invalid "Sound/Patterns/pattern_invalid.wav" XGM

WAV snd_player_hurt "Sound/Player/player_hurt.wav" XGM2
WAV snd_player_hit_enemy "Sound/Player/player_hit_enemy.wav" XGM2

# Other effects

WAV snd_effect_magic_appear "Sound/Effects/effect_magic_appear.wav" XGM2
WAV snd_effect_magic_disappear "Sound/Effects/effect_magic_appear_inverted.wav" XGM2

================
File: src/dialogs.h
================
#ifndef _DIALOGS_H_
#define _DIALOGS_H_

#define DEFAULT_TALK_TIME 10   // Default maximum time in conversations (10 seconds)
#define DEFAULT_CHOICE_TIME 30   // Default maximum time for choices (30 seconds)

void talk(u8 nface, bool isinleft, char *text, u16 max_seconds); // Make a character talk
void talk_dialog(const DialogItem *dialog); // Talk a dialog line
void split_text(char *input_text, char *line1, char *line2, char *line3); // Split a text in up to three lines
void print_line(char *text, u16 x, u16 y, bool wait_for_frame); // Print a line of text, character by character
u8 choice(u8 nface, bool isinleft, char **options, u8 num_options, u16 max_seconds); // Show a choice dialog directly
u8 choice_dialog(const ChoiceItem *choice); // Show a choice dialog from a ChoiceItem

#endif

================
File: src/entity.h
================
#ifndef _ENTITY_H_
#define _ENTITY_H_

// Animations
#define ANIM_IDLE       0
#define ANIM_WALK       1
#define ANIM_ACTION     2
#define ANIM_MAGIC      3

// Global variables
extern bool movement_active;

// Entities states
typedef enum {
    STATE_IDLE,
    STATE_WALKING,
    STATE_PLAYING_NOTE,
    STATE_PATTERN_FINISHED,
    STATE_PATTERN_CHECK,
    STATE_PATTERN_EFFECT,
    STATE_PATTERN_EFFECT_FINISH,
    STATE_ATTACK_FINISHED,
    STATE_FOLLOWING
} GameState;

// Game entity definition
typedef struct
{
    bool                    active;
    const SpriteDefinition  *sd;
    const SpriteDefinition  *sd_shadow;
    s16                     x;
    s16                     y;
    u8                      x_size;
    u8                      y_size;
    u16                     palette;
    u8                      priority;
    u8                      flipH;
    u8                      animation;
    bool                    visible;
    u8                      collision_x_offset;
    u8                      collision_y_offset;
    u8                      collision_width;
    u8                      collision_height;
    GameState               state;
    bool                    follows_character;
    u8                      follow_speed;
    bool                    drops_shadow;
} Entity;

void move_entity(Entity *entity, Sprite *sprite, s16 newx, s16 newy); // Move an entity

#endif

================
File: src/patterns/pattern_thunder.c
================
#include "globals.h"

#define PAL_ENTRY(pal, col)   (((pal) << 4) | (col)) 
#define PAL0_COL4             PAL_ENTRY(0, 4)
#define COLOR_WHITE_VDP  RGB24_TO_VDPCOLOR(0xFFFFFF)

static u16 savedColor; // original colour in CRAM before the flash

// Launch callback
void playerThunderLaunch(void)
{
    // Save current CRAM entry so we can restore it later            */
    savedColor = PAL_getColor(PAL0_COL4); 
    dprintf(2, "Thunder: initial CRAM colour 0-4 = 0x%04X\n", savedColor);

    // First frame: set to white so the flash is immediate
    PAL_setColor(PAL0_COL4, COLOR_WHITE_VDP);
    combatContext.effectTimer = 0;

    // Sound effect
    play_sample(snd_pattern_thunder, sizeof(snd_pattern_thunder)); // play thunder sound
}

// Update callback
bool playerThunderUpdate(void)
{
    const u16 duration = playerPatterns[PATTERN_THUNDER].baseDuration;

    // Toggle each frame between white and the original color
    const bool evenFrame  = (combatContext.effectTimer & 1) == 0;
    const u16  flashColor = evenFrame ? COLOR_WHITE_VDP : savedColor;
    PAL_setColor(PAL0_COL4, flashColor);

    // Advance timer and test end-of-effect                          
    if (++combatContext.effectTimer >= duration)
    {
        // Restore CRAM entry exactly as it was before the spell     
        PAL_setColor(PAL0_COL4, savedColor); 
        dprintf(2, "Thunder done: restoring color");
        return true; // pattern finished
    }
    return false;
}

bool playerThunderCanUse(void)
{
    return true;           // always available
}

================
File: src/texts.h
================
#ifndef _TXT_H_
#define _TXT_H_

// Languages
#define NUM_LANGUAGES 2
#define MAX_CHOICES 4

enum Languages {
    LANG_SPANISH,
    LANG_ENGLISH
};
extern u8 game_language;

// Acts and dialogs
#define SYSTEM_DIALOG   0
#define ACT1_DIALOG1    1
#define ACT1_DIALOG2    2
#define ACT1_DIALOG3    3
#define ACT1_DIALOG4    4

// Choices
#define ACT1_CHOICE1    0

typedef struct {
    u8 face;
    bool side;
    u16 max_seconds;
    const char *text[NUM_LANGUAGES];
} DialogItem;

typedef struct {
    u8 face;
    bool side;
    u16 max_seconds;
    u8 num_options;
    const char *options[NUM_LANGUAGES][MAX_CHOICES];
} ChoiceItem;

// Game texts
extern const DialogItem *dialogs[];
extern const ChoiceItem *choices[];

// Functions
char* encode_spanish_text(const char* input); // Code Spanish text in the game font charset
u16 calculate_text_position(const char *text, bool is_face_left, bool has_face); // Calculate centered text position

#endif

================
File: res/res_geesebumps.res
================
# Palettes
PALETTE geesebumps_pal_black "Geesebumps/pal_black.pal"
PALETTE geesebumps_pal_white "Geesebumps/pal_white.pal"
PALETTE geesebumps_pal_white2 "Geesebumps/pal_white2.pal"
PALETTE geesebumps_pal_lines "Geesebumps/pal_lines.pal"

# Logo
IMAGE geesebumps_logo_bg "Geesebumps/Logo_bg.png" BEST
SPRITE geesebumps_logo_text "Geesebumps/Logo_text_com.png" 28 4 BEST
SPRITE geesebumps_logo_line1 "Geesebumps/Logo_lines1.png" 11 13 BEST
SPRITE geesebumps_logo_line2 "Geesebumps/Logo_lines2.png" 7 6 BEST

# Intro Music
XGM2 music_geesebumps "Sound/Music/Goosebumps_intro.vgm"

================
File: src/characters.h
================
#ifndef _CHARACTERS_H_
#define _CHARACTERS_H_

// Characters
#define MAX_CHR       4
#define CHR_linus     0
#define CHR_clio      1
#define CHR_xander    2
#define CHR_swan      3
#define CHR_NONE      254

// Faces
#define MAX_FACE      4
#define FACE_linus    0
#define FACE_clio     1
#define FACE_xander   2
#define FACE_swan     3
#define FACE_none     250

// Sides
#define SIDE_left     true
#define SIDE_right    false
#define SIDE_none     true

// Distances for following characters
#define MAX_FOLLOW_DISTANCE 40
#define MIN_FOLLOW_DISTANCE 20

// Characters
extern Entity obj_character[MAX_CHR];
extern Sprite *spr_chr[MAX_CHR];
extern Sprite *spr_chr_shadow[MAX_CHR];
extern u16 active_character; // Which character is the active one
extern bool movement_active; // Can you move ?

// Faces
extern Entity obj_face[MAX_FACE];
extern Sprite *spr_face[MAX_FACE];

void init_character(u16 nchar); // Initialize a character
void release_character(u16 nchar); // Release a character from memory
void init_face(u16 nface); // Initialize a face
void release_face(u16 nface); // Release a face from memory
void update_character(u16 nchar); // Update a character based on every parameter
void show_character(u16 nchar, bool show); // Show or hide a character
void anim_character(u16 nchar, u8 newanimation); // Change a character's animation
void look_left(u16 nchar, bool left); // Make a character look to the left (or right)
void move_character(u16 nchar, s16 x, s16 y); // Move a character to a new position
void move_character_instant(u16 nchar, s16 x, s16 y); // Move a character to a new position (instantly)
void update_sprites_depth(void); // Update characters, items and enemies depth
void update_character_shadow(u16 nchar); // Update shadow position for a character
void follow_active_character(u16 nchar, bool follow, u8 follow_speed); // Follow (or unfollow active character)
void approach_characters(void); // Move characters with STATE_FOLLOWING towards the active character
void reset_character_animations(void); // Reset all character animations to idle

#endif

================
File: src/combat.h
================
#ifndef _COMBAT_H_
#define _COMBAT_H_

typedef enum
{
    COMBAT_NO,                          /* no combat active - no enemies */
    COMBAT_STATE_IDLE,                 /* combat active, everybody waiting  */
    /* --- player turn ----------------------------------------------------- */
    /* NOTE: If no combat is active, but player is casting a Spell ... */
    /* we can use these states with no active enemies */
    COMBAT_STATE_PLAYER_PLAYING,       /* player is playing invocation notes    */
    COMBAT_STATE_PLAYER_EFFECT,        /* player spell effect is active         */
    /* --- enemy counter-window (optional) --------------------------------- */
    COMBAT_STATE_PLAYER_COUNTER,       /* player is attempting a counter-spell  */
    /* --- enemy turn ------------------------------------------------------ */
    COMBAT_STATE_ENEMY_PLAYING,        /* enemy is playing its notes            */
    COMBAT_STATE_ENEMY_EFFECT,         /* enemy spell effect is active          */
    /* --- hit / impact feedback ------------------------------------------ */
    COMBAT_STATE_PLAYER_HIT,           /* player receives damage – show flash   */
    COMBAT_STATE_ENEMY_HIT             /* enemy receives damage – show flash    */
} CombatState;
extern CombatState combat_state; // Current combat state

typedef struct {
    CombatState state;        // current combat phase                      
    u16         frameInState; // ++ every frame, reset on state change     
    /* active pattern (either side) -------------------------------------- */
    u16         activePattern;
    u16         effectTimer;  // frames since effect started               
    bool     patternReversed; // true = effect was reflected / reversed    
    /* note–playing phase ------------------------------------------------ */
    u16         noteTimer;    // frames since current note started         
    u8          playerNotes;  // how many notes the player has played (0-4)
    u8          enemyNotes;   // how many notes the enemy has played  (0-4)
    /* attacker id (relevant only during enemy phases) ------------------- */
    u8          activeEnemy;  // ENEMY_NONE = none                         
} CombatContext;
extern CombatContext combatContext; // Combat context

#endif

================
File: src/geesebumps.c
================
#include "globals.h"

static bool should_exit = false;

static void joyEvent_Geesebumps(u16 joy, u16 changed, u16 state)
{
    // If button A was just pressed
    if ((changed & BUTTON_A) && (state & BUTTON_A))
    {
        should_exit = true;
    }
}

void geesebumps_logo(void)
{
    Sprite *logo_text, *logo_lines1, *logo_lines2;
    should_exit = false;

    initialize(false);
    
    // Set up the joystick handler
    JOY_setEventHandler(&joyEvent_Geesebumps);

    VDP_setBackgroundColor(13);
    PAL_setPalette(PAL0, geesebumps_pal_black.data, DMA);
    PAL_setPalette(PAL1, geesebumps_pal_white.data, DMA);
    PAL_setPalette(PAL2, geesebumps_pal_white.data, DMA);
    PAL_setPalette(PAL3, geesebumps_pal_white.data, DMA);

    // Background music
    play_music(music_geesebumps);
    
    // Fist part of the logo (Goose)
    VDP_drawImageEx(BG_A, &geesebumps_logo_bg, TILE_ATTR_FULL(PAL0, false, false, false, tile_ind), 0, 0, false, true);
    tile_ind+=geesebumps_logo_bg.tileset->numTile;

    // Load every other srpite
    logo_text = SPR_addSpriteSafe(&geesebumps_logo_text, 60, 163, TILE_ATTR(PAL1, false, false, false));
    logo_lines1 = SPR_addSpriteSafe(&geesebumps_logo_line1, 81-180, 55, TILE_ATTR(PAL2, false, false, false));
    logo_lines2 = SPR_addSpriteSafe(&geesebumps_logo_line2, 81-180, 84, TILE_ATTR(PAL3, false, false, false));
    SPR_setVisibility(logo_text, HIDDEN);
    SPR_update();

    // Second part (Text) fade in
    if (!should_exit) {
        // Start first fade asynchronously
        PAL_fade(0, 15, geesebumps_pal_black.data, geesebumps_logo_bg.palette->data, SCREEN_FPS*2, true);
                
        // Wait for fade completion or button press
        while (PAL_isDoingFade() && !should_exit) {
            SYS_doVBlankProcess();
        }
        PAL_setPalette(PAL0, geesebumps_logo_bg.palette->data, DMA);
        SYS_doVBlankProcess();

        if (!should_exit) {
            SPR_setVisibility(logo_text, VISIBLE);
            SPR_update();
            
            // Start second fade asynchronously
            PAL_fade(16, 31, geesebumps_pal_white.data, geesebumps_logo_text.palette->data, SCREEN_FPS*2, true);
            
            // Wait for fade completion or button press
            while (PAL_isDoingFade() && !should_exit) {
                SYS_doVBlankProcess();
            }
            PAL_setPalette(PAL1, geesebumps_logo_text.palette->data, DMA);
            SYS_doVBlankProcess();
        }
    }

    // Third and fourth part (Color lines) fade in and scroll
    if (!should_exit) {
        PAL_initFade(32, 63, geesebumps_pal_white2.data, geesebumps_pal_lines.data, SCREEN_FPS*3);
        for (u16 difx=180; difx>0 && !should_exit; difx--) {
            SPR_setPosition(logo_lines1, 81-difx, 55);
            SPR_setPosition(logo_lines2, 81-difx, 84);
            SPR_update();
            PAL_doFadeStep();
            SYS_doVBlankProcess();
        }
    }

    // Pause and fade out - these happen regardless of button press
    if (!should_exit) waitMs(3000);
    PAL_fadeOutAll(SCREEN_FPS*2, false);
    fade_music(SCREEN_FPS*2);
    waitMs(2000);

    // Release everything
    JOY_setEventHandler(NULL);
    VDP_releaseAllSprites();
    SPR_reset();
    VDP_clearPlane(BG_A, true);
    tile_ind-=geesebumps_logo_bg.tileset->numTile;   
}

================
File: src/globals.c
================
#include "globals.h"

u16 tile_ind;        // Current tile index for VDP tile loading
u16 frame_counter;   // Counter incremented each frame for RNG and timing
u8 current_act;      // Current game act number
u8 current_scene;    // Current scene number within act
u8 SCREEN_FPS;      // Screen refresh rate (50 for PAL, 60 for NTSC)

void wait_seconds(int sec)    // Pause execution for specified number of seconds
{
    u16 num_ticks=0;
    u16 max_ticks=sec*SCREEN_FPS; // Ticks
    while (num_ticks<max_ticks)
    {
        next_frame(false);
        num_ticks++;
    }
}

void next_frame(bool interactive)    // Process next frame with optional interactive updates (movement, combat, etc)
{
    if (interactive==true) {
        // Check controller
        if (movement_active==true) {
            joy_check();
            if (player_patterns_enabled) check_pattern_status();
        }

        // Active haracter state related actions 
        // check_active_character_state();

        // Approach other characters
        approach_characters();

        // Combat related actions
        // if (is_combat_active==true) {
            // check_enemy_state();
            // approach_enemies();
        // }
    }

    // Screen related actions
    update_bg(true); // First time we print the background, assume the player moved so it's fully painted

    // Items related actions
    check_items_visibility();

    // Sprites related actions
    update_sprites_depth();
    SPR_update();

    // Create an RNG seed depending of the number of frames
    frame_counter++;
    
    // Wait for next frame
    SYS_doVBlankProcess();
}

// Convert milliseconds to system ticks based on screen refresh rate
u16 calc_ticks(u16 milliseconds)    
{
    if (SCREEN_FPS == 50) {
        // 50 FPS: 1 tick ≈ 20 ms
        return (milliseconds / 20);
    } else if (SCREEN_FPS == 60) {
        // 60 FPS: 1 tick ≈ 16.67 ms
        return ((milliseconds<<2) + (milliseconds<<1)) / 100;
    } else return ((milliseconds*1000)/SCREEN_FPS);
}

================
File: src/items.h
================
#ifndef _ITEMS_H_
#define _ITEMS_H_

#include "entity.h"

#define MAX_ITEMS 10
#define ITEM_NONE 254
#define COLLISION_DEFAULT 9999

// Depth check modes for items
#define FORCE_FOREGROUND 0
#define FORCE_BACKGROUND 1
#define CALCULATE_DEPTH 2

typedef struct {
    Entity entity;
    //bool interactable; // Can the player interact?
    u16 x_in_background; // X coordinate, relative to the background
    u8 check_depth; // How to handle sprite depth (FORCE_FOREGROUND, FORCE_BACKGROUND, or CALCULATE_DEPTH)
} Item;

extern Item obj_item[MAX_ITEMS];
extern Sprite *spr_item[MAX_ITEMS];

extern u16 pending_item_interaction; // The user has interacted with an item

void init_item(u16 nitem, const SpriteDefinition *spritedef, u8 npal, u16 x_in_background, u8 y, u16 collision_width, u16 collision_x_offset, u16 collision_height, u16 collision_y_offset, u8 check_depth); // Initialize an item
void release_item(u16 nitem); // Release an item
void display_item_if_visible(u16 nitem); // Hide or display an item depending if the X coordinate is visible in the screen
void check_items_visibility(void); // Check visibility of every item in screen
u16 detect_nearby_item(); // Detect if the active character would collide with an object in a nearby position

#endif

================
File: src/patterns/pattern_thunder.h
================
#ifndef PATTERN_THUNDER_H
#define PATTERN_THUNDER_H

#include "globals.h"

// Launch the spell
void playerThunderLaunch(void);

// Update the ongoing spell.
// Returns true when the effect is finished.
bool playerThunderUpdate(void);

// Check if the pattern can be used
bool playerThunderCanUse(void);

#endif // PATTERN_THUNDER_H

================
File: src/sound.h
================
#ifndef _SOUNDS_H_
#define _SOUNDS_H_

#define XGM_VERSION 2 // XGM or XGM2 sound driver

// VGM and WAV resources should be defined as XGM or XGM2 according to the driver version

void play_music(const u8 *music);
void fade_music(u16 numframes);
void play_sample(const u8 *sample, u32 len);

// Notes and patterns sound effects
void playPlayerNote(u8 nnote); // Play a note (player)
void playEnemyNote(u8 nnote); // Play a note (enemy)
void playPlayerPatternSound(u16 npattern); // Play the sound of a pattern spell (player)
void playEnemyPatternSound(u16 npattern); // Play the sound of a pattern spell (enemy)


#endif

================
File: res/res_backgrounds.res
================
# Act 1 - Scene 1 - Bedroom - Nightmare
TILESET bedroom_front_tile "Backgrounds/Act1/bedroom_bg_front.png" BEST
MAP bedroom_front_map "Backgrounds/Act1/bedroom_bg_front.png" bedroom_front_tile BEST
TILESET bedroom_bg_tile "Backgrounds/Act1/bedroom_bg_back.png" BEST
MAP bedroom_bg_map "Backgrounds/Act1/bedroom_bg_back.png" bedroom_bg_tile BEST
PALETTE bedroom_pal "Backgrounds/Act1/bedroom_daylight.pal"
PALETTE bedroom_night_pal "Backgrounds/Act1/bedroom_midnight.pal"

# OLD Act 1 - Scene 1 - Historians guild corridor
TILESET historians_corridor_front_tile "Backgrounds/Act1/historians_corridor_front.png" NONE 
MAP historians_corridor_front_map "Backgrounds/Act1/historians_corridor_front.png" historians_corridor_front_tile NONE 
PALETTE historians_corridor_pal "Backgrounds/Act1/historians_corridor_front.png"

# Act 1 - Scene 2 - Historians guild main room
TILESET historians_front_tile "Backgrounds/Act1/historians_bg_front.png" BEST
MAP historians_front_map "Backgrounds/Act1/historians_bg_front.png" historians_front_tile BEST
TILESET historians_bg_tile "Backgrounds/Act1/historians_bg_back.png" BEST
MAP historians_bg_map "Backgrounds/Act1/historians_bg_back.png" historians_bg_tile BEST
PALETTE historians_pal "Backgrounds/Act1/historians_bg_front.png"

# Act 1 - Scene 5 - Forest
TILESET forest_front_tile "Backgrounds/Act1/forest_bg_front.png" BEST
MAP forest_front_map "Backgrounds/Act1/forest_bg_front.png" forest_front_tile BEST
TILESET forest_bg_tile "Backgrounds/Act1/forest_bg_back.png" BEST
MAP forest_bg_map "Backgrounds/Act1/forest_bg_back.png" forest_bg_tile BEST
PALETTE forest_pal "Backgrounds/Act1/forest.pal"
PALETTE forest_dark_pal "Backgrounds/Act1/forest_dark.pal"

================
File: res/res_faces.res
================
# Backgrounds
SPRITE face_left_sprite "Sprites/Interface/face_left.png" 8 8 BEST
SPRITE face_right_sprite "Sprites/Interface/face_right.png" 8 8 BEST

# Character faces
SPRITE linus_face_sprite "Sprites/Faces/linus_face.png" 8 8 BEST
SPRITE clio_face_sprite "Sprites/Faces/clio_face.png" 8 8 BEST
SPRITE xander_face_sprite "Sprites/Faces/xander_face.png" 8 8 BEST
SPRITE swan_face_sprite "Sprites/Faces/swan_face.png" 8 8 BEST

================
File: res/res_interface.res
================
PALETTE interface_pal "Sprites/Interface/PAL.png"

# Pentagram
IMAGE int_pentagram_image "Sprites/Interface/pentagram.png"
SPRITE int_pentagram_1_sprite "Sprites/Interface/pentagram_1.png" 2 5 BEST 
SPRITE int_pentagram_2_sprite "Sprites/Interface/pentagram_2.png" 2 5 BEST 
SPRITE int_pentagram_3_sprite "Sprites/Interface/pentagram_3.png" 2 5 BEST 
SPRITE int_pentagram_4_sprite "Sprites/Interface/pentagram_4.png" 2 5 BEST 
SPRITE int_pentagram_5_sprite "Sprites/Interface/pentagram_5.png" 2 5 BEST 
SPRITE int_pentagram_6_sprite "Sprites/Interface/pentagram_6.png" 2 5 BEST 

# Rod
IMAGE int_rod_image "Sprites/Interface/rod.png" BEST
SPRITE int_rod_1_sprite "Sprites/Interface/rod_1.png" 2 1 BEST 
SPRITE int_rod_2_sprite "Sprites/Interface/rod_2.png" 2 1 BEST 
SPRITE int_rod_3_sprite "Sprites/Interface/rod_3.png" 2 1 BEST 
SPRITE int_rod_4_sprite "Sprites/Interface/rod_4.png" 2 1 BEST 
SPRITE int_rod_5_sprite "Sprites/Interface/rod_5.png" 2 1 BEST 
SPRITE int_rod_6_sprite "Sprites/Interface/rod_6.png" 2 1 BEST 
SPRITE int_enemy_rod_1_sprite "Sprites/Interface/enemy_rod_1.png" 2 1 BEST 
SPRITE int_enemy_rod_2_sprite "Sprites/Interface/enemy_rod_2.png" 2 1 BEST 
SPRITE int_enemy_rod_3_sprite "Sprites/Interface/enemy_rod_3.png" 2 1 BEST 
SPRITE int_enemy_rod_4_sprite "Sprites/Interface/enemy_rod_4.png" 2 1 BEST 
SPRITE int_enemy_rod_5_sprite "Sprites/Interface/enemy_rod_5.png" 2 1 BEST 
SPRITE int_enemy_rod_6_sprite "Sprites/Interface/enemy_rod_6.png" 2 1 BEST 

# Pattern icons
SPRITE int_pattern_thunder "Sprites/Interface/pattern_thunder.png" 4 4 BEST
SPRITE int_pattern_hide "Sprites/Interface/pattern_hide.png" 4 4 BEST
SPRITE int_pattern_open "Sprites/Interface/pattern_open.png" 4 4 BEST 
SPRITE int_pattern_sleep "Sprites/Interface/pattern_sleep.png" 4 4 BEST 

# Others
SPRITE int_life_counter_sprite "Sprites/Interface/life_counter.png" 4 1 BEST 
SPRITE int_button_A_sprite "Sprites/Interface/button_A.png" 2 2 BEST 10
SPRITE int_magin_anim_sprite "Sprites/Interface/magic_anim.png" 20 1 BEST 10
IMAGE int_screen_limit "Sprites/Interface/screen_limit.png" BEST

================
File: res/Sprites/Characters/characters.pal
================
JASC-PAL
0100
16
230 0 164 0
172 172 172 255
222 161 90 255
255 255 255 255
171 116 81 255
205 80 65 255
86 23 23 255
102 59 48 255
230 194 164 255
234 233 18 255
13 154 163 255
161 16 16 255
87 87 87 255
0 0 0 255
18 103 111 255
255 0 230 255

================
File: src/background.c
================
#include "globals.h"

Map *background_BGA;              // Foreground layer tilemap
Map *background_BGB;              // Background layer tilemap
u32 offset_BGA;                   // Foreground scroll offset
u32 offset_BGB;                   // Background scroll offset
u8 background_scroll_mode;        // Current scrolling behavior mode
u8 scroll_speed;                  // Parallax scroll speed divider
bool player_scroll_active;        // Whether player can trigger scrolling
u16 background_width;             // Total width of background in pixels
u16 x_limit_min;                  // Minimum X position for movement
u16 x_limit_max;                  // Maximum X position for movement
u16 y_limit_min;                  // Minimum Y position for movement
u16 y_limit_max;                  // Maximum Y position for movement

void update_bg(bool player_moved)    // Update background scroll positions based on movement
{
    // Front background layer
    if (player_moved) MAP_scrollTo(background_BGA, offset_BGA, 0); // Scroll background A
    
    // Back background layer
    if (background_BGB!=NULL) {
        if (background_scroll_mode==BG_SCRL_USER_LEFT || background_scroll_mode==BG_SCRL_USER_RIGHT) {
            if (player_moved) {
                offset_BGB = offset_BGA >> scroll_speed; // Scroll by user movement
                MAP_scrollTo(background_BGB, offset_BGB, 0); // Scroll background B
            }
        }
        else { // Auto scroll
            if (background_scroll_mode==BG_SCRL_AUTO_LEFT) offset_BGB++;
            else offset_BGB--;
            MAP_scrollTo(background_BGB, offset_BGB >> scroll_speed, 0); // Scroll background B
        }
    }
}

void set_limits(u16 x_min, u16 y_min, u16 x_max, u16 y_max)    // Set movement boundary limits for characters
{
    x_limit_min=x_min;
    y_limit_min=y_min;
    x_limit_max=x_max;
    y_limit_max=y_max;
}

void scroll_background(s16 dx)    // Handle background scrolling when character reaches screen edge
{
    if (player_scroll_active) { // Can player scroll?
        if (background_scroll_mode == BG_SCRL_USER_RIGHT || background_scroll_mode == BG_SCRL_USER_LEFT) { // Scrolling mode is user dependant ?
            if (offset_BGA+dx>0 && ((s16) offset_BGA+dx)<((s16) background_width-SCREEN_WIDTH)) { // New scroll offset is inside background width boundries?
                offset_BGA+=dx; // Change offste
                update_bg(true);
                // Move following characters to the left
                for (u16 nchar=0; nchar<MAX_CHR; nchar ++) {
                    if (obj_character[nchar].follows_character==true) {
                        if (obj_character[nchar].x>-20) {
                            obj_character[nchar].x-=dx;
                            update_character(nchar);
                        }
                    }
                }
            }
        }
    }
}

u16 get_x_in_screen(u16 x_in_background, u8 width)    // Convert background X coordinate to screen space
{
    s16 x_in_screen = x_in_background - offset_BGA;
    
    // Allow sprite to be partially visible at screen edges
    // A sprite should be visible if any part of it is on screen
    if (x_in_screen < -(s16)width || x_in_screen >= SCREEN_WIDTH) {
        return X_OUT_OF_BOUNDS;
    }
    
    return (u16)x_in_screen;
}

================
File: src/collisions.c
================
#include "globals.h"

u8 num_colls;    // Counter to prevent infinite collision loops

u16 char_distance(u16 char1, s16 x1, u8 y1, u16 char2)    // Calculate Manhattan distance between character collision boxes
{
    // Calculate char1's collision box boundaries
    s16 char1_left = x1 + obj_character[char1].collision_x_offset;
    s16 char1_right = char1_left + obj_character[char1].collision_width;
    s16 char1_top = y1 + obj_character[char1].collision_y_offset;
    s16 char1_bottom = char1_top + obj_character[char1].collision_height;

    // Calculate char2's collision box boundaries
    s16 char2_left = obj_character[char2].x + obj_character[char2].collision_x_offset;
    s16 char2_right = char2_left + obj_character[char2].collision_width;
    s16 char2_top = obj_character[char2].y + obj_character[char2].collision_y_offset;
    s16 char2_bottom = char2_top + obj_character[char2].collision_height;

    // Find closest x point on char2's box to char1's box
    s16 closest_x;
    if (char1_right < char2_left) closest_x = char2_left;
    else if (char1_left > char2_right) closest_x = char2_right;
    else closest_x = (char1_left + char1_right) / 2; // If boxes overlap in x, use midpoint

    // Find closest y point on char2's box to char1's box
    s16 closest_y;
    if (char1_bottom < char2_top) closest_y = char2_top;
    else if (char1_top > char2_bottom) closest_y = char2_bottom;
    else closest_y = (char1_top + char1_bottom) / 2; // If boxes overlap in y, use midpoint

    // If boxes overlap completely, return 0
    if (char1_left < char2_right && char1_right > char2_left &&
        char1_top < char2_bottom && char1_bottom > char2_top) {
        return 0;
    }

    // Calculate Manhattan distance to closest point
    return abs((char1_left + char1_right) / 2 - closest_x) + 
           abs((char1_top + char1_bottom) / 2 - closest_y);
}

u16 item_distance(u16 nitem, u16 x, u8 y)    // Calculate Manhattan distance from point to item collision box
{
    // Calculate item's collision box boundaries
    s16 item_left = obj_item[nitem].entity.x + obj_item[nitem].entity.collision_x_offset;
    s16 item_right = item_left + obj_item[nitem].entity.collision_width;
    s16 item_top = obj_item[nitem].entity.y + obj_item[nitem].entity.collision_y_offset;
    s16 item_bottom = item_top + obj_item[nitem].entity.collision_height;
    
    // Find closest x point on box
    s16 closest_x;
    if (x < item_left) closest_x = item_left;
    else if (x > item_right) closest_x = item_right;
    else closest_x = x;

    // Find closest y point on box
    s16 closest_y;
    if (y < item_top) closest_y = item_top;
    else if (y > item_bottom) closest_y = item_bottom;
    else closest_y = y;

    // If point is inside box, return 0
    if (x >= item_left && x <= item_right && y >= item_top && y <= item_bottom) {
        return 0;
    }

    // Calculate Manhattan distance to closest point
    return abs(x - closest_x) + abs(y - closest_y);
}

u16 detect_char_char_collision(u16 nchar, u16 x, u8 y)    // Check for collisions between character and other characters
{
    u16 other_char;

    if (obj_character[nchar].active == true) {
        // Compute character collision box
        u16 char_col_x1, char_col_x2;
        if (obj_character[nchar].flipH) {
            char_col_x1 = x + obj_character[nchar].x_size - obj_character[nchar].collision_x_offset - obj_character[nchar].collision_width;
            char_col_x2 = char_col_x1 + obj_character[nchar].collision_width;
        } else {
            char_col_x1 = x + obj_character[nchar].collision_x_offset;
            char_col_x2 = char_col_x1 + obj_character[nchar].collision_width;
        }
        u8 char_col_y1 = y + obj_character[nchar].collision_y_offset;
        u8 char_col_y2 = char_col_y1 + obj_character[nchar].collision_height;

        // Check collision with each active character (except itself)
        for (other_char = 0; other_char < MAX_CHR; other_char++) {
            if (other_char != nchar && obj_character[other_char].active == true) {
                // Compute other character collision box
                u16 other_col_x1, other_col_x2;
                if (obj_character[other_char].flipH) {
                    other_col_x1 = obj_character[other_char].x + obj_character[other_char].x_size - obj_character[other_char].collision_x_offset - obj_character[other_char].collision_width;
                    other_col_x2 = other_col_x1 + obj_character[other_char].collision_width;
                } else {
                    other_col_x1 = obj_character[other_char].x + obj_character[other_char].collision_x_offset;
                    other_col_x2 = other_col_x1 + obj_character[other_char].collision_width;
                }
                u8 other_col_y1 = obj_character[other_char].y + obj_character[other_char].collision_y_offset;
                u8 other_col_y2 = other_col_y1 + obj_character[other_char].collision_height;

                // Check if collision boxes overlap
                if (char_col_x1 < other_col_x2 &&
                    char_col_x2 > other_col_x1 &&
                    char_col_y1 < other_col_y2 &&
                    char_col_y2 > other_col_y1) {
                    if (num_colls < MAX_COLLISIONS) { // Prevent character from being trapped
                        num_colls++;
                        return other_char;
                    } else {
                        num_colls = 0;
                        return CHR_NONE;
                    }
                }
            }
        }
    }
    
    // No collision detected
    return CHR_NONE;
}

u16 detect_char_item_collision(u16 nchar, u16 x, u8 y)    // Check for collisions between character and items
{
    u16 nitem;
    s16 char_left, char_right, char_top, char_bottom;
    s16 item_left, item_right, item_top, item_bottom;

    // Calculate character's bounding box
    char_left = x + obj_character[nchar].collision_x_offset;
    char_right = char_left + obj_character[nchar].collision_width;
    char_top = y + obj_character[nchar].collision_y_offset;
    char_bottom = char_top + obj_character[nchar].collision_height;
    //dprintf(2,"CAJA PERSONAJE: (%d,%d)-(%d,%d)",char_left,char_top,char_right,char_bottom);

    for (nitem = 0; nitem < MAX_ITEMS; nitem++)
    {
        if (obj_item[nitem].entity.active && obj_item[nitem].entity.visible)
        {
            //dprintf(2,"Detectando colisión con %d", nitem);
            // Calculate item's bounding box
            item_left = obj_item[nitem].entity.x + obj_item[nitem].entity.collision_x_offset;
            item_right = item_left + obj_item[nitem].entity.collision_width;
            item_top = obj_item[nitem].entity.y + obj_item[nitem].entity.collision_y_offset;
            item_bottom = item_top + obj_item[nitem].entity.collision_height;
            //dprintf(2,"DATOS OBJETO: (x,y)=(%d,%d), offset(x,y)=(%d,%d), tam(x,y)=(%d,%d)",obj_item[nitem].entity.x,obj_item[nitem].entity.y,obj_item[nitem].entity.collision_x_offset,obj_item[nitem].entity.collision_y_offset,obj_item[nitem].entity.collision_width,obj_item[nitem].entity.collision_height);
            //dprintf(2,"CAJA OBJETO: (%d,%d)-(%d,%d)",item_left,item_top,item_right,item_bottom);

            // Check for collision
            if (char_left < item_right && char_right > item_left &&
                char_top < item_bottom && char_bottom > item_top)
            {
                //dprintf(2," *** COLISION ***");
                return nitem; // Return the index of the collided item
            }
        }
    }

    return ITEM_NONE; // No collision detected
}

u16 detect_char_enemy_collision(u16 nchar, u16 x, u8 y)    // Check for collisions between character and enemies
{
    u16 nenemy;

    if (obj_character[nchar].active == true) {
        // Compute character collision box
        u16 char_col_x1, char_col_x2;
        if (obj_character[nchar].flipH) {
            char_col_x1 = x + obj_character[nchar].x_size - obj_character[nchar].collision_x_offset - obj_character[nchar].collision_width;
            char_col_x2 = char_col_x1 + obj_character[nchar].collision_width;
        } else {
            char_col_x1 = x + obj_character[nchar].collision_x_offset;
            char_col_x2 = char_col_x1 + obj_character[nchar].collision_width;
        }
        u8 char_col_y1 = y + obj_character[nchar].collision_y_offset;
        u8 char_col_y2 = char_col_y1 + obj_character[nchar].collision_height;

        // Check collision with each active enemy
        for (nenemy = 0; nenemy < MAX_ENEMIES; nenemy++) {
            if (obj_enemy[nenemy].obj_character.active == true) {
                // Compute enemy collision box
                u16 enemy_col_x1, enemy_col_x2;
                if (obj_enemy[nenemy].obj_character.flipH) {
                    enemy_col_x1 = obj_enemy[nenemy].obj_character.x + obj_enemy[nenemy].obj_character.x_size - obj_enemy[nenemy].obj_character.collision_x_offset - obj_enemy[nenemy].obj_character.collision_width;
                    enemy_col_x2 = enemy_col_x1 + obj_enemy[nenemy].obj_character.collision_width;
                } else {
                    enemy_col_x1 = obj_enemy[nenemy].obj_character.x + obj_enemy[nenemy].obj_character.collision_x_offset;
                    enemy_col_x2 = enemy_col_x1 + obj_enemy[nenemy].obj_character.collision_width;
                }
                u8 enemy_col_y1 = obj_enemy[nenemy].obj_character.y + obj_enemy[nenemy].obj_character.collision_y_offset;
                u8 enemy_col_y2 = enemy_col_y1 + obj_enemy[nenemy].obj_character.collision_height;

                // Check if collision boxes overlap
                if (char_col_x1 < enemy_col_x2 &&
                    char_col_x2 > enemy_col_x1 &&
                    char_col_y1 < enemy_col_y2 &&
                    char_col_y2 > enemy_col_y1) {
                    if (num_colls<MAX_COLLISIONS) { // Prevent player from being trapped by limiting consecutive collisions
                        num_colls++;
                        return nenemy;
                    } else {
                        num_colls=0;
                        return ENEMY_NONE;
                    }
                }
            }
        }
    }
    
    // No collision detected
    return ENEMY_NONE;
}

u16 detect_enemy_char_collision(u16 nenemy, u16 x, u8 y)    // Check for collisions between enemy and characters
{
    u16 nchar;

    if (obj_enemy[nenemy].obj_character.active == true) {
        // Compute enemy collision box
        u16 enemy_col_x1, enemy_col_x2;
        if (obj_enemy[nenemy].obj_character.flipH) {
            enemy_col_x1 = x + obj_enemy[nenemy].obj_character.x_size - obj_enemy[nenemy].obj_character.collision_x_offset - obj_enemy[nenemy].obj_character.collision_width;
            enemy_col_x2 = enemy_col_x1 + obj_enemy[nenemy].obj_character.collision_width;
        } else {
            enemy_col_x1 = x + obj_enemy[nenemy].obj_character.collision_x_offset;
            enemy_col_x2 = enemy_col_x1 + obj_enemy[nenemy].obj_character.collision_width;
        }
        u8 enemy_col_y1 = y + obj_enemy[nenemy].obj_character.collision_y_offset;
        u8 enemy_col_y2 = enemy_col_y1 + obj_enemy[nenemy].obj_character.collision_height;

        // Check collision with each active character
        for (nchar = 0; nchar < MAX_CHR; nchar++) {
            if (obj_character[nchar].active == true) {
                // Compute character collision box
                u16 char_col_x1, char_col_x2;
                if (obj_character[nchar].flipH) {
                    char_col_x1 = obj_character[nchar].x + obj_character[nchar].x_size - obj_character[nchar].collision_x_offset - obj_character[nchar].collision_width;
                    char_col_x2 = char_col_x1 + obj_character[nchar].collision_width;
                } else {
                    char_col_x1 = obj_character[nchar].x + obj_character[nchar].collision_x_offset;
                    char_col_x2 = char_col_x1 + obj_character[nchar].collision_width;
                }
                u8 char_col_y1 = obj_character[nchar].y + obj_character[nchar].collision_y_offset;
                u8 char_col_y2 = char_col_y1 + obj_character[nchar].collision_height;

                // Check if collision boxes overlap
                if (enemy_col_x1 < char_col_x2 &&
                    enemy_col_x2 > char_col_x1 &&
                    enemy_col_y1 < char_col_y2 &&
                    enemy_col_y2 > char_col_y1) {
                    return nchar;
                }
            }
        }
    }
    
    // No collision detected
    return CHR_NONE;
}

================
File: src/entity.c
================
#include "globals.h"

bool movement_active;    // Whether entity movement is currently allowed

void move_entity(Entity *entity, Sprite *sprite, s16 newx, s16 newy)    // Move entity to new position with smooth animation and shadow updates
{
    u16 nchar=CHR_NONE;
    u16 nenemy = ENEMY_NONE;

    newy-=entity->y_size; // Now all calculations are relative to the bottom line, not the upper one
    
    s16 x = entity->x;
    s16 y = entity->y;
    s16 dx = newx - x;
    s16 dy = newy - y;
    s16 sx = dx > 0 ? 1 : -1;
    s16 sy = dy > 0 ? 1 : -1;
    s16 err = (abs(dx) > abs(dy) ? abs(dx) : -abs(dy)) / 2;
    s16 e2;
    bool old_movement_active=movement_active;


    // Check if this entity is a character so we can update its shadow
    for (u16 i = 0; i < MAX_CHR; i++) {
        if (&obj_character[i] == entity) {
            nchar = i;
            break;
        }
    }

    // Check if this entity is an enemy so we can update its shadow
    for (u16 i = 0; i < MAX_ENEMIES; i++) {
        if (&obj_enemy[i].obj_character == entity) {
            nenemy = i;
            break;
        }
    }

    movement_active=false; // Player can't move while an entity is moving
    for(;;)
    {
        SPR_setPosition(sprite, x, y);
        if (nchar != CHR_NONE) update_character_shadow(nchar);
        if (nenemy != ENEMY_NONE) update_enemy_shadow(nenemy);
        entity->x = x;
        entity->y = y;
        next_frame(false);

        if (x == newx && y == newy) break;

        e2 = err;
        if (e2 > -abs(dx)) { err -= abs(dy); x += sx; }
        if (e2 < abs(dy)) { err += abs(dx); y += sy; }
    }
    movement_active=old_movement_active;
}

================
File: src/intro.c
================
#include "globals.h"

/**
 * @brief Displays and handles the game's intro sequence
 * 
 * Shows the game logo with animated stars in the background, allows language selection,
 * and waits for player input to proceed. Handles all resource loading/unloading and
 * transitions including music and palette fades.
 */
void theweave_intro(void)
{
    Sprite *star[MAXSTARS];
    u8 nstar,x,y;
    bool exit_menu=false;
    
    initialize(false);

    PAL_setPalette(PAL0, geesebumps_pal_black.data, DMA);
    PAL_setPalette(PAL1, geesebumps_pal_black.data, DMA);

    // Initialize stars
    for (nstar=0;nstar<MAXSTARS;nstar++) {
        x=random()%320;
        y=random()%224;
        star[nstar]=SPR_addSpriteSafe(&intro_stars_sprite, x, y, TILE_ATTR(PAL1, false, false, false));
        SPR_setAnimAndFrame(star[nstar],random()%3,random()%8);
    }

    // Game Logo
    VDP_drawImageEx(BG_A, &intro_logo_bg, TILE_ATTR_FULL(PAL0, true, false, false, tile_ind), 0, 0, false, true);
    tile_ind+=intro_logo_bg.tileset->numTile;

    // Version number
    VDP_drawTextBG(BG_A, GAMEVERSION, 40-strlen(GAMEVERSION), 0);

    // Fade from black
    PAL_fade(0, 15, geesebumps_pal_black.data, intro_logo_bg.palette->data, SCREEN_FPS*2, false);
    PAL_fade(16, 31, geesebumps_pal_black.data, intro_stars_sprite.palette->data, SCREEN_FPS/2, false);

    // Disable star loops
    for (nstar=0;nstar<MAXSTARS;nstar++) SPR_setAnimationLoop(star[nstar],false);

    // Background music
    play_music(music_intro);

    game_language=LANG_ENGLISH;    
    intro_update_language();
    while (!exit_menu) {
        for (nstar=0;nstar<MAXSTARS;nstar++) {
            if (SPR_isAnimationDone(star[nstar])) {
                x=random()%320;
                y=random()%224;
                SPR_setPosition(star[nstar],x,y);
                SPR_setAnimAndFrame(star[nstar],random()%3,0);
            }
        }
        exit_menu=intro_read_keys();
        SPR_update();
        SYS_doVBlankProcess();
    }

    // Fade out music and graphics
    VDP_clearTextLineBG(WINDOW,22);
    VDP_clearTextLineBG(WINDOW,23);
    fade_music(SCREEN_FPS*2);
    PAL_fadeOutAll(SCREEN_FPS*2, true);
    waitMs(2000);

    // Release everything
    SPR_reset();
    VDP_releaseAllSprites();
    VDP_clearPlane(BG_A, true);
    tile_ind-=intro_logo_bg.tileset->numTile;   
}

/**
 * @brief Updates the language selection display in the intro screen
 * 
 * Clears and redraws the language options (English/Spanish) text,
 * highlighting the currently selected language with brackets.
 */
void intro_update_language(void)
{
    char eng_text[40];
    char spa_text[40];
    
    VDP_clearTextLineBG(WINDOW,22);
    VDP_clearTextLineBG(WINDOW,24);

    if (game_language == LANG_ENGLISH) {
        strcpy(eng_text, "} English {");
        strcpy(spa_text, "Espa^ol");
    } else {
        strcpy(eng_text, "English");
        strcpy(spa_text, "} Espa^ol {");
    }

    VDP_drawTextBG(WINDOW, eng_text, (40 - strlen(eng_text)) >> 1, 22);
    VDP_drawTextBG(WINDOW, spa_text, (40 - strlen(spa_text)) >> 1, 24);
}

/**
 * @brief Handles player input during the intro sequence
 * 
 * Processes directional inputs to switch language selection and
 * A/Start buttons to confirm and exit the intro sequence.
 * 
 * @return true if player pressed A/Start to exit intro, false otherwise
 */
bool intro_read_keys(void)
{
    u16 joy_state;

    joy_state=JOY_readJoypad (JOY_ALL);

    switch (joy_state)
    {
        case BUTTON_LEFT:
        case BUTTON_RIGHT:
        case BUTTON_UP:
        case BUTTON_DOWN:
            while (JOY_readJoypad(JOY_ALL)!=0) SYS_doVBlankProcess();
            if (game_language==LANG_ENGLISH) game_language=LANG_SPANISH;
            else game_language=LANG_ENGLISH;
            intro_update_language();
            break;
        case BUTTON_A:
        case BUTTON_START:
            return true;    
        default:
            return false;
    }
    return false;
}

================
File: src/sound.c
================
#include "globals.h"

void play_music(const u8 *music)    // Start playing background music track using XGM1/XGM2 driver
{
    if (XGM_VERSION==2) XGM2_play(music);
    else XGM_startPlay(music);
}

void fade_music(u16 numframes)    // Fade out current music over specified number of frames (XGM2 only)
{
    if (XGM_VERSION==2) XGM2_fadeOutAndStop(numframes);
    else {} // Fade out not supported in XGM1
}

void play_sample(const u8 *sample, u32 len)    // Play sound effect sample using available PCM channel
{
    if (XGM_VERSION==2) XGM2_playPCM(sample, len, SOUND_PCM_CH_AUTO);
    else {
        XGM_setPCM(1, sample, len);
        XGM_startPlayPCM(1, 1, SOUND_PCM_CH2);
    }
}


// ------------------------------------------------------------------
// Player note (simple pitch table)
// ------------------------------------------------------------------
void playPlayerNote(u8 noteCode)
{
    const u8 *sample = NULL;

    switch (noteCode)
    {
        case NOTE_MI:  sample = snd_note_mi;  break;
        case NOTE_FA:  sample = snd_note_fa;  break;
        case NOTE_SOL: sample = snd_note_sol; break;
        case NOTE_LA:  sample = snd_note_la;  break;
        case NOTE_SI:  sample = snd_note_si;  break;
        case NOTE_DO:  sample = snd_note_do;  break;
        default: return;
    }

    play_music(sample);
}

// ------------------------------------------------------------------
// Enemy note
// ------------------------------------------------------------------
void playEnemyNote(u8 noteCode)
{
    const u8 *sample = NULL;

    switch (noteCode)
    {
        case NOTE_MI:  sample = snd_enemy_note_mi;  break;
        case NOTE_FA:  sample = snd_enemy_note_fa;  break;
        case NOTE_SOL: sample = snd_enemy_note_sol; break;
        case NOTE_LA:  sample = snd_enemy_note_la;  break;
        case NOTE_SI:  sample = snd_enemy_note_si;  break;
        case NOTE_DO:  sample = snd_enemy_note_do;  break;
        default: return;
    }

    play_music(sample);
}


// ------------------------------------------------------------------
// Spell jingle (player side)
// ------------------------------------------------------------------
void playPlayerPatternSound(u16 patternId)
{
    switch (patternId)
    {
        case PATTERN_THUNDER:
            // PENDING - playSample(snd_pattern_electric, sizeof(...));
            break;
        case PATTERN_HIDE:
            // PENDING
            break;
        case PATTERN_OPEN:
            // PENDING
            break;
        case PATTERN_SLEEP:
            // PENDING
            break;           
        default:
            // PENDING - play error jingle
            break;
    }
}

// ------------------------------------------------------------------
// Spell jingle (enemy side)
// ------------------------------------------------------------------
void playEnemyPatternSound(u16 patternId)
{
    switch (patternId)
    {
        case PATTERN_EN_THUNDER:
            // PENDING
            break;
        case PATTERN_EN_BITE:
            // PENDING
            break;
        default:
            // PENDING
            break;
    }
}

================
File: res/res_items.res
================
# Act 1 - Scene 1 (bedroom)
SPRITE item_bedroom_linus_sleeping "Sprites/Items/Act1/bedroom_linus_sleeping.png" 10 3 BEST
SPRITE item_bedroom_bed "Sprites/Items/Act1/bedroom_bed.png" 12 4 BEST
SPRITE item_bedroom_chair "Sprites/Items/Act1/bedroom_chair.png" 4 6 BEST
SPRITE item_bedroom_windowsill "Sprites/Items/Act1/bedroom_windowsill.png" 13 3 BEST
SPRITE item_bedroom_cabinet "Sprites/Items/Act1/bedroom_cabinet.png" 7 11 BEST

# Act 1 - Scene 2 (corridor)
SPRITE item_corridor_bookpedestal_sprite "Sprites/Items/Act1/book_in_pedestal.png" 6 8 BEST

# Act 1 - Scene 5 (forest)
SPRITE item_forest_fg1_sprite "Sprites/Items/Act1/forest_fgsprite1.png" 4 2 BEST 
SPRITE item_forest_fg2_sprite "Sprites/Items/Act1/forest_fgsprite2.png" 6 3 BEST 
SPRITE item_forest_fg3_sprite "Sprites/Items/Act1/forest_fgsprite3.png" 6 2 BEST 
SPRITE item_forest_fg4_sprite "Sprites/Items/Act1/forest_fgsprite4.png" 6 9 BEST 
SPRITE item_forest_fg5_sprite "Sprites/Items/Act1/forest_fgsprite5.png" 4 22 BEST

================
File: src/combat.c
================
#include "globals.h"

CombatState combat_state; // Current combat state
CombatContext combatContext; // Combat context

================
File: src/patterns.c
================
// patterns.c  – static pattern system

#include "globals.h"

bool player_has_rod;          /* can physically use patterns?      */
bool player_patterns_enabled; /* not silenced by a cut-scene, etc. */
u16 current_note_ticks;   /* lifetime of the single note sprite  */
u8  current_note;         /* NOTE_MI … NOTE_DO or NOTE_NONE      */
u8  noteQueue[4] = {NOTE_NONE,NOTE_NONE,NOTE_NONE,NOTE_NONE}; // Queue of notes played by the player (up to 4)

// --------------------------------------------------------------------
// Static player-pattern table
// --------------------------------------------------------------------

PlayerPattern playerPatterns[MAX_PLAYER_PATTERNS];
EnemyPattern enemyPatterns[MAX_ENEMIES][MAX_PATTERN_ENEMY];

// ---------------------------------------------------------------------
// Local helpers
// ---------------------------------------------------------------------
static inline PlayerPattern* getPlayerPattern(u16 id)
{
    return (id < PATTERN_PLAYER_COUNT) ? &playerPatterns[id] : NULL;
}

static inline EnemyPattern* getEnemyPattern(u8 slot, u8 pslot)
{
    return (slot < MAX_ENEMIES && pslot < MAX_PATTERN_ENEMY)
           ? &enemyPatterns[slot][pslot]
           : NULL;
}

static inline bool playerPatternEnabled(u16 id)
{
    PlayerPattern* p = getPlayerPattern(id);
    dprintf(2,"Checking player pattern %d: enabled=%d, canUse=%p", id, p ? p->enabled : 0, p ? p->canUse : NULL);
    return p && p->enabled && (!p->canUse || p->canUse());
}

// Devuelve true si el patrón del enemigo está habilitado y sin cooldown
static inline bool enemyPatternReady(u8 slot, u8 pslot)
{
    EnemyPattern* p = getEnemyPattern(slot, pslot);
    return p && p->enabled && (p->rechargeFrames == 0);
}


// ---------------------------------------------------------------------
// Player-side: Initialisation
// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// initPlayerPatterns  –  set up the 4 default spells (thunder, hide,
//                        open, sleep) according to the new system.
// ---------------------------------------------------------------------
void initPlayerPatterns(void)
{
    dprintf(2,"Initializing player patterns");

    // 0) Limpia todos los slots
    for (u8 i = 0; i < MAX_PLAYER_PATTERNS; ++i)
    {
        playerPatterns[i] = (PlayerPattern){
            .id       = PATTERN_PLAYER_NONE,
            .enabled  = false,
            .notes    = { NOTE_NONE, NOTE_NONE, NOTE_NONE, NOTE_NONE },
            .baseDuration = 0,
            .canUse   = NULL,
            .launch   = NULL,
            .update   = NULL,
            .icon     = NULL
        };
    }

    // 1) Electric
    playerPatterns[PATTERN_THUNDER] = (PlayerPattern){
        .id       = PATTERN_THUNDER,
        .enabled  = true,
        .notes    = { NOTE_MI, NOTE_FA, NOTE_SOL, NOTE_LA }, // 1-2-3-4
        .baseDuration = 60,
        .canUse   = playerThunderCanUse,
        .launch   = playerThunderLaunch,
        .update   = playerThunderUpdate,
        .icon     = NULL // Will load on demand
   };

    // 2) Hide
    playerPatterns[PATTERN_HIDE] = (PlayerPattern){
        .id       = PATTERN_HIDE,
        .enabled  = true,
        .notes    = { NOTE_FA, NOTE_SI, NOTE_SOL, NOTE_DO }, // 2-5-3-6
        .baseDuration = 90,
        .canUse   = playerHideCanUse,
        .launch   = playerHideLaunch,
        .update   = playerHideUpdate,
        .icon     = NULL // Will load on demand
    };

    // 3) Open
    playerPatterns[PATTERN_OPEN] = (PlayerPattern){
        .id       = PATTERN_OPEN,
        .enabled  = true,
        .notes    = { NOTE_FA, NOTE_SOL, NOTE_SOL, NOTE_FA }, // 2-3-3-2
        .baseDuration = 45,
        .canUse   = playerOpenCanUse,
        .launch   = playerOpenLaunch,
        .update   = playerOpenUpdate,
        .icon     = NULL // Will load on demand
    };

    // 4) Sleep
    playerPatterns[PATTERN_SLEEP] = (PlayerPattern){
        .id       = PATTERN_SLEEP,
        .enabled  = true,
        .notes    = { NOTE_FA, NOTE_MI, NOTE_DO, NOTE_LA }, // 2-1-6-4
        .baseDuration = 75,
        .canUse   = playerSleepCanUse,
        .launch   = playerSleepLaunch,
        .update   = playerSleepUpdate,
        .icon     = NULL // Will load on demand
    };

    dprintf(2,"Player patterns ready: E=%d H=%d O=%d S=%d",
            playerPatterns[PATTERN_THUNDER].enabled,
            playerPatterns[PATTERN_HIDE].enabled,
            playerPatterns[PATTERN_OPEN].enabled,
            playerPatterns[PATTERN_SLEEP].enabled);
}


// ---------------------------------------------------------------------
// Player-side: Spell activation (unlock new pattern)
// ---------------------------------------------------------------------
void activate_spell(u16 patternId)
{
    PlayerPattern* p = getPlayerPattern(patternId);
    if (!p || p->enabled) return;            // already unlocked

    // simple feedback: play jingle & flash icon
    playPlayerPatternSound(patternId);       // sound layer only

    // PENDING - showPatternUnlockIcon(patternId);

    p->enabled = true;
}

// ---------------------------------------------------------------------
// Player-side: launch / update
// ---------------------------------------------------------------------
void launchPlayerPattern(u16 patternId)
{
    PlayerPattern* p = getPlayerPattern(patternId);
    if (!p || !p->enabled || (p->canUse && !p->canUse()))
        return;

    combatContext.activePattern = patternId;
    combatContext.effectTimer   = 0;
    combat_state                = COMBAT_STATE_PLAYER_EFFECT;

    if (p->launch) p->launch();
}

bool updatePlayerPattern(void)
{
    if (combat_state != COMBAT_STATE_PLAYER_EFFECT)
        return true;                       // nothing to do

    PlayerPattern* p = getPlayerPattern(combatContext.activePattern);
    if (!p) return true;                   // safety

    // If there's no update callback, we finish immediately
    bool finished = (p->update)
                  ? p->update()
                  : true;

    if (finished) {
        combat_state = COMBAT_STATE_ENEMY_PLAYING;  // or next phase
        return true;
    }
    return false;
}

// ---------------------------------------------------------------------
// Player-side: note input
// ---------------------------------------------------------------------

// Player presses a note (called from input layer)
bool patternPlayerAddNote(u8 noteCode)
{
    if (noteCode < NOTE_MI || noteCode > NOTE_DO) return false;

    // Reject if the last note was too recent
    if (combatContext.noteTimer < MIN_TIME_BETWEEN_NOTES) {
        dprintf(3, "Note %d ignored (debounce)\n", noteCode);
        return false;
    }

    // Reject if the player is already playing a note
    if (current_note != NOTE_NONE) {
        dprintf(3,"Note %d ignored: previous still playing\n", noteCode);
        return false;
    }

    // Restart note timer
    combatContext.noteTimer   = 0;

    // Store into queue
    u8 idx = combatContext.playerNotes;
    if (idx > 3) idx = 3;
    noteQueue[idx] = noteCode;
    combatContext.playerNotes = idx + 1;

    // HUD + Sound
    show_note(noteCode, true);
    current_note       = noteCode;
    current_note_ticks = 0;
    playPlayerNote(noteCode);

    dprintf(2,"Note %d queued at pos %d\n", noteCode, idx);

    // If 4 notes reached → validate pattern
    if (combatContext.playerNotes == 4) {
            bool rev;
            u16 id = validatePattern(noteQueue, &rev);

            dprintf(2,"Pattern validation: id=%d, rev=%d, enabled=%d", id, rev, playerPatternEnabled(id));

            if (id != PATTERN_PLAYER_NONE && playerPatternEnabled(id))
            {
                dprintf(1,"Pattern %d recognised (rev=%d)\n", id, rev);
                reset_note_queue(); // Clear queue
                combatContext.patternReversed = rev;
                launchPlayerPattern(id); // Launch the pattern
            }
            else
            {
                dprintf(1,"Invalid pattern, queue cleared\n");
                reset_note_queue(); // Just flush notes
                play_sample(snd_pattern_invalid, sizeof(snd_pattern_invalid)); // play invalid sound
            }
        }

    return true;
}

// Reset the note queue and player notes count
void reset_note_queue(void)
{
    for (u8 i=0;i<4;i++) noteQueue[i] = NOTE_NONE;
    combatContext.playerNotes = 0;
}

// ---------------------------------------------------------------------
// Enemy-side: Initialisation
// ---------------------------------------------------------------------
/*  Rellena la tabla de un enemigo concreto.
 *  Llama a esta función justo al entrar en combate
 *  para cada enemigo activo.                                       */
void initEnemyPatterns(u8 enemyId)
{
    /* --- THUNDER / ELECTRIC  (slot 0) --------------------------- */
    enemyPatterns[enemyId][0] = (EnemyPattern){
        .id             = PATTERN_EN_THUNDER,
        .noteCount      = 0,
        .baseDuration   = SCREEN_FPS, 
        .rechargeFrames = SCREEN_FPS*3,
        .enabled        = TRUE,
        .launch         = enemyThunderLaunch,
        .update         = enemyThunderUpdate,
        .counterable    = TRUE,
        .onCounter      = enemyThunderOnCounter
    };

    /* --- BITE  (slot 1) ----------------------------------------- */
    enemyPatterns[enemyId][1] = (EnemyPattern){
        .id             = PATTERN_EN_BITE,
        .noteCount      = 0,
        .baseDuration   = SCREEN_FPS,
        .rechargeFrames = SCREEN_FPS*2,
        .enabled        = TRUE,
        .launch         = enemyBiteLaunch,
        .update         = enemyBiteUpdate,
        .counterable    = FALSE,
        .onCounter      = NULL
    };
}


// ---------------------------------------------------------------------
// Enemy-side: launch / update
// ---------------------------------------------------------------------
void launchEnemyPattern(u8 enemySlot, u16 patternSlot)
{
    EnemyPattern* pat = getEnemyPattern(enemySlot, patternSlot);
    if (!pat || !pat->enabled) return;

    combatContext.activePattern = pat->id;
    combatContext.effectTimer   = 0;
    combatContext.activeEnemy   = enemySlot;
    combat_state                = COMBAT_STATE_ENEMY_EFFECT;

    if (pat->launch) pat->launch(enemySlot);

    // start cooldown
    pat->rechargeFrames = pat->baseDuration;   // or any value you prefer
}

bool updateEnemyPattern(u8 enemySlot)
{
    if (combat_state != COMBAT_STATE_ENEMY_EFFECT ||
        combatContext.activeEnemy != enemySlot)
        return true;

    // Locate the pattern inside the enemy slot
    for (u8 pslot = 0; pslot < MAX_PATTERN_ENEMY; ++pslot)
    {
        EnemyPattern* pat = &enemyPatterns[enemySlot][pslot];
        if (pat->id == combatContext.activePattern)
        {
            // Tick cooldown if >0
            if (pat->rechargeFrames) --pat->rechargeFrames;

            bool finished = (pat->update)
                          ? pat->update(enemySlot)
                          : true;

            if (finished) {
                combat_state = COMBAT_STATE_PLAYER_PLAYING;
                return true;
            }
            return false;
        }
    }
    return true; // pattern not found → treat as finished
}

// ---------------------------------------------------------------------
// Enemy-side: note input
// ---------------------------------------------------------------------
void patternEnemyAddNote(u8 enemySlot, u8 noteCode)
{
    if (noteCode < NOTE_MI || noteCode > NOTE_DO) return;

    combatContext.noteTimer  = 0;
    combatContext.enemyNotes = (combatContext.enemyNotes < 4)
                             ? combatContext.enemyNotes + 1
                             : 4;

    playEnemyNote(noteCode);

    // PENDING - display HUD icon for enemy's note
}

// ---------------------------------------------------------------------
// Validate 4-note sequence (returns PATTERN_PLAYER_NONE if invalid)
// ---------------------------------------------------------------------
u16 validatePattern(const u8 notes[4], bool* reversed)
{
    for (u8 i = 0; i < PATTERN_PLAYER_COUNT; ++i)
    {
        PlayerPattern* p = &playerPatterns[i];
        dprintf(2,"Validating pattern %d. Queue: %d %d %d %d - Pattern: %d %d %d %d", i, notes[0], notes[1], notes[2], notes[3], p->notes[0], p->notes[1], p->notes[2], p->notes[3]);

        // direct order
        if (notes[0]==p->notes[0] && notes[1]==p->notes[1] &&
            notes[2]==p->notes[2] && notes[3]==p->notes[3])
        {
            dprintf(2,"Pattern %d recognised (direct order)", p->id);
            if (reversed) *reversed = false;
            return p->id;
        }

        // reversed order
        if (notes[0]==p->notes[3] && notes[1]==p->notes[2] &&
            notes[2]==p->notes[1] && notes[3]==p->notes[0])
        {
            dprintf(2,"Pattern %d recognised (reversed order)", p->id);
            if (reversed) *reversed = true;
            return p->id;
        }
    }
    if (reversed) *reversed = false;
    return PATTERN_PLAYER_NONE;
}

================
File: res/resources.h
================
#include <genesis.h>

#ifndef _RES_RESOURCES_H_
#define _RES_RESOURCES_H_

extern const Image font;

#endif // _RES_RESOURCES_H_

================
File: src/controller.c
================
#include "globals.h"

void joy_check(void)    // Process joystick input each frame for movement, actions, and pause
{
    static u16 frame_counter = 0;
    frame_counter++;
    
    // Read the current state of the joystick
    u16 joy_value = JOY_readJoypad(JOY_ALL);

    // Only process movement and action buttons if movement is allowed
    if (movement_active) {
        if (obj_character[active_character].state == STATE_IDLE ||
            obj_character[active_character].state == STATE_WALKING ||
        (obj_character[active_character].state == STATE_PATTERN_EFFECT &&
            combatContext.activePattern == PATTERN_HIDE))
        {
            dprintf(3,"Handling movement");
            handle_movement(joy_value);
        }
        
        // Always check action buttons, even during pattern effects
        dprintf(3,"Handling action buttons");
        handle_action_buttons(joy_value);
    }

    // Always check for pause button, regardless of game state
    handle_pause_button(joy_value);
}

void handle_movement(u16 joy_value)    // Process directional inputs and update character movement state
{
    bool moved = false;
    s16 dx = 0, dy = 0;

    // Check for left/right movement
    if (joy_value & BUTTON_LEFT) {
        dx = -1;
    } else if (joy_value & BUTTON_RIGHT) {
        dx = 1;
    }

    // Check for up/down movement
    if (joy_value & BUTTON_UP) {
        dy = -1;
    } else if (joy_value & BUTTON_DOWN) {
        dy = 1;
    }

    // If any direction button was pressed, attempt to move the character
    if (dx != 0 || dy != 0) {
        handle_character_movement(dx, dy);
        moved = true;
    }

    // Update the character's state and animation based on movement
    if (moved) {
        // Don't change state if we're in PATTERN_EFFECT with HIDE
        if (!(obj_character[active_character].state == STATE_PATTERN_EFFECT && combatContext.activePattern == PATTERN_HIDE)) {
            obj_character[active_character].state = STATE_WALKING;
        }
    } else if (obj_character[active_character].state == STATE_WALKING) {
        obj_character[active_character].state = STATE_IDLE;
    }
    update_character_animation();
}

void handle_character_movement(s16 dx, s16 dy)    // Update character position with collision and screen boundary checks
{
    // dx Horizontal movement (-1 for left, 1 for right, 0 for no horizontal movement)
    // dy Vertical movement (-1 for up, 1 for down, 0 for no vertical movement)

    s16 current_x = obj_character[active_character].x;
    s16 current_y = obj_character[active_character].y;
    s16 new_x = current_x + dx;
    s16 new_y = current_y + dy;
    u8 player_y_size = obj_character[active_character].y_size;
    bool direction_changed = false;

    // Check if we're changing horizontal direction
    if (dx != 0) {
        direction_changed = ((dx < 0 && !obj_character[active_character].flipH) ||
                           (dx > 0 && obj_character[active_character].flipH));
    }

    // Check for collision at new position
    if ((detect_char_enemy_collision(active_character, new_x, new_y) != ENEMY_NONE) ||
        (detect_char_item_collision(active_character, new_x, new_y) != ITEM_NONE) ||
        (detect_char_char_collision(active_character, new_x, new_y) != CHR_NONE)) {
        
        num_colls = 0; // Reset collision counter
        
        // If changing direction, try moving in new direction
        // If not changing direction, try moving in opposite direction
        s16 move_dx = direction_changed ? dx : -dx;
        s16 move_dy = direction_changed ? dy : -dy;
        s16 test_x = direction_changed ? current_x : new_x;
        s16 test_y = direction_changed ? current_y : new_y;

        // Move pixel by pixel until no collision or MAX_COLLISIONS reached
        while ((detect_char_enemy_collision(active_character, test_x, test_y) != ENEMY_NONE ||
               detect_char_item_collision(active_character, test_x, test_y) != ITEM_NONE ||
               detect_char_char_collision(active_character, test_x, test_y) != CHR_NONE) &&
               num_colls < MAX_COLLISIONS) {
            
            test_x += move_dx;
            test_y += move_dy;
            num_colls++;

            // Stay within screen boundaries
            if (test_x < x_limit_min || test_x > x_limit_max ||
                test_y + player_y_size < y_limit_min || test_y + player_y_size > y_limit_max) {
                break;
            }
        }

        // Update new position to where we found no collision
        new_x = test_x;
        new_y = test_y;
    }

    bool position_updated = false;

    // Handle horizontal movement
    if (dx != 0) {
        if ((background_scroll_mode == BG_SCRL_USER_RIGHT || background_scroll_mode == BG_SCRL_USER_LEFT) &&
            (new_x < x_limit_min || new_x > x_limit_max)) {
            // Player is trying to move outside screen boundaries, and scroll mode is user dependent
            scroll_background(dx); // Try to scroll
            position_updated = true;
        }
        else if (new_x >= x_limit_min && new_x <= x_limit_max) {
            // Update character position and flip state
            obj_character[active_character].x = new_x;
            if (direction_changed) {
                obj_character[active_character].flipH = (dx < 0); // Only update flip if direction changed
            }
            position_updated = true;
        }
    }

    // Handle vertical movement
    if (dy != 0 && new_y + player_y_size >= y_limit_min && new_y + player_y_size <= y_limit_max) {
        obj_character[active_character].y = new_y;
        position_updated = true;
    }

    // Update character sprite position if any movement occurred
    if (position_updated) {
        update_character(active_character);
    }
}

void update_character_animation(void)    // Set appropriate animation based on character state
{
    // Don't change animation if we're in PATTERN_EFFECT with HIDE
    if (obj_character[active_character].state == STATE_PATTERN_EFFECT && combatContext.activePattern == PATTERN_HIDE) {
        return;
    }

    switch (obj_character[active_character].state) {
        case STATE_WALKING:
            if (obj_character[active_character].animation != ANIM_WALK) {
                obj_character[active_character].animation = ANIM_WALK;
                update_character(active_character);
            }
            break;
        case STATE_IDLE:
            if (obj_character[active_character].animation != ANIM_IDLE) {
                anim_character(active_character, ANIM_IDLE);
            }
            break;
        case STATE_PLAYING_NOTE:
            if (obj_character[active_character].animation != ANIM_ACTION) {
                anim_character(active_character, ANIM_ACTION);
            }
            break;
        case STATE_PATTERN_EFFECT:
            if (obj_character[active_character].animation != ANIM_MAGIC) {
                anim_character(active_character, ANIM_MAGIC);
            }
            break;
        case STATE_PATTERN_EFFECT_FINISH:
            if (obj_character[active_character].animation != ANIM_IDLE) {
                anim_character(active_character, ANIM_IDLE);
            }
            obj_character[active_character].state = STATE_IDLE;
            break;
        default:
            break;
    }
}

void handle_action_buttons(u16 joy_value)    // Process action buttons for item interaction and musical notes
{
    // Only allow item interaction and note playing in IDLE or WALKING states
    if (obj_character[active_character].state != STATE_IDLE &&
        obj_character[active_character].state != STATE_WALKING) {
            dprintf(2,"  - Skipping action buttons: character state is %d", obj_character[active_character].state);
        return;
    }

    if (movement_active) {
        if (joy_value & BUTTON_A) { // Detect if the player is interacting with an item
            u16 nitem=detect_nearby_item();
            if (nitem!=ITEM_NONE) {
                dprintf(2,"  - Player pressed A, interacting with item %d", nitem);
                pending_item_interaction=nitem;
                // Don't return here, continue to process note playing
            }
        }
    }

    // Process musical notes if player patterns are enabled and ther's not an active pattern launched
    if (player_patterns_enabled &&
        combatContext.state != COMBAT_STATE_PLAYER_PLAYING &&
        combatContext.state != COMBAT_STATE_PLAYER_EFFECT)
    {
        dprintf(3,"  - Checking buttons. Player pressed action button(s): joy_value=0x%04X", joy_value);
        if (joy_value & BUTTON_A) { patternPlayerAddNote(NOTE_MI);  }
        if (joy_value & BUTTON_B) { patternPlayerAddNote(NOTE_FA);  }
        if (joy_value & BUTTON_C) { patternPlayerAddNote(NOTE_SOL); }
        if (joy_value & BUTTON_X) { patternPlayerAddNote(NOTE_LA);  }
        if (joy_value & BUTTON_Y) { patternPlayerAddNote(NOTE_SI);  }
        if (joy_value & BUTTON_Z) { patternPlayerAddNote(NOTE_DO);  }
    }
}

void handle_pause_button(u16 joy_value)    // Handle START button press to show pause screen
{
    if (joy_value & BUTTON_START) {
        // Wait for the START button to be released
        while (joy_value & BUTTON_START) {
            joy_value = JOY_readJoypad(JOY_ALL);
            SYS_doVBlankProcess();
        }
        pause_screen(); // Call the pause screen function
    }
}

================
File: add_texts_comments.py
================
import os, re, sys  


def show_help():  
    print("""  
Add dialog text comments to C source files  

Usage:  
    python add_texts_comments.py <file>  
    python add_texts_comments.py *  

This script reads the dialog texts from texts.c (and mappings from texts.h) and adds comments to talk_dialog() and choice_dialog() calls.  
""")  


def read_mappings(texts_h_file):  
    dialogs = {0: "SYSTEM_DIALOG"}  # Default value  
    choices = {}  
    with open(texts_h_file, 'r', encoding='utf-8') as f:  
        for line in f:  
            dmatch = re.match(r'^\s*#define\s+(\w+)_DIALOG(\d+)\s+(\d+)', line)  
            cmatch = re.match(r'^\s*#define\s+(\w+)_CHOICE(\d+)\s+(\d+)', line)  
            if dmatch:  
                act = dmatch.group(1)  
                num = dmatch.group(2)  
                id_ = int(dmatch.group(3))  
                dialogs[id_] = f"{act}_DIALOG{num}"  
            elif cmatch:  
                act = cmatch.group(1)  
                num = cmatch.group(2)  
                id_ = int(cmatch.group(3))  
                choices[id_] = f"{act}_CHOICE{num}"  
    return dialogs, choices  


def extract_items(block_content):  
    items = []  
    brace_count = 0  
    start = None  
    for i, ch in enumerate(block_content):  
        if ch == '{':  
            if brace_count == 0:  
                start = i  
            brace_count += 1  
        elif ch == '}':  
            brace_count -= 1  
            if brace_count == 0 and start is not None:  
                item = block_content[start:i+1]  
                if "NULL" not in item:  # Ignore terminator  
                    items.append(item)  
                start = None  
    return items  


def parse_dialog_item(item):  
    m = re.search(r'\{\s*"([^"]+)"\s*,\s*"([^"]+)"\s*\}', item, re.DOTALL)  
    if m:  
        return {"es": m.group(1).strip(), "en": m.group(2).strip()}  
    return None  


def parse_choice_item(item):  
    count_match = re.search(r'FACE_[^,]+,\s*[^,]+,\s*[^,]+,\s*(\d+),', item)  
    if not count_match:  
        return []  
    num_options = int(count_match.group(1))  
    arrays_match = re.search(r'\{\s*\{(.*?)\}\s*,\s*\{(.*?)\}\s*\}', item, re.DOTALL)  
    if not arrays_match:  
        return []  
    es_text = arrays_match.group(1)  
    en_text = arrays_match.group(2)  
    es_options = re.findall(r'"([^"]*?)"', es_text)[:num_options]  
    en_options = re.findall(r'"([^"]*?)"', en_text)[:num_options]  
    return [{"es": es.strip(), "en": en.strip()} for es, en in zip(es_options, en_options)]  


def parse_texts_c(texts_c_file):  
    dialog_texts = {}  
    choice_texts = {}  
    with open(texts_c_file, 'r', encoding='utf-8') as f:  
        content = f.read()  
    dialog_blocks = re.finditer(r'const\s+DialogItem\s+(\w+_dialog\d*)\[\]\s*=\s*{(.*?)};', content, re.DOTALL)  
    for block in dialog_blocks:  
        block_name = block.group(1)  
        items = extract_items(block.group(2))  
        texts = []  
        for item in items:  
            res = parse_dialog_item(item)  
            if res:  
                texts.append(res)  
        dialog_texts[block_name.upper()] = texts  
    choice_blocks = re.finditer(r'const\s+ChoiceItem\s+(\w+_choice\d+)\[\]\s*=\s*{(.*?)};', content, re.DOTALL)  
    for block in choice_blocks:  
        block_name = block.group(1)  
        items = extract_items(block.group(2))  
        texts = []  
        for item in items:  
            opts = parse_choice_item(item)  
            texts.append(opts)  
        choice_texts[block_name.upper()] = texts  
    return dialog_texts, choice_texts  

def update_source_file(c_file, dialogs_map, choices_map, dialog_texts, choice_texts):  
    modified = False  
    with open(c_file, 'r', encoding='utf-8') as f:  
        lines = f.readlines()  

    new_lines = []  
    talk_re = re.compile(r'(\s*)(.*?)(talk_dialog\s*\(\s*&dialogs\[(\w+)_DIALOG(?:\d+)?\]\[(\d+)\]\s*\);)(.*)?$')  
    choice_re = re.compile(r'(\s*)(.*?)(choice_dialog\s*\(\s*&choices\[(\w+)_CHOICE(\d+)\]\[(\d+)\]\s*\);)(.*)?$')  

    for line in lines:  
        l = line.rstrip('\n')  

        m = talk_re.search(l)  
        if m:  
            indent, before, call, act, idx, existing_comment = m.group(1), m.group(2), m.group(3), m.group(4), int(m.group(5)), m.group(6) or ""  
            key = "SYSTEM_DIALOG" if act.upper() == "SYSTEM" else None  
            if not key:  
                dnum_match = re.search(r'_DIALOG(\d+)', call)  
                if dnum_match:  
                    key = f"{act}_DIALOG{dnum_match.group(1)}".upper()  
            texts = dialog_texts.get(key, [])  
            if idx < len(texts):  
                comment = f' // (ES) "{texts[idx]["es"]}" - (EN) "{texts[idx]["en"]}"'  
                l = f"{indent}{before}{call}{comment}"  
                modified = True  

        else:  
            m = choice_re.search(l)  
            if m:  
                indent, before, call, act, choice_num, idx, existing_comment = m.group(1), m.group(2), m.group(3), m.group(4), m.group(5), int(m.group(6)), m.group(7) or ""  
                key = f"{act}_CHOICE{choice_num}".upper()  
                opts = choice_texts.get(key, [])  
                if idx < len(opts):  
                    options = opts[idx]  
                    options_text = ', '.join([f'(ES) "{o["es"]}" - (EN) "{o["en"]}"' for o in options])  
                    comment = f' // {options_text}'  
                    l = f"{indent}{before}{call}{comment}"  
                    modified = True  

        new_lines.append(l + "\n")  

    with open(c_file, 'w', encoding='utf-8', newline='') as f:  
        f.writelines(new_lines)  

    if modified:  
        print(f"Successfully updated comments in {c_file}")  
    else:  
        print(f"No comments were modified in {c_file}")  


def process_file(c_file):  
    texts_h_file = "src/texts.h"  
    texts_c_file = "src/texts.c"  
    print(f"Processing file: {c_file}")  
    dialogs_map, choices_map = read_mappings(texts_h_file)  
    dialog_texts, choice_texts = parse_texts_c(texts_c_file)  
    update_source_file(c_file, dialogs_map, choices_map, dialog_texts, choice_texts)  


def process_all_files():
    for root, _, files in os.walk("src"):
        for file in files:
            if file.endswith(".c") and file != "texts.c":
                c_file = os.path.join(root, file)
                process_file(c_file)


def main():  
    if len(sys.argv) < 2:  
        show_help()  
        return  
    if sys.argv[1] == "*":  
        process_all_files()  
    else:  
        c_file = sys.argv[1]  
        if not c_file.startswith("src/"):  
            c_file = os.path.join("src", c_file)  
        if not os.path.exists(c_file):  
            print(f"Error: File {c_file} not found")  
            return  
        process_file(c_file)  


if __name__ == "__main__":  
    main()

================
File: res/res_enemies.h
================
#include <genesis.h>

#ifndef _RES_RES_ENEMIES_H_
#define _RES_RES_ENEMIES_H_

extern const SpriteDefinition weaver_ghost_sprite;
extern const SpriteDefinition weaver_ghost_sprite_face;
extern const SpriteDefinition three_head_monkey_sprite;
extern const SpriteDefinition three_head_monkey_sprite_face;
extern const SpriteDefinition three_head_monkey_sprite_shadow;

#endif // _RES_RES_ENEMIES_H_

================
File: src/enemies.h
================
#ifndef _ENEMIES_H_
#define _ENEMIES_H_

// Game constants
#define ENEMY_ENTITY_ID_BASE 100

// Enemies
#define MAX_ENEMIES 3
#define ENEMY_NONE 254
#define MAX_PATTERN_ENEMY 2

// Enemy classes
#define MAX_ENEMY_CLASSES 10
#define ENEMY_CLS_WEAVERGHOST    0
#define ENEMY_CLS_3HEADMONKEY  1

// Enemy modes
typedef enum {
    ENEMY_MODE_IDLE,        /* doing nothing */
    ENEMY_MODE_PLAY_NOTE,   /* playing the 4 pre-spell notes */
    ENEMY_MODE_CASTING,     /* spell effect is currently running */
    ENEMY_MODE_COOLDOWN     /* post-spell recovery */
} EnemyMode;

// Enemy classes
typedef struct
{
    u16 max_hitpoints;
    bool follows_character; // If true, the enemy will follow the character
    u8 follow_speed;
    bool has_pattern[MAX_PATTERN_ENEMY]; // If true, the enemy has a particular pattern
} Enemy_Class;
extern Enemy_Class obj_enemy_class[MAX_ENEMY_CLASSES]; // Enemy class object

// Enemies
typedef struct
{
    Enemy_Class class;
    u16 class_id;
    Entity obj_character;
    u16 hitpoints;
    u16 last_pattern_time[MAX_PATTERN_ENEMY]; // Last time a particular pattern was used (in frames)
    EnemyMode mode; // What's the enemy doing?
    u16 modeTimer; // Timer for the current mode (in frames)
} Enemy;


extern Enemy obj_enemy[MAX_ENEMIES]; // Enemy object
extern Sprite *spr_enemy[MAX_ENEMIES]; // Enemy sprites
extern Sprite *spr_enemy_face[MAX_ENEMIES]; // Enemy faces sprites
extern Sprite *spr_enemy_shadow[MAX_ENEMIES]; // Enemy shadows sprites


/* --- Init / cleanup --- */
void init_enemy_classes(void);
void init_enemy(u16 numenemy, u16 class_id);
void release_enemy(u16 nenemy);

/* --- Runtime updates --- */
void update_enemy_shadow(u16 nenemy);
void update_enemy(u16 nenemy);
void show_enemy(u16 nenemy, bool show);
void anim_enemy(u16 nenemy, u8 newanimation);
void look_enemy_left(u16 nenemy, bool direction_right);
void move_enemy(u16 nenemy, s16 newx, s16 newy);
void move_enemy_instant(u16 nenemy, s16 x, s16 y);

/* --- AI movement --- */
void approach_enemies(void);

#endif

================
File: src/patterns.h
================
#ifndef PATTERNS_H
#define PATTERNS_H

#include "globals.h"

// Include all patern headers
#include "patterns/pattern_open.h"
#include "patterns/pattern_hide.h"
#include "patterns/pattern_sleep.h"
#include "patterns/pattern_thunder.h"
#include "patterns/pattern_en_thunder.h"
#include "patterns/pattern_en_bite.h"

/* Max */
#define MAX_PLAYER_PATTERNS   6   /* maximum slots for player spells     */
#define MAX_ENEMY_PATTERNS    8   /* maximum slots for enemy spells      */

/* Player patterns  */
#define PATTERN_THUNDER   0
#define PATTERN_HIDE       1
#define PATTERN_OPEN       2
#define PATTERN_SLEEP      3
#define PATTERN_PLAYER_COUNT 4
#define PATTERN_PLAYER_NONE   254

/* Enemy patterns */
#define PATTERN_EN_THUNDER   0
#define PATTERN_EN_BITE       1

#define PATTERN_ENEMY_COUNT   2
#define PATTERN_ENEMY_NONE    254

// Notes
#define NOTE_NONE 0
#define NOTE_MI   1
#define NOTE_FA   2
#define NOTE_SOL  3
#define NOTE_LA   4
#define NOTE_SI   5
#define NOTE_DO   6

// Timing and delays
#define MAX_NOTE_PLAYING_TIME  500  // Note playing time in milliseconds
#define MAX_PATTERN_WAIT_TIME 2000   // Time to wait for a next note before cancelling the pattern in milliseconds
#define MIN_TIME_BETWEEN_NOTES 10     // Minimum ticks between consecutive notes to prevent too rapid input

// Globals
extern bool player_has_rod;          /* can physically use patterns?      */
extern bool player_patterns_enabled; /* not silenced by a cut-scene, etc. */
extern u16 current_note_ticks;   /* lifetime of the single note sprite  */
extern u8  current_note;         /* NOTE_MI … NOTE_DO or NOTE_NONE      */
extern u8  noteQueue[4];    // Queue of notes played by the player (up to 4)

typedef struct
{
    /* identity & availability */
    u16  id;      // PATTERN_...                       
    bool enabled; // true if available for the character
    u8   notes[4]; // notes in the pattern (always 4)
    u16  baseDuration; // duration of the effect (in frames)

    /* callbacks */
    bool (*canUse)(void); // can the player use this pattern?
    void (*launch)(void); // called when the pattern is launched
    bool (*update)(void); // called every frame (true = finished)

    Sprite* icon; // HUD / menu icon (nullable)
} PlayerPattern;

typedef struct
{
    u16  id;  // PATTERN_EN_...
    u8   noteCount; // number of notes in the pattern

    /* timing */
    u16  baseDuration;   // frames the effect lasts
    u16  rechargeFrames;   // frames before the pattern can be used again

    bool enabled; // true if available for the enemy

    /* callbacks */
    void (*launch)(u8 enemyId); // called when the pattern is launched
    bool (*update)(u8 enemyId); // called every frame (true = finished)

    /* counter-spell support */
    bool counterable; // can the player counter this pattern?
    void (*onCounter)(u8 enemyId); // NULL if not counterable
} EnemyPattern;

/* -------------------------------------------------------------------
 * Static tables
 * ------------------------------------------------------------------*/
extern PlayerPattern playerPatterns[MAX_PLAYER_PATTERNS];
extern EnemyPattern  enemyPatterns[MAX_ENEMIES][MAX_PATTERN_ENEMY];

// Initialization
void initPlayerPatterns(void);              // Initialize graphics, sounds and pattern data

// Player side
void launchPlayerPattern(u16 patternId);    // Activate pattern
bool updatePlayerPattern(void);             // Called every frame (true = finished)
void activate_spell(u16 npattern);          // Play spell animation and sound
bool patternPlayerAddNote(u8 noteCode);     // player presses a note
void reset_note_queue(void);                // Reset the note queue and player notes count

// Enemy side
void launchEnemyPattern(u8 enemySlot, u16 patternSlot);
bool updateEnemyPattern(u8 enemySlot);      // Called every frame (true = finished)
void patternEnemyAddNote(u8 enemySlot, u8 noteCode); // enemy plays a note

// Note validation
u16 validatePattern(const u8 notes[4], bool* reversed); // Returns PATTERN_PLAYER_NONE if invalid

#endif // PATTERNS_H

================
File: res/res_faces.h
================
#include <genesis.h>

#ifndef _RES_RES_FACES_H_
#define _RES_RES_FACES_H_

extern const SpriteDefinition face_left_sprite;
extern const SpriteDefinition face_right_sprite;
extern const SpriteDefinition linus_face_sprite;
extern const SpriteDefinition clio_face_sprite;
extern const SpriteDefinition xander_face_sprite;
extern const SpriteDefinition swan_face_sprite;

#endif // _RES_RES_FACES_H_

================
File: res/res_geesebumps.h
================
#include <genesis.h>

#ifndef _RES_RES_GEESEBUMPS_H_
#define _RES_RES_GEESEBUMPS_H_

extern const u8 music_geesebumps[1024];
extern const Palette geesebumps_pal_black;
extern const Palette geesebumps_pal_white;
extern const Palette geesebumps_pal_white2;
extern const Palette geesebumps_pal_lines;
extern const Image geesebumps_logo_bg;
extern const SpriteDefinition geesebumps_logo_text;
extern const SpriteDefinition geesebumps_logo_line1;
extern const SpriteDefinition geesebumps_logo_line2;

#endif // _RES_RES_GEESEBUMPS_H_

================
File: res/res_intro.h
================
#include <genesis.h>

#ifndef _RES_RES_INTRO_H_
#define _RES_RES_INTRO_H_

extern const u8 music_intro[1536];
extern const Image intro_logo_bg;
extern const SpriteDefinition intro_stars_sprite;

#endif // _RES_RES_INTRO_H_

================
File: res/res_sound.h
================
#include <genesis.h>

#ifndef _RES_RES_SOUND_H_
#define _RES_RES_SOUND_H_

extern const u8 snd_pattern_thunder[60672];
extern const u8 snd_pattern_hide[32768];
extern const u8 snd_pattern_open[11264];
extern const u8 snd_pattern_invalid[6912];
extern const u8 snd_player_hurt[5120];
extern const u8 snd_player_hit_enemy[15360];
extern const u8 snd_effect_magic_appear[90368];
extern const u8 snd_effect_magic_disappear[90368];
extern const u8 snd_note_mi[1024];
extern const u8 snd_note_fa[1024];
extern const u8 snd_note_sol[1024];
extern const u8 snd_note_la[1024];
extern const u8 snd_note_si[1024];
extern const u8 snd_note_do[1024];
extern const u8 snd_enemy_note_mi[1024];
extern const u8 snd_enemy_note_fa[1024];
extern const u8 snd_enemy_note_sol[1024];
extern const u8 snd_enemy_note_la[1024];
extern const u8 snd_enemy_note_si[1024];
extern const u8 snd_enemy_note_do[1024];

#endif // _RES_RES_SOUND_H_

================
File: src/enemies.c
================
#include "globals.h"

Enemy obj_enemy[MAX_ENEMIES];                    // Array of enemy instances with their properties
Sprite *spr_enemy[MAX_ENEMIES];                  // Array of enemy sprites
Sprite *spr_enemy_face[MAX_ENEMIES];             // Array of enemy face sprites for dialogs
Sprite *spr_enemy_shadow[MAX_ENEMIES];           // Array of enemy shadow sprites
Enemy_Class obj_enemy_class[MAX_ENEMY_CLASSES];  // Array of enemy class definitions

void update_enemy_shadow(u16 nenemy)    // Update shadow sprite position based on enemy position
{
    if (obj_enemy[nenemy].obj_character.drops_shadow && spr_enemy_shadow[nenemy] != NULL) {
        // Position shadow at the bottom of enemy's collision box
        s16 shadow_x = obj_enemy[nenemy].obj_character.x;
        s16 shadow_y = obj_enemy[nenemy].obj_character.y + obj_enemy[nenemy].obj_character.collision_y_offset - 4;
        
        // Flip shadow if enemy is looking to the left
        SPR_setHFlip(spr_enemy_shadow[nenemy], obj_enemy[nenemy].obj_character.flipH);

        // Set shadow position
        SPR_setPosition(spr_enemy_shadow[nenemy], shadow_x, shadow_y);
    }
}

void init_enemy_classes(void)    // Setup enemy class definitions with HP, patterns, and behavior
{
    obj_enemy_class[ENEMY_CLS_WEAVERGHOST]=(Enemy_Class) { 2, false, 0, {true, false}}; // 2 HP, can use electric pattern, don't follow
    obj_enemy_class[ENEMY_CLS_3HEADMONKEY]=(Enemy_Class) {3, true, 3, {false, true}}; // 3 HP, can use bite pattern, follows at speed 3
}


void init_enemy(u16 numenemy, u16 class)    // Create new enemy instance of given class with sprites and collision
{
    u16 i;
    u8 npal = PAL3;
    u8 x_size, y_size;
    u8 collision_x_offset=0,collision_y_offset=0,collision_width=0,collision_height=0;
    bool drops_shadow=true;
    const SpriteDefinition *nsprite = NULL;
    const SpriteDefinition *nsprite_face = NULL;
    const SpriteDefinition *nsprite_shadow = NULL;

    obj_enemy[numenemy].class_id=class;
    obj_enemy[numenemy].class=obj_enemy_class[class];
    obj_enemy[numenemy].hitpoints=obj_enemy_class[class].max_hitpoints;

    // Set specific attributes based on enemy class
    switch (class)
    {
    case ENEMY_CLS_WEAVERGHOST:
        nsprite = &weaver_ghost_sprite;
        nsprite_face = &weaver_ghost_sprite_face;
        nsprite_shadow = NULL;
        drops_shadow=false;
        break;
    case ENEMY_CLS_3HEADMONKEY:
        nsprite = &three_head_monkey_sprite;
        nsprite_face = &three_head_monkey_sprite_face;
        nsprite_shadow = &three_head_monkey_sprite_shadow;
        break;
    default:
        return;
    }
    
    // Get width and height from the sprite definition
    x_size = nsprite->w; 
    y_size = nsprite->h;
    // Set default collision box if not defined previously
    if (collision_width==0) collision_width=x_size/2; // Half width size
    if (collision_x_offset==0) collision_x_offset=x_size/4; // Centered in X
    if (collision_height==0) collision_height=2; // Two lines height
    if (collision_y_offset==0) collision_y_offset=y_size-1; // At the feet

    // Initialize enemy character with sprite, position, and collision attributes
    obj_enemy[numenemy].obj_character = (Entity) { 
        true, nsprite, nsprite_shadow, 0, 0, x_size, y_size, npal, false, false, 
        ANIM_IDLE, false, collision_x_offset, collision_y_offset, 
        collision_width, collision_height, STATE_IDLE, 
        obj_enemy_class[class].follows_character, obj_enemy_class[class].follow_speed,
        drops_shadow
    };

    // Add enemy sprite if not already present
    if (spr_enemy[numenemy]==NULL) spr_enemy[numenemy] = SPR_addSpriteSafe(nsprite, obj_enemy[numenemy].obj_character.x, obj_enemy[numenemy].obj_character.y, 
                                       TILE_ATTR(npal, obj_enemy[numenemy].obj_character.priority, false, obj_enemy[numenemy].obj_character.flipH));
    
    // Add enemy face sprite if not already present
    if (spr_enemy_face[numenemy]==NULL) spr_enemy_face[numenemy] = SPR_addSpriteSafe(nsprite_face, 198, 178, TILE_ATTR(npal, false, false, false));

    // Initialize shadow if enemy drops one
    if (obj_enemy[numenemy].obj_character.drops_shadow) {
        if (spr_enemy_shadow[numenemy] == NULL) {
            spr_enemy_shadow[numenemy] = SPR_addSpriteSafe(nsprite_shadow, 0, 0, TILE_ATTR(npal, TRUE, FALSE, FALSE));
        }
        if (spr_enemy_shadow[numenemy] != NULL) {
            SPR_setVisibility(spr_enemy_shadow[numenemy], HIDDEN);
            SPR_setDepth(spr_enemy_shadow[numenemy], SPR_MAX_DEPTH); // Shadow always at back
            update_enemy_shadow(numenemy);
        }
    }

    // Initially hide enemy sprites
    SPR_setVisibility(spr_enemy[numenemy], HIDDEN);
    SPR_setVisibility(spr_enemy_face[numenemy], HIDDEN);
    
    // Reset last pattern times
    //for (i=0;i<MAX_PATTERN_ENEMY;i++) obj_enemy[numenemy].last_pattern_time[i]=0;

    // Patterns and cooldowns
    // ****************** initEnemyPatterns(numenemy);

    for (i = 0; i < MAX_PATTERN_ENEMY; i++)
        obj_enemy[numenemy].last_pattern_time[i] = 0;
}

void release_enemy(u16 nenemy)    // Free enemy resources and reset related combat state
{

    /* If this enemy was the active one in combat, reset the state */
    if (combatContext.activeEnemy == nenemy) {
        combatContext.activeEnemy = ENEMY_NONE;
        combatContext.state       = COMBAT_STATE_IDLE;
        combatContext.effectTimer = 0;
    }

    /* Hide any note indicators (through interface) */
    for (u8 note = 0; note < 6; note++) {
        // ******************** show_enemy_note(note + 1, false, false);
    }

    /* Deactivate entity */
    obj_enemy[nenemy].obj_character.active = false;

    /* Release sprites */
    if (spr_enemy[nenemy] != NULL) {
        SPR_releaseSprite(spr_enemy[nenemy]);
        spr_enemy[nenemy] = NULL;
    }
    if (spr_enemy_face[nenemy] != NULL) {
        SPR_releaseSprite(spr_enemy_face[nenemy]);
        spr_enemy_face[nenemy] = NULL;
    }
    if (spr_enemy_shadow[nenemy] != NULL) {
        SPR_releaseSprite(spr_enemy_shadow[nenemy]);
        spr_enemy_shadow[nenemy] = NULL;
    }
}

void update_enemy(u16 nenemy)    // Update enemy sprite properties from current state
{
    SPR_setPosition(spr_enemy[nenemy], obj_enemy[nenemy].obj_character.x, obj_enemy[nenemy].obj_character.y);
    SPR_setPriority(spr_enemy[nenemy], obj_enemy[nenemy].obj_character.priority);
    SPR_setVisibility(spr_enemy[nenemy], obj_enemy[nenemy].obj_character.visible ? VISIBLE : HIDDEN);
    SPR_setHFlip(spr_enemy[nenemy], obj_enemy[nenemy].obj_character.flipH);
    SPR_setAnim(spr_enemy[nenemy], obj_enemy[nenemy].obj_character.animation);
    update_enemy_shadow(nenemy);
    SPR_update();
}

void show_enemy(u16 nenemy, bool show)    // Toggle visibility of enemy and its shadow
{
    obj_enemy[nenemy].obj_character.visible = show;
    SPR_setVisibility(spr_enemy[nenemy], show ? VISIBLE : HIDDEN);
    
    // Update shadow visibility if it exists
    if (obj_enemy[nenemy].obj_character.drops_shadow && spr_enemy_shadow[nenemy] != NULL) {
        SPR_setVisibility(spr_enemy_shadow[nenemy], show ? VISIBLE : HIDDEN);
    }
    
    SPR_update();
}

void anim_enemy(u16 nenemy, u8 newanimation)    // Set enemy animation if different from current
{
    dprintf(2,"Enemy %d animation %d\n", nenemy, newanimation);
    if (obj_enemy[nenemy].obj_character.animation != newanimation) {
        obj_enemy[nenemy].obj_character.animation = newanimation;
        SPR_setAnim(spr_enemy[nenemy], obj_enemy[nenemy].obj_character.animation);
    }
}

void look_enemy_left(u16 nenemy, bool direction_right)    // Set enemy sprite horizontal flip
{
    obj_enemy[nenemy].obj_character.flipH = direction_right;
    SPR_setHFlip(spr_enemy[nenemy], direction_right);
    update_enemy_shadow(nenemy);
    SPR_update();
}

void move_enemy(u16 nenemy, s16 newx, s16 newy)    // Move enemy with walking animation and direction update
{
    show_enemy(nenemy, true);
    anim_enemy(nenemy, ANIM_WALK);

    // Determine direction to face based on movement
    s16 dx = newx - obj_enemy[nenemy].obj_character.x;
    if (dx < 0) {
        look_enemy_left(nenemy, true); // Face left
    } else if (dx > 0) {
        look_enemy_left(nenemy, false); // Face right
    }

    move_entity(&obj_enemy[nenemy].obj_character, spr_enemy[nenemy], newx, newy);
    update_enemy_shadow(nenemy);

    anim_enemy(nenemy, ANIM_IDLE);
}

void move_enemy_instant(u16 nenemy, s16 x, s16 y)    // Set enemy position immediately without animation
{
    y-=obj_enemy[nenemy].obj_character.y_size; // Adjust y position relative to the bottom line

    SPR_setPosition(spr_enemy[nenemy], x, y);
    obj_enemy[nenemy].obj_character.x = x;
    obj_enemy[nenemy].obj_character.y = y;
    update_enemy_shadow(nenemy);
    next_frame(false);
}

void approach_enemies(void)    // Update enemy positions to follow player during combat
{
    u16 nenemy;
    s16 newx, newy;
    s16 dx, dy;
    u16 collision_result;
    bool has_moved;

    if (combatContext.state == COMBAT_STATE_IDLE && combatContext.activePattern != PATTERN_HIDE) { // Only move enemies during combat when the player is not hidden
        for (nenemy = 0; nenemy < MAX_ENEMIES; nenemy++) {
            has_moved=false;
            if (obj_enemy[nenemy].obj_character.follows_character == true) { // Check if this enemy type follows characters
                if (frame_counter%obj_enemy[nenemy].obj_character.follow_speed==0) { // Move at enemy's specific speed
                    // Calculate direction towards active character
                    dx = obj_character[active_character].x - obj_enemy[nenemy].obj_character.x;
                    dy = (obj_character[active_character].y + obj_character[active_character].y_size) - 
                        (obj_enemy[nenemy].obj_character.y + obj_enemy[nenemy].obj_character.y_size);

                    // Move by 1 pixel in the calculated direction
                    newx = obj_enemy[nenemy].obj_character.x + (dx != 0 ? (dx > 0 ? 1 : -1) : 0);
                    newy = obj_enemy[nenemy].obj_character.y + (dy != 0 ? (dy > 0 ? 1 : -1) : 0);

                    // Check for collision at new position
                    collision_result = detect_enemy_char_collision(nenemy, newx, newy);

                    // Move the enemy if there's no collision and it's not currently attacking
                    if (collision_result == CHR_NONE && combatContext.activeEnemy==ENEMY_NONE) {
                        obj_enemy[nenemy].obj_character.x = newx;
                        obj_enemy[nenemy].obj_character.y = newy;
                        obj_enemy[nenemy].obj_character.animation=ANIM_WALK;
                        obj_enemy[nenemy].obj_character.flipH=(dx<0);
                        update_enemy(nenemy);
                        has_moved=true;
                    }
                if (has_moved==false && combatContext.activeEnemy!=nenemy) anim_enemy(nenemy,ANIM_IDLE); // Set to idle if not moved and not attacking
                }
            }
        }
    }
}

================
File: res/res_backgrounds.h
================
#include <genesis.h>

#ifndef _RES_RES_BACKGROUNDS_H_
#define _RES_RES_BACKGROUNDS_H_

extern const TileSet bedroom_front_tile;
extern const MapDefinition bedroom_front_map;
extern const TileSet bedroom_bg_tile;
extern const MapDefinition bedroom_bg_map;
extern const Palette bedroom_pal;
extern const Palette bedroom_night_pal;
extern const TileSet historians_corridor_front_tile;
extern const MapDefinition historians_corridor_front_map;
extern const Palette historians_corridor_pal;
extern const TileSet historians_front_tile;
extern const MapDefinition historians_front_map;
extern const TileSet historians_bg_tile;
extern const MapDefinition historians_bg_map;
extern const Palette historians_pal;
extern const TileSet forest_front_tile;
extern const MapDefinition forest_front_map;
extern const TileSet forest_bg_tile;
extern const MapDefinition forest_bg_map;
extern const Palette forest_pal;
extern const Palette forest_dark_pal;

#endif // _RES_RES_BACKGROUNDS_H_

================
File: src/items.c
================
#include "globals.h"

Item obj_item[MAX_ITEMS];              // Array of game items with their properties
Sprite *spr_item[MAX_ITEMS];           // Array of item sprites
u16 pending_item_interaction;          // ID of item currently pending interaction

void init_item(u16 nitem, const SpriteDefinition *spritedef, u8 npal, u16 x_in_background, u8 y, u16 collision_width, u16 collision_x_offset, u16 collision_height, u16 collision_y_offset, u8 check_depth)    // Initialize item with sprite and collision properties
{
    u8 x_size, y_size;

    dprintf(2,"Initializing item %d\n", nitem);

    if (spritedef == NULL) {
        return;
    }

    // Width and height (from the sprite defition)
    x_size=spritedef->w;
    y_size=spritedef->h;

    // Collision box (if set to COLLISION_DEFAULT, use default values)
    if (collision_width==COLLISION_DEFAULT) collision_width=x_size/2; // Half width size
    if (collision_x_offset==COLLISION_DEFAULT) collision_x_offset=x_size/4; // Centered in X
    if (collision_height==COLLISION_DEFAULT) collision_height=2; // Two lines heght
    if (collision_y_offset==COLLISION_DEFAULT) collision_y_offset=y_size-1; // At the feet

    obj_item[nitem].x_in_background=x_in_background;
    obj_item[nitem].check_depth=check_depth;

    // We set X to 0, as we are gonna calc it later
    obj_item[nitem].entity = (Entity) { true, spritedef, NULL, 0, y, x_size, y_size, npal, false, false, ANIM_IDLE, true, collision_x_offset, collision_y_offset, collision_width, collision_height, STATE_IDLE, FALSE, 0, false };
    spr_item[nitem] = NULL;

    // Check visibility and load sprite if needed
    display_item_if_visible(nitem);
}

void release_item(u16 nitem)    // Free item resources and remove from game
{
    if (nitem >= MAX_ITEMS) {
        return;
    }
    
    // First hide sprite before releasing
    if (spr_item[nitem] != NULL) {
        SPR_setPosition(spr_item[nitem], -128, -128);
        SPR_setVisibility(spr_item[nitem], HIDDEN);
        SPR_update();  // Ensure sprite is moved before release
        SPR_releaseSprite(spr_item[nitem]);
        spr_item[nitem] = NULL;
    }
    
    obj_item[nitem].entity.active = false;
    obj_item[nitem].entity.visible = false;
}

void display_item_if_visible(u16 nitem)    // Show/hide item based on screen visibility
{
    if (nitem >= MAX_ITEMS || !obj_item[nitem].entity.active || obj_item[nitem].entity.sd == NULL) {
        return;
    }

    // Get sprite width from definition for visibility check
    u8 sprite_width = obj_item[nitem].entity.sd->w;
    
    // Calculate screen position
    s16 x = get_x_in_screen(obj_item[nitem].x_in_background, sprite_width);
    bool should_be_visible = (x != X_OUT_OF_BOUNDS);

    if (should_be_visible) {
        // Item should be visible
        if (spr_item[nitem] == NULL) {
            dprintf(2,"Item %d now visible. LOADING.", nitem);
            spr_item[nitem] = SPR_addSpriteSafe(obj_item[nitem].entity.sd, 
                                               x, 
                                               obj_item[nitem].entity.y, 
                                               TILE_ATTR(obj_item[nitem].entity.palette, 
                                                       false, false, false));
            
            if (spr_item[nitem] == NULL) {
                obj_item[nitem].entity.visible = false;
                return;
            }
        }
        
        // Update position and ensure visibility
        s16 clamped_x = x;
        if (clamped_x < -(s16)(sprite_width - 1)) clamped_x = -(s16)(sprite_width - 1);
        if (clamped_x > SCREEN_WIDTH - 1) clamped_x = SCREEN_WIDTH - 1;
        
        SPR_setPosition(spr_item[nitem], clamped_x, obj_item[nitem].entity.y);
        SPR_setVisibility(spr_item[nitem], VISIBLE);
    } else {
        // Item should be invisible
        if (spr_item[nitem] != NULL) {
            dprintf(2,"Item %d now invisible. UNLOADING.", nitem);
            SPR_setPosition(spr_item[nitem], -128, -128);
            SPR_setVisibility(spr_item[nitem], HIDDEN);
            SPR_update();  // Ensure sprite is moved before release
            SPR_releaseSprite(spr_item[nitem]);
            spr_item[nitem] = NULL;
        }
    }
    
    // Update final state
    obj_item[nitem].entity.visible = should_be_visible;
    obj_item[nitem].entity.x = x;
}

void check_items_visibility(void)    // Update visibility state of all active items
{
    u16 nitem;

    for (nitem=0;nitem<MAX_ITEMS;nitem++) {
        if (obj_item[nitem].entity.active==true) {
            display_item_if_visible(nitem);
        }
    }
}

u16 detect_nearby_item()    // Find closest item within interaction range of active character
{
    u16 nitem;
    u16 min_distance = 0xFFFF; // Maximum possible distance
    u16 closest_item = ITEM_NONE;
    u16 distance;
    
    // Get active character's position
    u16 char_x = obj_character[active_character].x + 
                 obj_character[active_character].collision_x_offset + 
                 (obj_character[active_character].collision_width / 2);
    u8 char_y = obj_character[active_character].y + 
                obj_character[active_character].collision_y_offset + 
                (obj_character[active_character].collision_height / 2);

    // Check all active and visible items
    for (nitem = 0; nitem < MAX_ITEMS; nitem++) {
        if (obj_item[nitem].entity.active && obj_item[nitem].entity.visible) {
            distance = item_distance(nitem, char_x, char_y);
            // If this item is closer than previous closest and within interaction distance
            if (distance < min_distance && distance <= MAX_INTERACTIVE_DISTANCE) {
                min_distance = distance;
                closest_item = nitem;
            }
        }
    }

    return closest_item;
}

================
File: res/res_characters.h
================
#include <genesis.h>

#ifndef _RES_RES_CHARACTERS_H_
#define _RES_RES_CHARACTERS_H_

extern const SpriteDefinition linus_sprite;
extern const SpriteDefinition linus_norod_sprite;
extern const SpriteDefinition linus_shadow_sprite;
extern const SpriteDefinition clio_sprite;
extern const SpriteDefinition clio_shadow_sprite;
extern const SpriteDefinition xander_sprite;
extern const SpriteDefinition xander_shadow_sprite;
extern const SpriteDefinition swan_sprite;
extern const Palette characters_pal;
extern const Palette swan_pal;

#endif // _RES_RES_CHARACTERS_H_

================
File: res/res_items.h
================
#include <genesis.h>

#ifndef _RES_RES_ITEMS_H_
#define _RES_RES_ITEMS_H_

extern const SpriteDefinition item_bedroom_linus_sleeping;
extern const SpriteDefinition item_bedroom_bed;
extern const SpriteDefinition item_bedroom_chair;
extern const SpriteDefinition item_bedroom_windowsill;
extern const SpriteDefinition item_bedroom_cabinet;
extern const SpriteDefinition item_corridor_bookpedestal_sprite;
extern const SpriteDefinition item_forest_fg1_sprite;
extern const SpriteDefinition item_forest_fg2_sprite;
extern const SpriteDefinition item_forest_fg3_sprite;
extern const SpriteDefinition item_forest_fg4_sprite;
extern const SpriteDefinition item_forest_fg5_sprite;

#endif // _RES_RES_ITEMS_H_

================
File: src/dialogs.c
================
#include "globals.h"

void talk(u8 nface, bool isinleft, char *text, u16 max_seconds)    // Display dialog with optional face portrait and timed text
{
    u16 faceposx,buttonposx;
    u16 textposx_line1=0, textposx_line2=0, textposx_line3=0;
    u16 joy_state;
    u16 num_ticks, max_ticks;

    char text_line1[40]={0},text_line2[40]={0},text_line3[40]={0};

    // If the active character is walking, stop it
    if (obj_character[active_character].state==STATE_WALKING) {
        obj_character[active_character].state=STATE_IDLE;
        update_character_animation();
    }

    // Initialize the needed face
    if (nface!=FACE_none) init_face(nface);

    // Divide the text in up to three lines
    split_text(text, text_line1, text_line2, text_line3);

    // Calculate centered positions using reusable function
    textposx_line1 = calculate_text_position(text_line1, isinleft, nface != FACE_none);
    textposx_line2 = calculate_text_position(text_line2, isinleft, nface != FACE_none);
    textposx_line3 = calculate_text_position(text_line3, isinleft, nface != FACE_none);

    // Check if face is in left or right (or none)
    if (nface!=FACE_none) {
        if (isinleft) {
            faceposx=0;
            buttonposx=296;
            SPR_setHFlip (spr_face[nface], false);
            SPR_setVisibility (spr_face_left, VISIBLE);
        }
        else{
            faceposx=256;
            buttonposx=232;
            SPR_setHFlip (spr_face[nface], true);
            SPR_setVisibility (spr_face_right, VISIBLE);
        }
        SPR_setPosition (spr_face[nface], faceposx, 160); // Show face
        SPR_setVisibility (spr_face[nface], VISIBLE);
    }
    else { // No face
        buttonposx=296;
        textposx_line1 = calculate_text_position(text_line1, false, false); // Center text
        textposx_line2 = calculate_text_position(text_line2, false, false); // Center text
        textposx_line3 = calculate_text_position(text_line3, false, false); // Center text
    }

    // Show text and button
    if (strlen(text_line2)<1) { // One line -> Center vertically
        strcpy(text_line2,text_line1);
        textposx_line2=textposx_line1;
        strcpy(text_line1,"");
    }
    print_line(text_line1, textposx_line1, 23, true);
    print_line(text_line2, textposx_line2, 24, true);
    print_line(text_line3, textposx_line3, 25, true);
    SPR_setVisibility (spr_int_button_A, VISIBLE);
    SPR_setPosition (spr_int_button_A, buttonposx, 208);
    next_frame(false);

    // Wait for time or button A
    num_ticks=0;
    max_ticks=max_seconds*SCREEN_FPS;
    joy_state=JOY_readJoypad (JOY_ALL);
    while (num_ticks<max_ticks && ((joy_state & BUTTON_A)==0))
    {
        next_frame(false);
        joy_state=JOY_readJoypad (JOY_ALL);
        num_ticks++;
    }

    // Is button A is still pressed, wait until release
    joy_state=JOY_readJoypad (JOY_ALL);
    while (joy_state & BUTTON_A)
    {
        joy_state=JOY_readJoypad (JOY_ALL);
        next_frame(false);
    }

    // Hide everything
    SPR_setVisibility (spr_face_left, HIDDEN);
    SPR_setVisibility (spr_face_right, HIDDEN);
    if (nface!=FACE_none) SPR_setVisibility (spr_face[nface], HIDDEN);
    SPR_setVisibility (spr_int_button_A, HIDDEN);
    VDP_clearTextLineBG(WINDOW,23);
    VDP_clearTextLineBG(WINDOW,24);
    VDP_clearTextLineBG(WINDOW,25);

    // Release the face from memory
    if (nface!=FACE_none) release_face(nface);

    next_frame(false);
}

void talk_dialog(const DialogItem *dialog)    // Display a predefined dialog item with face and text
{
    reset_character_animations();
    talk(dialog->face, dialog->side, (char *)dialog->text[game_language], dialog->max_seconds);
}

void split_text(char *text, char *line1, char *line2, char *line3)    // Break text into three lines using | as separator
{
    u16 len = strlen(text);
    u16 i, lineStart = 0;
    u16 line = 0;

    for (i = 0; i <= len; ++i) {
        if (text[i] == '|' || text[i] == '\0') {
            if (line == 0) {
                strncpy(line1, text + lineStart, i - lineStart);
                line1[i - lineStart] = '\0';
            } else if (line == 1) {
                strncpy(line2, text + lineStart, i - lineStart);
                line2[i - lineStart] = '\0';
            } else if (line == 2) {
                strncpy(line3, text + lineStart, i - lineStart);
                line3[i - lineStart] = '\0';
            }
            lineStart = i + 1;
            line++;
        }
    }
}

void print_line(char *text, u16 x, u16 y, bool wait_for_frame)    // Display text line with character-by-character animation
{
    int i = 0;
    u16 joy_state;
    char temp[2] = {0, 0};  // Temporary one character storage
    char *encoded_text = NULL;

    // Code Spanish text
    if (game_language == LANG_SPANISH) {
        encoded_text = encode_spanish_text(text);
        if (encoded_text != NULL) {
            text = encoded_text;
        }
    }

    // Print the text, character by character
    while (text[i] != '\0') {
        temp[0] = text[i];
        VDP_drawTextBG(WINDOW, temp, x + i, y);
        if (wait_for_frame) {
            joy_state = JOY_readJoypad(JOY_ALL);
            if ((joy_state & BUTTON_A) == 0) next_frame(false); // If button A is being pressed, skip frame update
        }
        i++;
    }

    if (wait_for_frame) {
        joy_state = JOY_readJoypad(JOY_ALL);
        while ((joy_state & BUTTON_A) != 0)
        {
            joy_state = JOY_readJoypad(JOY_ALL);
            next_frame(false); // If button A is being pressed, wait until release
        }
    }

    // Free the encoded text if it was allocated
    if (encoded_text != NULL) {
        free(encoded_text);
    }
}

u8 choice(u8 nface, bool isinleft, char **options, u8 num_options, u16 max_seconds)    // Display dialog with multiple choice options
{
    u16 faceposx, buttonposx;
    u16 textposx[MAX_CHOICES] = {0};
    u8 choice_lenght[MAX_CHOICES];
    char *encoded_text = NULL;
    u16 joy_state = JOY_readJoypad(JOY_ALL), prev_joy_state = 0;
    u8 current_option = 0;
    u16 num_ticks = 0;
    u16 max_ticks = max_seconds * SCREEN_FPS;
    
    // Load magic animation sprite
    Sprite* spr_magic_anim = SPR_addSprite(&int_magin_anim_sprite, 0, 0, TILE_ATTR(PAL2, TRUE, FALSE, FALSE));
    SPR_setVisibility(spr_magic_anim, HIDDEN);
    
    // If the active character is walking, stop it
    if (obj_character[active_character].state==STATE_WALKING) {
        obj_character[active_character].state=STATE_IDLE;
        update_character_animation();
    }

    // Initialize the needed face
    if (nface!=FACE_none) init_face(nface);

    // Check if face is in left or right (or none)
    if (nface!=FACE_none) {
        if (isinleft) {
            faceposx=0;
            buttonposx=296;
            SPR_setHFlip(spr_face[nface], false);
            SPR_setVisibility(spr_face_left, VISIBLE);
        }
        else {
            faceposx=256;
            buttonposx=232;
            SPR_setHFlip(spr_face[nface], true);
            SPR_setVisibility(spr_face_right, VISIBLE);
        }
        SPR_setPosition(spr_face[nface], faceposx, 160);
        SPR_setVisibility(spr_face[nface], VISIBLE);
    }
    else {
        buttonposx=296;
    }

    // Show initial options and calculate positions
    u8 start_y = (num_options == 2) ? 24 : 23; // Start one line lower for 2 options
    
    for(u8 i = 0; i < num_options && i < MAX_CHOICES; i++) {
        
        // Calculate lenght (it's important do encode Spanish characters to the standard font before)
        if (game_language==LANG_ENGLISH) choice_lenght[i]=strlen(options[i]);
        else {
            encoded_text = encode_spanish_text(options[i]);
            choice_lenght[i] = strlen(encoded_text);
        }

        // Center text (calculate position based on plain text)
        if(nface != FACE_none) {
            textposx[i] = 8 + ((33 - choice_lenght[i]) >> 1);
            if(!isinleft) textposx[i] -= 8;
        }
        else {
            textposx[i] = calculate_text_position(options[i], false, false);
        }

        // Show plain text first
        print_line(options[i], textposx[i], start_y + i, false);
    }

    // Add selection markers to initial option
    VDP_drawTextBG(WINDOW, "}", textposx[current_option] - 2, start_y + current_option);
    VDP_drawTextBG(WINDOW, "{", textposx[current_option] + choice_lenght[current_option] + 1, start_y + current_option);

    // Show magic animation on initial option
    u16 magic_x = (textposx[current_option] * 8) + ((choice_lenght[current_option] * 8) / 2) - 80;
    u16 magic_y = (start_y + current_option) * 8;
    SPR_setPosition(spr_magic_anim, magic_x, magic_y);
    SPR_setVisibility(spr_magic_anim, VISIBLE);

    // Show button A
    SPR_setVisibility(spr_int_button_A, VISIBLE);
    SPR_setPosition(spr_int_button_A, buttonposx, 208);
    next_frame(false);

    // Main loop
    while(num_ticks < max_ticks) {
        // Handle input
        prev_joy_state = joy_state;
        joy_state = JOY_readJoypad(JOY_ALL);

        // Only process new button presses
        u16 new_press = joy_state & ~prev_joy_state;

        bool need_redraw = false;

        if(new_press & BUTTON_UP) {
            if(current_option > 0) {
                current_option--;
                need_redraw = true;
            }
        }
        else if(new_press & BUTTON_DOWN) {
            if(current_option < num_options - 1) {
                current_option++;
                need_redraw = true;
            }
        }
        else if(new_press & BUTTON_A) {
            break;
        }

        // Only update selection markers if needed
        if(need_redraw) {
            u8 prev_option = current_option + (new_press & BUTTON_UP ? 1 : -1);
            
            // Remove selection markers from previous option
            VDP_drawTextBG(WINDOW, " ", textposx[prev_option] - 2, start_y + prev_option);
            VDP_drawTextBG(WINDOW, " ", textposx[prev_option] + choice_lenght[prev_option] + 1, start_y + prev_option);

            // Add selection markers to new option
            VDP_drawTextBG(WINDOW, "}", textposx[current_option] - 2, start_y + current_option);
            VDP_drawTextBG(WINDOW, "{", textposx[current_option] + choice_lenght[current_option] + 1, start_y + current_option);
            
            // Update magic animation position
            // Center horizontally: text position + (text length * 8) / 2 - (160 / 2)
            u16 magic_x = (textposx[current_option] * 8) + ((choice_lenght[current_option] * 8) / 2) - 80;
            // Vertically align with text: start_y + current_option lines down (8 pixels per line)
            u16 magic_y = (start_y + current_option) * 8;
            SPR_setPosition(spr_magic_anim, magic_x, magic_y);
            SPR_setVisibility(spr_magic_anim, VISIBLE);
        }

        next_frame(false);
        num_ticks++;
    }

    // Wait for button A release
    joy_state = JOY_readJoypad(JOY_ALL);
    while(joy_state & BUTTON_A) {
        joy_state = JOY_readJoypad(JOY_ALL);
        next_frame(false);
    }

    // Hide everything
    SPR_setVisibility(spr_face_left, HIDDEN);
    SPR_setVisibility(spr_face_right, HIDDEN);
    if(nface != FACE_none) SPR_setVisibility(spr_face[nface], HIDDEN);
    SPR_setVisibility(spr_int_button_A, HIDDEN);
    SPR_releaseSprite(spr_magic_anim);
    VDP_clearTextLineBG(WINDOW, 23);
    VDP_clearTextLineBG(WINDOW, 24);
    VDP_clearTextLineBG(WINDOW, 25);

    // Release the face from memory
    if(nface != FACE_none) release_face(nface);

    next_frame(false);

    dprintf(2,"Choice: %d\n", current_option);
    return current_option;
}

u8 choice_dialog(const ChoiceItem *item)    // Display a predefined choice dialog item
{
    reset_character_animations();
    u8 result = choice(item->face, item->side, (char **)item->options[game_language], item->num_options, item->max_seconds);
    return result;
}

================
File: res/res_characters.res
================
# Linux
SPRITE linus_sprite "Sprites/Characters/linus.png" 6 8 BEST 4
SPRITE linus_norod_sprite "Sprites/Characters/linus_norod.png" 6 8 BEST 4
SPRITE linus_shadow_sprite "Sprites/Characters/linus_shadow.png" 6 1 BEST

# Clio
SPRITE clio_sprite "Sprites/Characters/clio.png" 4 8 BEST 4 
SPRITE clio_shadow_sprite "Sprites/Characters/clio_shadow.png" 4 1 BEST

# Xander
SPRITE xander_sprite "Sprites/Characters/xander.png" 6 8 BEST 4
SPRITE xander_shadow_sprite "Sprites/Characters/xander_shadow.png" 6 1 BEST

# Swan
SPRITE swan_sprite "Sprites/Characters/swan.png" 8 7 BEST 10

# Palettes
PALETTE characters_pal "Sprites/Characters/characters.pal"
PALETTE swan_pal "Sprites/Characters/swan.png"

================
File: res/res_interface.h
================
#include <genesis.h>

#ifndef _RES_RES_INTERFACE_H_
#define _RES_RES_INTERFACE_H_

extern const Palette interface_pal;
extern const Image int_pentagram_image;
extern const SpriteDefinition int_pentagram_1_sprite;
extern const SpriteDefinition int_pentagram_2_sprite;
extern const SpriteDefinition int_pentagram_3_sprite;
extern const SpriteDefinition int_pentagram_4_sprite;
extern const SpriteDefinition int_pentagram_5_sprite;
extern const SpriteDefinition int_pentagram_6_sprite;
extern const Image int_rod_image;
extern const SpriteDefinition int_rod_1_sprite;
extern const SpriteDefinition int_rod_2_sprite;
extern const SpriteDefinition int_rod_3_sprite;
extern const SpriteDefinition int_rod_4_sprite;
extern const SpriteDefinition int_rod_5_sprite;
extern const SpriteDefinition int_rod_6_sprite;
extern const SpriteDefinition int_enemy_rod_1_sprite;
extern const SpriteDefinition int_enemy_rod_2_sprite;
extern const SpriteDefinition int_enemy_rod_3_sprite;
extern const SpriteDefinition int_enemy_rod_4_sprite;
extern const SpriteDefinition int_enemy_rod_5_sprite;
extern const SpriteDefinition int_enemy_rod_6_sprite;
extern const SpriteDefinition int_pattern_thunder;
extern const SpriteDefinition int_pattern_hide;
extern const SpriteDefinition int_pattern_open;
extern const SpriteDefinition int_pattern_sleep;
extern const SpriteDefinition int_life_counter_sprite;
extern const SpriteDefinition int_button_A_sprite;
extern const SpriteDefinition int_magin_anim_sprite;
extern const Image int_screen_limit;

#endif // _RES_RES_INTERFACE_H_

================
File: src/globals.h
================
#ifndef _GLOBALS_H_
#define _GLOBALS_H_


// Create version using compile date
#define GAMEVERSION ({ static char version[20]; sprintf(version, "v%c%c%c%c%c%c%c", (__DATE__[4] == ' ' ? '0' : __DATE__[4]), __DATE__[5], __DATE__[0], __DATE__[1], __DATE__[2], __DATE__[9], __DATE__[10]); version; })

// Sega Genesis
#include <genesis.h>

// Debug
#define DEBUG_LEVEL 2  // 0: no debug, 1: only errors, 2: debug messages, 3: verbose debug messages

#define dprintf(level, ...) ((void)0)
#if DEBUG_LEVEL > 0
  #undef dprintf
  #include "KDebug.h"
  #include "tools.h"
  #include "timer.h"
  #define dprintf(level, ...) do { if ((level) <= DEBUG_LEVEL) kprintf(__VA_ARGS__); } while (0)
#endif

// Resources
#include "../res/resources.h"
#include "../res/res_backgrounds.h"
#include "../res/res_characters.h"
#include "../res/res_faces.h"
#include "../res/res_enemies.h"
#include "../res/res_items.h"
#include "../res/res_interface.h"
#include "../res/res_sound.h"
#include "../res/res_geesebumps.h"
#include "../res/res_intro.h"

extern u16 tile_ind; // Tiles index
extern u16 frame_counter; // Number of frames counter (random number generator, and frameskip counter in some functions)

// Auxiliary game libraries
#include "entity.h" // Every object in the game that has a sprite you can show, move...
#include "combat.h" // Combat related functions
#include "characters.h" // Characters that can talk, or you can control
#include "enemies.h" // Enemies you fight
#include "patterns.h" // Pattern structure and definitions
#include "items.h" // Items in the scenery
#include "texts.h" // Text strings (English / Spanish)
#include "dialogs.h" // Dialog and text related functions
#include "controller.h" // Controller related functions
#include "interface.h" // Game interface
#include "background.h" // Background and scenery related objects and functions
#include "collisions.h" // Distance and collisions related functions
#include "sound.h" // Music and SFX

// Main game libraries
#include "init.h" // Initialization functions
#include "intro.h" // Game intro
#include "geesebumps.h" // Geesebumps logo
#include "act_1.h" // Act 1

// Global definitions (NTSC)
#define SCREEN_WIDTH 320
#define SCREEN_HEIGHT 224
extern u8 SCREEN_FPS;

// Game state globals
extern u8 current_act;
extern u8 current_scene;

// Global functions
void wait_seconds(int sec); // Wait for N seconds
void next_frame(bool interactive); // Wait for next frame and do each-frame actions, including interactive actions if selected
u16 calc_ticks(u16 milliseconds); // Translate millisecons to ticks

#endif

================
File: src/init.c
================
#include "globals.h"

void initialize(bool first_time)    // Initialize system hardware, sprites, controllers and global game state
{
    dprintf(2,"Initializing system, first_time=%d\n", first_time);
    u8 i;

    // Initialize VPD
    VDP_init();

    // Initialize audio driver
    Z80_init();
    if (XGM_VERSION==2) {
        Z80_loadDriver(Z80_DRIVER_XGM2, 1);
        dprintf(2,"XGM2 driver loaded\n");
    }
    else {
        Z80_loadDriver(Z80_DRIVER_XGM, 1);
        dprintf(2,"XGM driver loaded\n");
    }

    // Initialize sprite Engine
    SPR_init();

    // Initialize controllers
    JOY_init();

    // Screen definitions
    VDP_setScreenWidth320();
    VDP_setScreenHeight224();

    // Detect refresh rate
    u8 vers = *(u8 *)0xA10001;
    if(vers & (1 << 6)) SCREEN_FPS=50; // PAL
    else SCREEN_FPS=60; // NTSC

    // Load font and set text palette
    VDP_loadFont(font.tileset, DMA);
    VDP_setTextPalette(PAL2);

    // Initialize globals
    tile_ind = TILE_USER_INDEX;

    //  Plane A scrolls up to line 22 (176px)
    VDP_setWindowVPos(TRUE, 22);

    // Initialize palettes
    dprintf(2,"Loading palettes (initialize)\n");
    // PAL0 is the background palette. It's initialized with the background
    PAL_setPalette(PAL1, characters_pal.data, DMA); // Characters palette
    PAL_setPalette(PAL2, interface_pal.data, DMA); // Interface palette
    // PAL2 is the enemies palette. It's initialized with the enemies

    // Interface: Face backgrounds
    dprintf(2,"Loading face backgrounds\n");
    spr_face_left = SPR_addSpriteSafe ( &face_left_sprite, 0, 160, TILE_ATTR(PAL1, false, false, true));
    SPR_setVisibility (spr_face_left, HIDDEN);
    spr_face_right = SPR_addSpriteSafe ( &face_right_sprite, 256, 160, TILE_ATTR(PAL1, false, false, true));
    SPR_setVisibility (spr_face_right, HIDDEN);
    SPR_setDepth (spr_face_left, SPR_MIN_DEPTH+1); // Face background are above anything but faces
    SPR_setDepth (spr_face_right, SPR_MIN_DEPTH+1); // Face background are above anything but faces

    // Interface: Button A
    spr_int_button_A = SPR_addSpriteSafe (&int_button_A_sprite, 0, 0, TILE_ATTR(PAL2, false, false, false));
    SPR_setVisibility (spr_int_button_A, HIDDEN);

    // Patterns & combat context
    if (first_time) {
        dprintf(2,"Initializing patterns\n");
        initPlayerPatterns();
        dprintf(2,"Initializing enemy classes\n");
        init_enemy_classes();
    }
    dprintf(2,"Initializing combat context\n");
    combatContext.state          = COMBAT_NO;
    combatContext.frameInState   = 0;
    combatContext.activePattern  = PATTERN_PLAYER_NONE;
    combatContext.effectTimer    = 0;
    combatContext.patternReversed= FALSE;
    combatContext.noteTimer      = 0;
    combatContext.playerNotes    = 0;
    combatContext.enemyNotes     = 0;
    combatContext.activeEnemy    = ENEMY_NONE;

    // Items
    pending_item_interaction=ITEM_NONE;

    // Release active character, faces, enemies and items
    for (i=0;i<MAX_CHR;i++) {
        if (obj_character[i].active==true) release_character(i);
    }
    for (i=0;i<MAX_FACE;i++) {
        if (obj_face[i].active==true) release_face(i);
    }
    for (i=0;i<MAX_ENEMIES;i++) {
        if (obj_enemy[i].obj_character.active==true) release_enemy(i);
    }
    for (i=0;i<MAX_ITEMS;i++) {
        if (obj_item[i].entity.active==true) release_item(i);
    }
}

// initialize level and load background
void new_level(const TileSet *tile_bg, const MapDefinition *map_bg, const TileSet *tile_front, const MapDefinition *map_front, Palette new_pal, u16 new_background_width, u8 new_scroll_mode, u8 new_scroll_speed)    // Load and setup a new game level with background layers and scroll settings
{
    dprintf(2,"Loading new level: bg_width=%d scroll_mode=%d\n", new_background_width, new_scroll_mode);
    
    initialize(false); // Reset hardware when starting each level, but don't change only first-time options
    
    // Reset tile index to start fresh
    tile_ind = TILE_USER_INDEX;
    
    // Tile_bg and Map_bg are the background layer. They can be NULL
    if ((tile_bg!=NULL) && (map_bg!=NULL)) {
        dprintf(2,"Loading background tileset, tiles=%d\n", tile_bg->numTile);
        VDP_loadTileSet(tile_bg, tile_ind, CPU);
        background_BGB = MAP_create(map_bg, BG_B, TILE_ATTR_FULL(PAL0, false, false, false, tile_ind));
        tile_ind += tile_bg->numTile;
    }
    else background_BGB=NULL;

    // Tile_front and Map_front are the foreground layer. Thay can't be NULL.
    dprintf(2,"Loading foreground tileset, tiles=%d\n", tile_front->numTile);
    VDP_loadTileSet(tile_front, tile_ind, CPU);
    background_BGA = MAP_create(map_front, BG_A, TILE_ATTR_FULL(PAL0, false, false, false, tile_ind));
    tile_ind += tile_front->numTile;

    // Set palettes after loading all tiles to avoid flicker
    dprintf(2,"Loading palettes (new level)\n");
    PAL_setPalette(PAL0, new_pal.data, DMA);
    PAL_setPalette(PAL1, characters_pal.data, DMA);
    PAL_setPalette(PAL2, interface_pal.data, DMA);

    background_scroll_mode=new_scroll_mode;
    scroll_speed=new_scroll_speed;
    background_width=new_background_width;

    offset_BGA=0;
    offset_BGB=0;

    if (background_scroll_mode==BG_SCRL_USER_LEFT) { // We should start at the rightmost edge of the screen
        offset_BGA=background_width-SCREEN_WIDTH;
    }

    interface_active=false; // No interface by default
    player_scroll_active=false; // You can't scroll the screen by default
    movement_active=false; // You can't move by default

    dprintf(2,"everthing initialized, background scroll mode=%d, scroll speed=%d\n", background_scroll_mode, scroll_speed);
    update_bg(false);
}

// Free all resources used by the level
void end_level() {    // Clean up level resources and reset game state
    dprintf(2,"Ending level, freeing resources\n");
    
    // Fade out music and screen
    fade_music(SCREEN_FPS);
    PAL_fadeOutAll(SCREEN_FPS,false);

    // Free background maps
    if (background_BGA) {
        MAP_release(background_BGA);
        background_BGA = NULL;
    }
    if (background_BGB) {
        MAP_release(background_BGB);
        background_BGB = NULL;
    }

    // Release active characters
    dprintf(2,"Releasing active characters\n");
    for (u16 i = 0; i < MAX_CHR; i++) {
        if (obj_character[i].active) {
            release_character(i);
        }
    }

    // Release active faces
    for (u16 i = 0; i < MAX_FACE; i++) {
        if (obj_face[i].active) {
            release_face(i);
        }
    }

    // Release active enemies
    for (u16 i = 0; i < MAX_ENEMIES; i++) {
        if (obj_enemy[i].obj_character.active) {
            release_enemy(i);
        }
    }

    // Release active items
    for (u16 i = 0; i < MAX_ITEMS; i++) {
        if (obj_item[i].entity.active) {
            release_item(i);
        }
    }

    // Reset combat context
    combatContext = (CombatContext){
        .state           = COMBAT_NO,
        .frameInState    = 0,
        .activePattern   = PATTERN_PLAYER_NONE,
        .effectTimer     = 0,
        .patternReversed = FALSE,
        .noteTimer       = 0,
        .playerNotes     = 0,
        .enemyNotes      = 0,
        .activeEnemy     = ENEMY_NONE
    };

    // player_patterns_enabled = false; // Mantener habilitado para permitir lanzar hechizos

    pending_item_interaction = ITEM_NONE;

    // Reset scroll values
    offset_BGA = 0;
    offset_BGB = 0;
    background_scroll_mode = 0;
    scroll_speed = 0;
    player_scroll_active = FALSE;
    movement_active = FALSE;

    // Reset screen limits
    x_limit_min = 0;
    x_limit_max = 0;
    y_limit_min = 0;
    y_limit_max = 0;

    // Reset game state
    //active_character = CHR_NONE; <-- Don't reset: The Act level code should do it if needed
    interface_active = FALSE;

    // Reset all sprites after releasing everything
    VDP_releaseAllSprites();
    SPR_reset();
    
    // Reset VDP state
    tile_ind = TILE_USER_INDEX;
    VDP_resetScreen();
    VDP_clearPlane(BG_A, TRUE);
    VDP_clearPlane(BG_B, TRUE);
    PAL_setColor(0, RGB24_TO_VDPCOLOR(0x000000));
    VDP_setWindowVPos(TRUE, 22);

    dprintf(2,"Level cleanup complete\n");
}

================
File: src/interface.c
================
#include "globals.h"

Sprite *spr_face_left;                    // Left character face background sprite
Sprite *spr_face_right;                   // Right character face background sprite
Sprite *spr_int_button_A;                 // Button A interface sprite
Map *map_int_rod;                         // Rod interface map
Sprite *spr_int_rod_1,*spr_int_rod_2,*spr_int_rod_3,*spr_int_rod_4,*spr_int_rod_5,*spr_int_rod_6;    // Player rod note sprites
Sprite *spr_int_enemy_rod_1,*spr_int_enemy_rod_2,*spr_int_enemy_rod_3,*spr_int_enemy_rod_4,*spr_int_enemy_rod_5,*spr_int_enemy_rod_6;    // Enemy rod note sprites
Sprite *spr_int_pentagram_1,*spr_int_pentagram_2,*spr_int_pentagram_3,*spr_int_pentagram_4,*spr_int_pentagram_5,*spr_int_pentagram_6;    // Pentagram note sprites
Sprite *spr_int_life_counter;             // Life counter interface sprite
Sprite *spr_pause_icon[5];                // Pattern icons shown in pause screen
Sprite *spr_pattern_list_note[4];         // Note sprites shown in pause pattern list
bool interface_active;                     // Whether game interface is currently shown


void show_or_hide_interface(bool visible)    // Toggle visibility of game's bottom interface
{
    if (!interface_active) return; // If interface is not active, do nothing

    if (visible == true) {
        // Draw the rod and pentagram images in the window plane
        VDP_drawImageEx(WINDOW, &int_screen_limit, TILE_ATTR_FULL(PAL2, false, false, false, tile_ind), 0, 22, false, true);
        tile_ind+=int_screen_limit.tileset->numTile;
        VDP_drawImageEx(WINDOW, &int_rod_image, TILE_ATTR_FULL(PAL2, false, false, false, tile_ind), 0, 23, false, true);
        tile_ind+=int_rod_image.tileset->numTile;
        VDP_drawImageEx(WINDOW, &int_pentagram_image, TILE_ATTR_FULL(PAL2, false, false, false, tile_ind), 27, 22, false, true);
        tile_ind+=int_pentagram_image.tileset->numTile;
    } 
    else {
        // Clear the window plane and hide rod and pentagram icons
        tile_ind-=int_rod_image.tileset->numTile;
        tile_ind-=int_pentagram_image.tileset->numTile;
        VDP_clearPlane(WINDOW, true);
        hide_rod_icons();
        hide_pentagram_icons();
    }
}

void show_note(u8 nnote, bool visible)    // Display or hide a musical note (1-6:MI-DO) with its rod and pentagram sprites
{
    Sprite **pentSpr, **rodSpr;
    const SpriteDefinition *pentDef, *rodDef;
    u16 pentX, rodX;

    switch (nnote)
    {
        case NOTE_MI:  pentSpr=&spr_int_pentagram_1; rodSpr=&spr_int_rod_1;
                       pentDef=&int_pentagram_1_sprite; rodDef=&int_rod_1_sprite;
                       pentX=219;        rodX=24;        break;
        case NOTE_FA:  pentSpr=&spr_int_pentagram_2; rodSpr=&spr_int_rod_2;
                       pentDef=&int_pentagram_2_sprite; rodDef=&int_rod_2_sprite;
                       pentX=235;        rodX=56;        break;
        case NOTE_SOL: pentSpr=&spr_int_pentagram_3; rodSpr=&spr_int_rod_3;
                       pentDef=&int_pentagram_3_sprite; rodDef=&int_rod_3_sprite;
                       pentX=251;        rodX=88;        break;
        case NOTE_LA:  pentSpr=&spr_int_pentagram_4; rodSpr=&spr_int_rod_4;
                       pentDef=&int_pentagram_4_sprite; rodDef=&int_rod_4_sprite;
                       pentX=267;        rodX=120;       break;
        case NOTE_SI:  pentSpr=&spr_int_pentagram_5; rodSpr=&spr_int_rod_5;
                       pentDef=&int_pentagram_5_sprite; rodDef=&int_rod_5_sprite;
                       pentX=283;        rodX=152;       break;
        default:       pentSpr=&spr_int_pentagram_6; rodSpr=&spr_int_rod_6;
                       pentDef=&int_pentagram_6_sprite; rodDef=&int_rod_6_sprite;
                       pentX=299;        rodX=184;       break;
    }

    if (visible) // Show the note and its rod/pentagram sprites
    {
        if (*rodSpr == NULL)
            *rodSpr = SPR_addSpriteSafe(rodDef, rodX, 212,
                                         TILE_ATTR(PAL2,false,false,false));

        if (*pentSpr == NULL && player_patterns_enabled)
            *pentSpr = SPR_addSpriteSafe(pentDef, pentX, 180,
                                         TILE_ATTR(PAL2,false,false,false));
    }
    else { // Hide the note and its rod/pentagram sprites
        if (*rodSpr)
        {   SPR_releaseSprite(*rodSpr);
            *rodSpr = NULL;
        }

        if (*pentSpr && player_patterns_enabled)
        {   SPR_releaseSprite(*pentSpr);
            *pentSpr = NULL;
        }
    }

    SPR_update();
}

void hide_rod_icons(void)    // Remove all rod note sprites from interface
{
    // Release all rod sprites and set pointers to NULL
    if (spr_int_rod_1!=NULL) SPR_releaseSprite(spr_int_rod_1);
    if (spr_int_rod_2!=NULL) SPR_releaseSprite(spr_int_rod_2);
    if (spr_int_rod_3!=NULL) SPR_releaseSprite(spr_int_rod_3);
    if (spr_int_rod_4!=NULL) SPR_releaseSprite(spr_int_rod_4);
    if (spr_int_rod_5!=NULL) SPR_releaseSprite(spr_int_rod_5);
    if (spr_int_rod_6!=NULL) SPR_releaseSprite(spr_int_rod_6);
    spr_int_rod_1=NULL;
    spr_int_rod_2=NULL;
    spr_int_rod_3=NULL;
    spr_int_rod_4=NULL;
    spr_int_rod_5=NULL;
    spr_int_rod_6=NULL;
    SPR_update();
}

void hide_pentagram_icons(void)    // Remove all pentagram note sprites from interface
{
    // Release all pentagram sprites and set pointers to NULL
    if (spr_int_pentagram_1!=NULL) SPR_releaseSprite(spr_int_pentagram_1);
    if (spr_int_pentagram_2!=NULL) SPR_releaseSprite(spr_int_pentagram_2);
    if (spr_int_pentagram_3!=NULL) SPR_releaseSprite(spr_int_pentagram_3);
    if (spr_int_pentagram_4!=NULL) SPR_releaseSprite(spr_int_pentagram_4);
    if (spr_int_pentagram_5!=NULL) SPR_releaseSprite(spr_int_pentagram_5);
    if (spr_int_pentagram_6!=NULL) SPR_releaseSprite(spr_int_pentagram_6);
    spr_int_pentagram_1=NULL;
    spr_int_pentagram_2=NULL;
    spr_int_pentagram_3=NULL;
    spr_int_pentagram_4=NULL;
    spr_int_pentagram_5=NULL;
    spr_int_pentagram_6=NULL;
    SPR_update();
}

void hide_pattern_icons(void)    // Remove all pattern spell icons from interface
{
    u16 npattern;

    for (npattern=0;npattern<MAX_PLAYER_PATTERNS;npattern++) {
    if (playerPatterns[npattern].icon!=NULL) {
            SPR_releaseSprite(playerPatterns[npattern].icon);
            playerPatterns[npattern].icon=NULL;
        }
    }
}

void show_pattern_icon(u16 npattern, bool show, bool priority)    // Display or hide a pattern spell icon in interface
{
    u8 npal = PAL2;
    const SpriteDefinition *nsprite = NULL;

    if (show==TRUE) {
        // Select the appropriate sprite based on the pattern
        if (npattern==PATTERN_THUNDER) nsprite = &int_pattern_thunder;
        if (npattern==PATTERN_HIDE) nsprite = &int_pattern_hide;
        if (npattern==PATTERN_OPEN) nsprite = &int_pattern_open;
        if (npattern==PATTERN_SLEEP) nsprite = &int_pattern_sleep;
        
        // Add the sprite if it doesn't exist
        if (playerPatterns[npattern].icon==NULL) playerPatterns[npattern].icon = SPR_addSpriteSafe(nsprite, SCREEN_WIDTH-40, 4, TILE_ATTR(npal, priority, false, false));
        SPR_setAlwaysOnTop(playerPatterns[npattern].icon);
    }
    else {
        // Release the sprite if it exists
        SPR_releaseSprite(playerPatterns[npattern].icon);
        playerPatterns[npattern].icon=NULL;
    }
}

SpriteState* hideAllSprites(u16* count)    // Hide all active sprites and save their visibility state
{
    Sprite* currentSprite = firstSprite;
    u16 spriteCount = 0;
    
    // First, count how many sprites there are
    while (currentSprite != NULL) {
        spriteCount++;
        currentSprite = currentSprite->next;
    }
    
    // Allocate memory for the state array
    SpriteState* states = MEM_alloc(spriteCount * sizeof(SpriteState));
    
    // Return to the first sprite
    currentSprite = firstSprite;
    u16 index = 0;
    
    // Traverse again, saving the state and hiding
    while (currentSprite != NULL) {
        states[index].sprite = currentSprite;
        states[index].visibility = SPR_getVisibility(currentSprite);
        
        // Hide the sprite
        SPR_setVisibility(currentSprite, HIDDEN);
        
        currentSprite = currentSprite->next;
        index++;
    }
    
    *count = spriteCount;
    return states;
}

void restoreSpritesVisibility(SpriteState* states, u16 count)    // Restore previously saved sprite visibility states
{
    for (u16 i = 0; i < count; i++) {
        if (states[i].sprite != NULL) {
            SPR_setVisibility(states[i].sprite, states[i].visibility);
        }
    }
    
    // Free allocated memory
    MEM_free(states);
}

void pause_screen(void)    // Handle pause screen with pattern spell selection
{
    u16 value; // Joypad value
    u8 old_pattern,selected_pattern,npattern,num_active_patterns=0;
    bool next_pattern_found;

    u16 spriteCount;
    SpriteState* savedStates;

    // Initialize pattern list note sprites to NULL
    for (u8 i = 0; i < 4; i++) {
        spr_pattern_list_note[i] = NULL;
    }

    VDP_setHilightShadow(true); // Dim screen
    show_or_hide_interface(false); // Hide interface
    //show_or_hide_enemy_combat_interface(false); // Hide combat interface
    savedStates = hideAllSprites(&spriteCount); // Hide every sprite and save state

    // Find the first active pattern
    selected_pattern=254;
    for (npattern=0;npattern<MAX_PLAYER_PATTERNS;npattern++) {
        if (playerPatterns[npattern].enabled==true) {
            #ifdef DEBUG_ON
             dprintf(2,"Patron %d activo", npattern);
            #endif
            num_active_patterns++;
            if (selected_pattern==254) selected_pattern=npattern;
        } 
    }

    if (num_active_patterns!=0) show_pause_pattern_list(true,selected_pattern);

    value = JOY_readJoypad(JOY_ALL);
    while ( (value & BUTTON_START) == 0 ) { // Wait until START button is pressed again
        value = JOY_readJoypad(JOY_ALL);
        if (num_active_patterns>1) { // Only allow pattern switching if there's more than one active pattern
            if (value & BUTTON_RIGHT) { // Find next active pattern
                next_pattern_found=false;
                old_pattern=selected_pattern;
                selected_pattern++;
                while (next_pattern_found==false)
                {
                    if (selected_pattern==MAX_PLAYER_PATTERNS) selected_pattern=0;
                    if (playerPatterns[selected_pattern].enabled==true) next_pattern_found=true;
                    else selected_pattern++;
                }
                show_pause_pattern_list(false,old_pattern); // Hide previous pattern
                show_pause_pattern_list(true,selected_pattern); // Show new pattern
            }
            if (value & BUTTON_LEFT) { // Find previous active pattern
                next_pattern_found=false;
                old_pattern=selected_pattern;
                selected_pattern--;
                while (next_pattern_found==false)
                {
                    if (selected_pattern==255) selected_pattern=MAX_PLAYER_PATTERNS-1;
                    if (playerPatterns[selected_pattern].enabled==true) next_pattern_found=true;
                    else selected_pattern--;
                }            
                show_pause_pattern_list(false,old_pattern); // Hide previous pattern
                show_pause_pattern_list(true,selected_pattern); // Show new pattern
            }
            while ((value & BUTTON_LEFT) || (value & BUTTON_RIGHT)) // Wait until LEFT or RIGHT is released
            {
                value = JOY_readJoypad(JOY_ALL);
                SYS_doVBlankProcess();
            }
        }
        SPR_update();
        SYS_doVBlankProcess();
    }
    while ( value & BUTTON_START ) { // Now wait until START is released
        value = JOY_readJoypad(JOY_ALL);
        SYS_doVBlankProcess();
    }

    if (num_active_patterns != 0) {
        show_pause_pattern_list(false, selected_pattern); // Hide last selected pattern
    }

    // Release any remaining pattern list note sprites
    for (u8 nnote = 0; nnote < 4; nnote++) {
        if (spr_pattern_list_note[nnote] != NULL) {
            SPR_releaseSprite(spr_pattern_list_note[nnote]);
            spr_pattern_list_note[nnote] = NULL;
        }
    }

    show_or_hide_interface(true); // Show interface again
    //show_or_hide_enemy_combat_interface(true); // Show combat interface again
    restoreSpritesVisibility(savedStates, spriteCount); // Restore sprites visibility
    VDP_setHilightShadow(false); // Relit screen
    SPR_update();
    VDP_waitVSync();
}

void show_pause_pattern_list(bool show, u8 active_pattern)    // Display pattern list in pause screen with active pattern highlighted
{
    u16 x_initial,x, nicon;
    u8 nnote, npattern, num_active_patterns=0;
    bool priority;

    for (npattern=0;npattern<MAX_PLAYER_PATTERNS;npattern++) // Count active patterns
        if (playerPatterns[npattern].enabled==true) num_active_patterns++;

    x_initial = (134 - 24 * num_active_patterns); // Calculate initial X position
    x = x_initial;
    nicon = 0;

    for (npattern=0;npattern<MAX_PLAYER_PATTERNS;npattern++) {
        if (playerPatterns[npattern].enabled==true) {
            priority = (npattern==active_pattern); // Highlight active pattern
            show_icon_in_pause_list(npattern, nicon, x, show, priority); // Show or hide pattern icon
            x+=48;
            nicon++;
        }
    }

    for (nnote=0;nnote<4;nnote++) {
        show_note_in_pause_pattern_list(active_pattern,nnote,show); // Show notes for the active pattern
    }
}

void show_note_in_pause_pattern_list(u8 npattern, u8 nnote, bool show)    // Display a note in the pause screen pattern list
{
    SpriteDefinition *pentsprite;
    u8 note;
    u16 x;

    note=playerPatterns[npattern].notes[nnote]; // Get the note for this pattern 

    // Select the appropriate pentagram sprite based on the note
    switch (note) 
    {
    case NOTE_MI:
        pentsprite=(SpriteDefinition*) &int_pentagram_1_sprite;
        break;
    case NOTE_FA:
        pentsprite=(SpriteDefinition*) &int_pentagram_2_sprite;
        break;
    case NOTE_SOL:
        pentsprite=(SpriteDefinition*) &int_pentagram_3_sprite;
        break;
    case NOTE_LA:
        pentsprite=(SpriteDefinition*) &int_pentagram_4_sprite;
        break;
    case NOTE_SI:
        pentsprite=(SpriteDefinition*) &int_pentagram_5_sprite;
        break;
    default:
        pentsprite=(SpriteDefinition*) &int_pentagram_6_sprite;
        break;
    }

    if (show==true) {
        x=251+nnote*16;
        spr_pattern_list_note[nnote]=SPR_addSpriteSafe(pentsprite, x, 180, TILE_ATTR(PAL2,false,false,false));
    }
    else {
        if (spr_pattern_list_note[nnote] != NULL) {
            SPR_releaseSprite(spr_pattern_list_note[nnote]);
            spr_pattern_list_note[nnote] = NULL;
        }
    }
}

void show_icon_in_pause_list(u16 npattern, u8 nicon, u16 x, bool show, bool priority)    // Display a pattern icon in the pause screen list
{
    u8 npal = PAL2;
    const SpriteDefinition *nsprite = NULL;

    if (show==TRUE) {
        // Select the appropriate sprite based on the pattern
        if (npattern==PATTERN_THUNDER) nsprite = &int_pattern_thunder;
        if (npattern==PATTERN_HIDE) nsprite = &int_pattern_hide;
        if (npattern==PATTERN_OPEN) nsprite = &int_pattern_open;
        if (npattern==PATTERN_SLEEP) nsprite = &int_pattern_sleep;

        if (spr_pause_icon[nicon]==NULL) spr_pause_icon[nicon] = SPR_addSpriteSafe(nsprite, x, 182, TILE_ATTR(npal, priority, false, false));
    }
    else {
        if (spr_pause_icon[nicon] != NULL) {
            SPR_releaseSprite(spr_pause_icon[nicon]);
            spr_pause_icon[nicon]=NULL;
        }
    }
}

// Check the status of the current pattern, including note playing and expiration
void check_pattern_status(void)
{
    combatContext.noteTimer++;

    // Abort the pattern if the player has not played any notes for too long
    if (combatContext.playerNotes && combatContext.noteTimer > calc_ticks(MAX_PATTERN_WAIT_TIME)) {
        dprintf(1,"Pattern aborted after %u ticks\n", combatContext.noteTimer);

        reset_note_queue();
        if (current_note != NOTE_NONE)
            show_note(current_note, false);
        current_note = NOTE_NONE;
    }

    // Lifetime of current HUD note
    if (current_note != NOTE_NONE && ++current_note_ticks > calc_ticks(MAX_NOTE_PLAYING_TIME)) {
        show_note(current_note, false);
        current_note = NOTE_NONE;
    }

    // Update combat / pattern effects
    if (combat_state == COMBAT_STATE_PLAYER_EFFECT)
    {
        if (updatePlayerPattern())
            dprintf(2,"Player pattern finished → state=%d\n", combat_state);
    }
    else if (combat_state == COMBAT_STATE_ENEMY_EFFECT &&
             combatContext.activeEnemy != ENEMY_NONE)
    {
        updateEnemyPattern(combatContext.activeEnemy);
    }
}

================
File: src/texts.c
================
#include "globals.h"

#define SIDE_LEFT true
#define SIDE_RIGHT false

// MAX TEXT LENGHT: "123456789012345678901234567890" (30 characters)

// Global variable definitions
u8 game_language=LANG_ENGLISH;

const DialogItem system_dialog[] = { // System messages
    {FACE_linus, SIDE_LEFT, DEFAULT_TALK_TIME, // 0
        {"No puedo usar ese patrón|ahora mismo", 
         "I can't use that pattern|right now"}},
    {FACE_none, SIDE_LEFT, DEFAULT_TALK_TIME, // 1
        {"The Weave|Demo técnica|Enero de 2025", 
         "The Weave|Tech demo|January 2025"}},
    {FACE_none, SIDE_LEFT, DEFAULT_TALK_TIME, // 2
        {"Los gráficos, mecánicas o sonidos|no son definitivos, ni|representan el resultado final", 
         "Graphics, mechanics or sounds|aren't final, nor they|represent the final result"}},
    {0, false, DEFAULT_TALK_TIME, {NULL, NULL}} // Terminator
};

const DialogItem act1_dialog1[] = { // Historians corridor
    {FACE_linus, SIDE_RIGHT, DEFAULT_TALK_TIME, // 0
        {"Creo que he dormido demasiado|Debo llegar rápido al salón", 
         "I think I've overslept|I should go to the hall quickly"}},
    {FACE_linus, SIDE_RIGHT, DEFAULT_TALK_TIME, // 1
        {"Aunque siendo el día que es|este pasillo me trae|demasiados recuerdos", 
         "Although in a day like this|this hallway brings back|too many memories"}},
    {FACE_linus, SIDE_RIGHT, DEFAULT_TALK_TIME, // 2
        {"Antes de irme quiero|repasar algunos recuerdos|Se lo debo a papá", 
         "Before I leave I want to|revisit some memories|I owe it to dad"}},        
    {FACE_linus, SIDE_RIGHT, DEFAULT_TALK_TIME, // 3
        {"Este tomo narra la historia|de nuestro gremio|desde la Gran Separación", 
        "This volume narrates the history|of our guild|since the Great Split"}},        
    {FACE_linus, SIDE_RIGHT, DEFAULT_TALK_TIME, // 4
        {"El último capítulo|termina con el fallecimiento|de mi padre", 
        "The last chapter|ends with the passing|of my father"}},       
    {FACE_linus, SIDE_RIGHT, DEFAULT_TALK_TIME, // 5
        {"Madre dice que seré yo|el que deba escribir|el siguiente", 
        "Mother says it will be me|who has to write|the next one"}},       
    {FACE_linus, SIDE_RIGHT, DEFAULT_TALK_TIME, // 6
        {"Una colección de|mitos y leyendas|de los distintos gremios", 
        "A collection of|myths and legends|from the different guilds"}},        
    {FACE_linus, SIDE_RIGHT, DEFAULT_TALK_TIME, // 7
        {"Gracias a mi padre|tenemos documentadas|las que cantaban los Pastores", 
        "Thanks to my father|we have documented|those the Shepherds sang"}},     
    {0, false, DEFAULT_TALK_TIME, {NULL, NULL}} // Terminator
};

const DialogItem act1_dialog2[] = { // Histoiran hall
    {FACE_none, SIDE_LEFT, DEFAULT_TALK_TIME, // 0
        {"Gremio de los historiadores|Año 8121", 
         "Historians guild|Year 8121"}},
    {FACE_none, SIDE_LEFT, DEFAULT_TALK_TIME, // 1
        {"Lunes|Primera hora de la mañana", 
         "Monday|Early morning"}},
    {FACE_clio, SIDE_LEFT, DEFAULT_TALK_TIME, // 2
        {"Es tarde, Linus|Y uno no debe llegar tarde|a su cumpleaños", 
         "It's late, Linus|And you shouldn't be late|at your birthday"}},
    {FACE_linus, SIDE_RIGHT, DEFAULT_TALK_TIME, // 3
        {"He tenido el sueño|más extraño, Madre", 
         "I have had the strangest|dream, Mother"}},
    {FACE_linus, SIDE_RIGHT, DEFAULT_TALK_TIME, // 4
        {"Un cisne venía a|mi cuarto y...", 
         "A swan came to my room|and..."}},
    {FACE_clio, SIDE_LEFT, DEFAULT_TALK_TIME, // 5
        {"Luego me lo cuentas|Xander nos espera", 
         "You can tell me later|Xander is waiting for us"}},
    {FACE_xander, SIDE_LEFT, DEFAULT_TALK_TIME, // 6
        {"Por fin|estás despierto, Linus", 
         "At last,|you're awake Linus"}},
    {FACE_linus, SIDE_RIGHT, DEFAULT_TALK_TIME, // 7
        {"Perdóname, maestro|Un extraño sueño me ha|mantenido despierto", 
         "Forgive me, master|A strange dream has|kept me awake"}},
    {FACE_xander, SIDE_LEFT, DEFAULT_TALK_TIME, // 8
        {"Ciertamente eres el|hijo de tu padre|Aiden tenía grandes sueños", 
         "You are certainly your|father's son|Aiden had big dreams"}},
    {FACE_xander, SIDE_LEFT, DEFAULT_TALK_TIME, // 9
        {"Y estamos aquí para hablar|sobre uno que|nunca llegó a cumplir", 
         "And we are here to talk|about one that he|never achieved"}},
    {FACE_linus, SIDE_RIGHT, DEFAULT_TALK_TIME, // 10
        {"He leído sus historias|mil veces|¿De cuál hablamos?", 
         "I've read his stories|a thousand times|Which one is this?"}},
    {FACE_xander, SIDE_LEFT, DEFAULT_TALK_TIME, // 11
        {"Una que no encontrarás en|un libro. La de la isla|del gremio de los Tejedores", 
         "One you won't find in a book|The one about Weavers|guild island"}},
    {FACE_xander, SIDE_LEFT, DEFAULT_TALK_TIME, // 12
        {"Según la leyenda|Fueron un gremio|capaz de tejer hechizos",
         "According to the legend|They were a guild|able to weave spells"}},
    {FACE_xander, SIDE_LEFT, DEFAULT_TALK_TIME, // 13
        {"Para él no era una leyenda|Los Pastores la cantaban|como cierta",
         "That was no legend for him|Shepherds sang it as a fact"}},
    {FACE_xander, SIDE_LEFT, DEFAULT_TALK_TIME, // 14
        {"Desaparecieron sin dejar rastro|Aunque muchos creen|que era solo un cuento",
         "They vanished without a trace|Although many believe|it was just a tale"}},
    {FACE_xander, SIDE_LEFT, DEFAULT_TALK_TIME, // 15
        {"Tu padre quería encontrar|la isla donde vivían", 
         "Your father wanted to find|their home island"}},
    {FACE_clio, SIDE_RIGHT, DEFAULT_TALK_TIME, // 16
        {"Nuestro destino es|documentar hechos,|no perseguirlos", 
         "Our destiny is to|document facts,|not to chase them"}},
    {FACE_xander, SIDE_LEFT, DEFAULT_TALK_TIME, // 17
        {"Linus tiene diecisiete años|Esa era mi edad cuando|viajé por el mundo", 
         "Linus is seventeen|That was my age when|I traveled the world"}},
    {FACE_xander, SIDE_LEFT, DEFAULT_TALK_TIME, // 18
        {"Y la edad de su padre cuando|llegó aquí", 
         "And his father's age when|he came to us"}},
    {FACE_xander, SIDE_LEFT, DEFAULT_TALK_TIME, // 19
        {"Un año antes de que|le acogiéramos|como uno de los nuestros", 
         "A year before we|took him as one of ours"}},
    {FACE_linus, SIDE_RIGHT, 100, // 20
        {"Madre...", 
         "Mother..."}},
    {FACE_clio, SIDE_LEFT, DEFAULT_TALK_TIME, // 21
        {"Si Xander lo quiere, así será|Pero no irás solo", 
         "If Xander wants it that way,|so it will be|But you'll not go alone"}},
    {FACE_clio, SIDE_LEFT, DEFAULT_TALK_TIME, // 22
        {"Nunca me ha gustado viajar|Pero no dejaré que vayas solo", 
         "I've never liked to travel|But I won't let you go alone"}},
    {0, false, DEFAULT_TALK_TIME, {NULL, NULL}} // Terminator
};

const DialogItem act1_dialog3[] = { // Combat zone
    {FACE_none, SIDE_LEFT, DEFAULT_TALK_TIME, // 0
        {"Algún tiempo después", 
         "Some time later"}},
    {FACE_linus, SIDE_LEFT, DEFAULT_TALK_TIME, // 1
        {"Se aproximan enemigos|Tenemos que estar atentos|Quédate cerca, madre",
         "Enemies are approaching|We have to stay alert|Stay close, mother"}},
     {FACE_linus, SIDE_LEFT, DEFAULT_TALK_TIME, // 2
         {"Eso ha dolido",
         "That hurts"}},
     {FACE_linus, SIDE_LEFT, DEFAULT_TALK_TIME, // 3
         {"Quizá deba pensar|al revés",
         "I should maybe|think backwards"}},
     {FACE_linus, SIDE_LEFT, DEFAULT_TALK_TIME, // 4
         {"Puedo probar a esconderme|o tratar de invocar|al trueno",
         "I could try to hide|or attempt to summon|the thunder"}},
    {FACE_none, SIDE_LEFT, DEFAULT_TALK_TIME, // 5
        {"Gracias por probar la demo técnica|Sígueme por X para estar al día|@GeeseBumpsGames", 
         "Thtanks for testing our tech demo|Follow me in X for updates|@GeeseBumpsGames"}},
     {FACE_linus, SIDE_LEFT, DEFAULT_TALK_TIME, // 6
         {"Si reproduzco al revés|las notas, podré|contraatacar este hechizo",
         "If I play the notes backwards|I could be able to|counter the spell"}},
    {FACE_none, SIDE_LEFT, DEFAULT_TALK_TIME, // 7
        {"Apaga tu consola|y haz algo constructivo|como jugar un poco al frontón", 
         "Turn off your console|and do something constructive|like play a little racquetball"}},
    {FACE_none, SIDE_LEFT, DEFAULT_TALK_TIME, // 8
        {"o preparar la cena,|o organizar tu cajón de calcetines|alfabéticamente.", 
         "or cook dinner,|or organize your sock drawer|alphabetically."}},
     {FACE_linus, SIDE_LEFT, DEFAULT_TALK_TIME, // 9
         {"No puedo lanzar hechizos|si estoy escondido",
         "I can't launch spells|while hiding"}},
    {FACE_none, SIDE_LEFT, DEFAULT_TALK_TIME, // 10
        {"¡Esto es todo!|(por ahora)", 
         "That's all!|(by now)"}},
    {FACE_none, SIDE_LEFT, DEFAULT_TALK_TIME, // 11
        {"NOTA: Ni esta escena ni estos|gráficos estarán en el|juego cuando esté terminado", 
         "NOTE: Neither that scene nor those|graphics will be present|in the game when it's finished"}},
    {FACE_none, SIDE_LEFT, DEFAULT_TALK_TIME, // 12
        {"Se ha decidido incluirla|en esta demo técnica|como prueba de ciertas mecánicas", 
         "It's been decided to include it|in this technical demo|as a test of certain mechanics"}},
    {FACE_none, SIDE_LEFT, DEFAULT_TALK_TIME, // 13
        {"Pulsa START para ver|tu inventario de hechizos", 
         "Press START to view|your spell inventory"}},
    {0, false, DEFAULT_TALK_TIME, {NULL, NULL}} // Terminator
};

const DialogItem act1_dialog4[] = { // Linus bedroom
    {FACE_swan, SIDE_LEFT, DEFAULT_TALK_TIME, // 0
        {"Han pasado ya cien años",
        "A hundred years have passed"}},
    {FACE_swan, SIDE_LEFT, DEFAULT_TALK_TIME, // 1
        {"No podremos pararles|por mucho más tiempo",
        "We won't be able to|stop them for much longer"}},
    {FACE_none, SIDE_LEFT, DEFAULT_TALK_TIME, // 2
        {"A la mañana siguiente...",
        "The next morning..."}},
    {FACE_linus, SIDE_LEFT, DEFAULT_TALK_TIME, // 3
        {"He dormido regular esta noche|Tuve horribles pesadillas",
        "I've not slept well last night|I had terrible nightmares"}},
    {FACE_linus, SIDE_LEFT, DEFAULT_TALK_TIME, // 4
        {"No ha podido ser real|La ventana está cerrada",
        "It couldn't be real|The windows is closed"}},
    {FACE_linus, SIDE_LEFT, DEFAULT_TALK_TIME, // 5
        {"No tengo tiempo de sentarme|Madre me espera",
        "I don't have time to sit down|Mother wating for me"}},
    {FACE_linus, SIDE_LEFT, DEFAULT_TALK_TIME, // 6
        {"Esta es la nana que me|cantaban cada noche",
        "That's the lullaby they used|to sing to me every night"}},
    {FACE_none, SIDE_LEFT, DEFAULT_TALK_TIME, // 7
        {"Has aprendido|tu primer patrón",
        "You have learned|your first pattern"}},
    {FACE_none, SIDE_LEFT, DEFAULT_TALK_TIME, // 8
        {"Entra en el menú de|pausa para verlo",
        "Enter the pause menu|to check it out"}},
    {FACE_clio, SIDE_RIGHT, DEFAULT_TALK_TIME, // 9
        {"Linus, ¿dónde estás?",
        "Linus, where are you?"}},
    {FACE_linus, SIDE_LEFT, DEFAULT_TALK_TIME, // 10
        {"Se me ha hecho demasiado tarde|tengo que ir al salón",
        "It's gotten too late|I need to go the hall"}},
    {0, false, DEFAULT_TALK_TIME, {NULL, NULL}} // Terminator
};

const DialogItem *dialogs[] = {
    system_dialog,  // 0
    act1_dialog1,   // 1
    act1_dialog2,   // 2
    act1_dialog3,   // 3
    act1_dialog4,   // 4
};

const ChoiceItem act1_choice1[] = {
    {FACE_linus, SIDE_RIGHT, DEFAULT_CHOICE_TIME, 3,
        {{ "¿Los Tejedores?", "Era mi leyenda favorita", "¿Qué pasó con ellos?"},
        { "The Weavers?", "It was my favourite legend", "What happened to them?"}}},
    {FACE_linus, SIDE_RIGHT, DEFAULT_CHOICE_TIME, 2,
        {{ "Tengo que ir a la isla", "¿Vendrías conmigo?"},
        { "I have to go to the island", "Would you come with me?"}}},
    {0, false, DEFAULT_TALK_TIME, 0, {{NULL}}} // Terminator
};

const ChoiceItem *choices[] = {
    act1_choice1,   // 0
};

 // Code Spanish text in the game font charset
// SPANISH CHARSET
// ñ --> ^
// á --> #
// é --> $
// í --> %
// ó --> *
// ú --> /
// < --> ¿
// > --> ¡

u16 calculate_text_position(const char *text, bool is_face_left, bool has_face) {
    u16 base_pos = 8; // Default left padding when face is present
    u16 max_width = has_face ? 33 : 40; // Available characters based on face presence
    
    u16 text_length = strlen(text);
    u16 centered_pos = (max_width - text_length) >> 1; // (width - len)/2 using bit shift
    
    if (has_face && !is_face_left) {
        base_pos -= 8; // Adjust for right-positioned face
    } else if (!has_face) {
        base_pos = 0; // No face, full width centering
    }
    
    return base_pos + centered_pos;
}

char* encode_spanish_text(const char* input) {
    if (input == NULL) {
        return NULL;
    }

    size_t len = strlen(input);
    char* result = (char*)malloc(len + 1); // +1 for the null terminator
    if (result == NULL) {
        return NULL; // Memory allocation failed
    }

    size_t i = 0;
    size_t j = 0;
    while (i < len) {
        if ((unsigned char)input[i] == 0xC3) {
            // This is a two-byte UTF-8 sequence
            if (i + 1 < len) {
                switch ((unsigned char)input[i + 1]) {
                    case 0xB1: // ñ
                    case 0x91: // Ñ
                        result[j] = '^';
                        break;
                    case 0xA1: // á
                    case 0x81: // Á
                        result[j] = '#';
                        break;
                    case 0xA9: // é
                    case 0x89: // É
                        result[j] = '$';
                        break;
                    case 0xAD: // í
                    case 0x8D: // Í
                        result[j] = '%';
                        break;
                    case 0xB3: // ó
                    case 0x93: // Ó
                        result[j] = '*';
                        break;
                    case 0xBA: // ú
                    case 0x9A: // Ú
                        result[j] = '/';
                        break;
                    default:
                        // If it's not a special character, copy both bytes
                        result[j] = input[i];
                        j++;
                        result[j] = input[i + 1];
                }
                i += 2; // Skip the next byte as we've already processed it
            } else {
                // Unexpected end of string, just copy the byte
                result[j] = input[i];
                i++;
            }
        } else if ((unsigned char)input[i] == 0xC2) {
            // This is a two-byte UTF-8 sequence for ¿ and ¡
            if (i + 1 < len) {
                switch ((unsigned char)input[i + 1]) {
                    case 0xBF: // ¿
                        result[j] = '<';
                        break;
                    case 0xA1: // ¡
                        result[j] = '>';
                        break;
                    default:
                        // If it's not a special character, copy both bytes
                        result[j] = input[i];
                        j++;
                        result[j] = input[i + 1];
                }
                i += 2; // Skip the next byte as we've already processed it
            } else {
                // Unexpected end of string, just copy the byte
                result[j] = input[i];
                i++;
            }
        } else {
            // Regular ASCII character, just copy it
            result[j] = input[i];
            i++;
        }
        j++;
    }
    result[j] = '\0'; // Ensure null-termination

    return result;
}

================
File: src/characters.c
================
#include "globals.h"

Entity obj_character[MAX_CHR];         // Array of game characters with their properties
Sprite *spr_chr[MAX_CHR];             // Array of character sprites
Sprite *spr_chr_shadow[MAX_CHR];      // Array of character shadow sprites
u16 active_character;                 // Currently controlled character ID
Entity obj_face[MAX_FACE];            // Array of character face entities for dialogs
Sprite *spr_face[MAX_FACE];           // Array of character face sprites

void update_character_shadow(u16 nchar)    // Update shadow sprite position based on character position
{
    if (obj_character[nchar].drops_shadow && spr_chr_shadow[nchar] != NULL) {
        // Position shadow at the bottom of character's collision box
        s16 shadow_x = obj_character[nchar].x;  // Center shadow (24/2 = 12)
        s16 shadow_y = obj_character[nchar].y + obj_character[nchar].collision_y_offset - 4;      // Place at bottom (8/2 = 4)
        
        // Flip shadow if character is looking to the left
        SPR_setHFlip(spr_chr_shadow[nchar], obj_character[nchar].flipH);

        // Set shadow position
        SPR_setPosition(spr_chr_shadow[nchar], shadow_x, shadow_y);
    }
}

void init_character(u16 nchar)    // Create new character instance with sprites and collision
{
    u8 npal = PAL1;
    u8 x_size, y_size; // We can get them from the Sprite Definition
    u8 collision_x_offset=0;
    u8 collision_y_offset=0;
    u8 collision_width=0;
    u8 collision_height=0;
    bool drops_shadow=true;
    const SpriteDefinition *nsprite = NULL;
    const SpriteDefinition *nsprite_shadow = NULL;

    dprintf(2,"Initializing character %d\n", nchar);

    if (obj_character[nchar].sd == NULL) {
        switch (nchar)
        {
        case CHR_linus:
            if (player_has_rod) nsprite = &linus_sprite;
            else nsprite = &linus_norod_sprite;
            nsprite_shadow = &linus_shadow_sprite;
            break;
        case CHR_clio:
            nsprite = &clio_sprite;
            nsprite_shadow = &clio_shadow_sprite;
            break;
        case CHR_xander:
            nsprite = &xander_sprite;
            nsprite_shadow = &xander_shadow_sprite;
            break;
        case CHR_swan:
            nsprite = &swan_sprite;
            drops_shadow = false;
            break;
        default:
            return; 
        }
        
        x_size=nsprite->w; // Get width and height from the Sprite Definition
        y_size=nsprite->h;

        // Set default collision box if not defined
        if (collision_width==0) collision_width=x_size/2; // Half width size
        if (collision_x_offset==0) collision_x_offset=x_size/4; // Centered in X
        if (collision_height==0) collision_height=2; // Two lines height
        if (collision_y_offset==0) collision_y_offset=y_size-1; // At the feet

        obj_character[nchar] = (Entity) { true, nsprite, nsprite_shadow, 0, 0, x_size, y_size, npal, false, false, ANIM_IDLE, false, collision_x_offset, collision_y_offset, collision_width, collision_height, STATE_IDLE, FALSE, 0, drops_shadow };
    } else {
        nsprite = obj_character[nchar].sd;
        nsprite_shadow = obj_character[nchar].sd_shadow;
        npal = obj_character[nchar].palette;
        obj_character[nchar].active=true;
    }

    dprintf(2,"Adding sprite for character %d at (%d, %d)\n", nchar, obj_character[nchar].x, obj_character[nchar].y);
    spr_chr[nchar] = SPR_addSpriteSafe(nsprite, obj_character[nchar].x, obj_character[nchar].y, 
                                       TILE_ATTR(npal, obj_character[nchar].priority, false, obj_character[nchar].flipH));

    if (spr_chr[nchar] != NULL) {
        SPR_setVisibility(spr_chr[nchar], HIDDEN);
    }

    // Initialize shadow if character drops one
    if (obj_character[nchar].drops_shadow) {
        dprintf(2,"Adding shadow sprite for character %d\n", nchar);
        spr_chr_shadow[nchar] = SPR_addSpriteSafe(nsprite_shadow, 0, 0, TILE_ATTR(PAL1, TRUE, FALSE, FALSE));
        
        if (spr_chr_shadow[nchar] != NULL) {
            SPR_setVisibility(spr_chr_shadow[nchar], HIDDEN);
            SPR_setDepth(spr_chr_shadow[nchar], SPR_MAX_DEPTH); // Shadow always at back
            update_character_shadow(nchar);
        }
    }
}

void release_character(u16 nchar)    // Free character sprite resources but keep entity data
{
    obj_character[nchar].active = false;
    obj_character[nchar].sd = NULL;
    obj_character[nchar].sd_shadow = NULL;
    if (spr_chr[nchar] != NULL)
    {
        SPR_releaseSprite(spr_chr[nchar]);
        spr_chr[nchar] = NULL;
    }
    
    // Release shadow if it exists
    if (spr_chr_shadow[nchar] != NULL)
    {
        SPR_releaseSprite(spr_chr_shadow[nchar]);
        spr_chr_shadow[nchar] = NULL;
    }
    
    // Update sprite engine after releasing sprites
    SPR_update();
}

void init_face(u16 nface)    // Create new character face sprite for dialogs
{
    u8 npal = PAL1;
    const SpriteDefinition *nsprite = NULL;

    if (obj_face[nface].sd == NULL) { // Object never initialized
        switch (nface)
        {
        case CHR_linus:
            nsprite = &linus_face_sprite;        
            break;
        case CHR_clio:
            nsprite = &clio_face_sprite;
            break;
        case CHR_xander:
            nsprite = &xander_face_sprite;
            break;
        case CHR_swan:
            nsprite = &swan_face_sprite;
            break;
        default:
            return;
        }
        obj_face[nface] = (Entity) { true, nsprite, NULL, 0, 160, 64, 64, npal, false, false, ANIM_IDLE, false, 0, 0, 0, 0, STATE_IDLE, FALSE, 0, false };
    } else {
        nsprite = obj_face[nface].sd;
        obj_face[nface].active=true;
    }

    spr_face[nface] = SPR_addSpriteSafe(nsprite, obj_face[nface].x, obj_face[nface].y, 
                                        TILE_ATTR(obj_face[nface].palette, obj_face[nface].priority, false, obj_face[nface].flipH));
    
    if (spr_face[nface] != NULL) {
        SPR_setVisibility(spr_face[nface], HIDDEN);
        SPR_setDepth(spr_face[nface], SPR_MIN_DEPTH); // Faces are above any other sprite
    }
}

void release_face(u16 nface)    // Free face sprite resources but keep entity data
{
    obj_face[nface].active = false;
    if (spr_face[nface] != NULL)
    {
        SPR_releaseSprite(spr_face[nface]);
        spr_face[nface] = NULL;
    }
}

void update_character(u16 nchar)    // Update character sprite properties from current state
{
    SPR_setPosition(spr_chr[nchar],obj_character[nchar].x,obj_character[nchar].y);
    SPR_setPriority(spr_chr[nchar],obj_character[nchar].priority);
    SPR_setVisibility(spr_chr[nchar],obj_character[nchar].visible?VISIBLE:HIDDEN);
    SPR_setHFlip(spr_chr[nchar],obj_character[nchar].flipH);
    SPR_setAnim(spr_chr[nchar],obj_character[nchar].animation);
    update_character_shadow(nchar);
}

void show_character(u16 nchar, bool show)    // Toggle visibility of character and its shadow
{
    obj_character[nchar].visible=show;
    SPR_setVisibility(spr_chr[nchar],show?VISIBLE:HIDDEN);
    
    // Update shadow visibility if it exists
    if (obj_character[nchar].drops_shadow && spr_chr_shadow[nchar] != NULL) {
        SPR_setVisibility(spr_chr_shadow[nchar],show?VISIBLE:HIDDEN);
    }
    
    SPR_update();
}

void anim_character(u16 nchar, u8 newanimation)    // Set character animation if different from current
{
    if (obj_character[nchar].animation!=newanimation) {
        obj_character[nchar].animation=newanimation;
        SPR_setAnim(spr_chr[nchar],obj_character[nchar].animation);
        SPR_update();
    }
}

void look_left(u16 nchar, bool direction_right)    // Set character sprite horizontal flip
{
    obj_character[nchar].flipH=direction_right;
    SPR_setHFlip (spr_chr[nchar], direction_right);
    SPR_update();
}

void move_character(u16 nchar, s16 newx, s16 newy)    // Move character with walking animation and direction update
{
    show_character(nchar, true);
    anim_character(nchar, ANIM_WALK);

    // Look in the appropriate direction
    s16 dx = newx - obj_character[nchar].x;
    if (dx < 0) {
        look_left(nchar, true);
    } else if (dx > 0) {
        look_left(nchar, false);
    }

    move_entity(&obj_character[nchar], spr_chr[nchar], newx, newy);
    anim_character(nchar, ANIM_IDLE);
}

void move_character_instant(u16 nchar,s16 x,s16 y)    // Set character position immediately without animation
{
    y-=obj_character[nchar].y_size; // Now all calculations are relative to the bottom line, not the upper one

    SPR_setPosition(spr_chr[nchar], x, y);
    obj_character[nchar].x = x;
    obj_character[nchar].y = y;
    update_character_shadow(nchar);
    next_frame(false);
}

void update_sprites_depth(void)    // Sort sprite layers based on Y position for proper overlap
{
    u16 i;

    // Update character depth
    for (i = 0; i < MAX_CHR; i++) {
        if (obj_character[i].active==true) {
            SPR_setDepth(spr_chr[i], -obj_character[i].y-obj_character[i].y_size); // Negative of the bottom line of the sprite
        }
    }

    // Update items depth
    for (i = 0; i < MAX_ITEMS; i++) {
        if (obj_item[i].entity.active==true && spr_item[i]!=NULL) {
            if (obj_item[i].check_depth==FORCE_BACKGROUND) {
                SPR_setDepth(spr_item[i], SPR_MAX_DEPTH); // Background items are always at the back
            } else if (obj_item[i].check_depth==FORCE_FOREGROUND) {
                SPR_setDepth(spr_item[i], SPR_MIN_DEPTH+100); // Foreground items are always at the front (add 100 so it doesn't interfere with frontend interface items)
            } else {
                SPR_setDepth(spr_item[i], -obj_item[i].entity.y-obj_item[i].entity.y_size); // Negative of the bottom line of the sprite
            }
        }
    }

    // Update enemies depth
    for (i = 0; i < MAX_ENEMIES; i++) {
        if (obj_enemy[i].obj_character.active==true) {
            SPR_setDepth(spr_enemy[i], -obj_enemy[i].obj_character.y-obj_enemy[i].obj_character.y_size); // Negative of the bottom line of the sprite
        }
    }
}

void follow_active_character(u16 nchar, bool follow, u8 follow_speed)    // Set character to follow active character
{
    obj_character[nchar].follows_character=follow;
    obj_character[nchar].follow_speed=follow_speed;
    obj_character[nchar].state=STATE_FOLLOWING;
    show_character(nchar, true);
}

void approach_characters(void)    // Update positions of following characters to move toward active character
{
    u16 nchar;
    s16 newx, newy;
    s16 dx, dy;
    bool has_moved;
    u16 distance;

    for (nchar = 0; nchar < MAX_CHR; nchar++)
    {
        // Skip if this is the active character
        if (nchar == active_character)
        {
            continue;
        }

        has_moved = false;
        // Check if character is active and in following state
        if (obj_character[nchar].active && obj_character[nchar].follows_character == true)
        {
            // Delay movement by follow_speed
            if (frame_counter % obj_character[nchar].follow_speed == 0)
            {
                // Calculate direction towards active character
                dx = obj_character[active_character].x - obj_character[nchar].x;
                dy = (obj_character[active_character].y + obj_character[active_character].y_size) -
                     (obj_character[nchar].y + obj_character[nchar].y_size);

                // Move by 1 pixel in the calculated direction
                newx = obj_character[nchar].x + (dx != 0 ? (dx > 0 ? 1 : -1) : 0);
                newy = obj_character[nchar].y + (dy != 0 ? (dy > 0 ? 1 : -1) : 0);

                // Check distance to active character at new position
                distance = char_distance(nchar, newx, newy, active_character);

                // Start moving when distance >MAX_FOLLOW_DISTANCE, keep moving until distance >MIN_FOLLOW_DISTANCE
                if ((obj_character[nchar].animation == ANIM_IDLE && distance > MAX_FOLLOW_DISTANCE) || (obj_character[nchar].animation == ANIM_WALK && distance > MIN_FOLLOW_DISTANCE))
                {
                    // Update character position and animation
                    // Update entity properties
                    obj_character[nchar].x = newx;
                    obj_character[nchar].y = newy;
                    obj_character[nchar].flipH = (dx < 0);

                    // Update sprite properties directly
                    SPR_setPosition(spr_chr[nchar], newx, newy);
                    SPR_setHFlip(spr_chr[nchar], dx < 0);

                    // Update shadow position
                    if (obj_character[nchar].drops_shadow && spr_chr_shadow[nchar] != NULL)
                    {
                        s16 shadow_y = newy + obj_character[nchar].collision_y_offset - 4;
                        SPR_setPosition(spr_chr_shadow[nchar], newx, shadow_y);
                        SPR_setHFlip(spr_chr_shadow[nchar], dx < 0);
                    }

                    // Update animation if needed
                    if (obj_character[nchar].animation == ANIM_IDLE)
                    {
                        obj_character[nchar].animation = ANIM_WALK;
                        SPR_setAnim(spr_chr[nchar], ANIM_WALK);
                    }
                    has_moved = true;
                }

                // Set to idle if close enough or not moved
                if (distance <= MIN_FOLLOW_DISTANCE)
                {
                    anim_character(nchar, ANIM_IDLE);
                }
                else if (!has_moved && obj_character[nchar].state == STATE_FOLLOWING)
                {
                    anim_character(nchar, ANIM_IDLE);
                }
            }
        }
    }

    // Update sprite depths after movement
    update_sprites_depth();
}

void reset_character_animations()
{
    for (u16 i = 0; i < MAX_CHR; i++)
    {
        if (obj_character[i].active && i != active_character)
        {
            anim_character(i, ANIM_IDLE);
            obj_character[i].state = STATE_IDLE;
        }
    }

    for (u16 nenemy = 0; nenemy < MAX_ENEMIES; nenemy++)
    {
        if (obj_enemy[nenemy].obj_character.active)
        {
            // anim_enemy(nenemy, ANIM_IDLE);
            // obj_enemy[nenemy].obj_character.state = STATE_IDLE;
        }
    }
}

================
File: src/main.c
================
#include "globals.h"


int main(bool hard)    // Main game loop - handles initialization and scene transitions
{
    #ifdef DEBUG_ON
     dprintf(2,"The Weave - %s",GAMEVERSION);
     dprintf(2,"https://geese-bumps.itch.io/\n\n");
    #endif

    //geesebumps_logo(); // GeeseBumps Logo
    //theweave_intro();  // Game intro

    initialize(true);

    current_act=1;
    current_scene=5;

    dprintf(2,"Loading Act %d, Scene %d\n", current_act, current_scene);
    while (true) { // MAIN LOOP
        switch (current_act)
        {
        case 1: // FIRST ACT
            switch (current_scene)
            {
            case 1:
                act_1_scene_1(); // ACT 1 - scene 1
                break;
            case 2:
                act_1_scene_2(); // ACT 1 - scene 2
                break;
            case 3:
                act_1_scene_3(); // ACT 1 - scene 3
                break;
            case 5:
                act_1_scene_5(); // ACT 1 - scene 5
                break;
            default:
                break;
            }
            break;
        default:
            break;
        }
    }
}

================
File: src/act_1.c
================
#include "globals.h"

void act_1_scene_1(void)    // Bedroom scene with swan's visit and pattern learning
{
    u16 paltmp[64];

    // Initialize level
    new_level(&bedroom_bg_tile, &bedroom_bg_map, &bedroom_front_tile, &bedroom_front_map, bedroom_night_pal, SCREEN_WIDTH, BG_SCRL_AUTO_RIGHT, 3);
    set_limits(20,145,278,176);

    // Use swan palette instead of characters palette
    PAL_setPalette(PAL1, swan_pal.data, DMA);

    // Initialize characters and dialog faces
    init_character(CHR_swan);
    init_character(CHR_linus);

    // Initialize items
    init_item(0, &item_bedroom_bed, PAL0, 31, 139, 93, 0, 23, 0, FORCE_BACKGROUND); // Bed
    init_item(1, &item_bedroom_chair, PAL0, 236, 110, 26, 0, 43, 0, FORCE_BACKGROUND); // Chair
    init_item(2, &item_bedroom_windowsill, PAL0, 125, 121, 99, 0, 22, 0, FORCE_BACKGROUND); // Windowsill
    init_item(3, &item_bedroom_cabinet, PAL0, 270, 79, 51, 0, 82, 0, FORCE_BACKGROUND); // Cabinet and sheet music
    init_item(4, &item_bedroom_linus_sleeping, PAL0, 30, 112, 0, 0, 0, 0, FORCE_BACKGROUND); // Linus sleeping

    // Flash to white, show swan, fade back
    wait_seconds(2);
    PAL_getColors(0, paltmp, 64); // backup current palete
    play_sample(snd_effect_magic_appear, sizeof(snd_effect_magic_appear)); // something magically appearing sound effect
    PAL_fadeToAll(geesebumps_pal_white.data, SCREEN_FPS, false); // fade to white
    move_character_instant(CHR_swan,141,110);
    show_character(CHR_swan, true); // show swan
    PAL_fadeToAll(paltmp, SCREEN_FPS, false); // fade to night palete
    wait_seconds(2);

    // Dialog
    talk_dialog(&dialogs[ACT1_DIALOG4][0]); // (ES) "Han pasado ya cien años" - (EN) "A hundred years have passed"
    talk_dialog(&dialogs[ACT1_DIALOG4][1]); // (ES) "No podremos pararles|por mucho más tiempo" - (EN) "We won't be able to|stop them for much longer"

    // Flash to white, hide swan, fade back
    wait_seconds(2);
    PAL_getColors(0, paltmp, 64); // backup current palete
    play_sample(snd_effect_magic_disappear, sizeof(snd_effect_magic_disappear)); // something magically disappearing sound effect
    PAL_fadeToAll(geesebumps_pal_white.data, SCREEN_FPS, false); // fade to white
    show_character(CHR_swan, false); // hide swan
    PAL_fadeToAll(paltmp, SCREEN_FPS, false); // fade to palete
    wait_seconds(2);
    
    // Daytime
    PAL_fadeTo(0, 15, bedroom_pal.data, SCREEN_FPS, false);

    // Dialog
    talk_dialog(&dialogs[ACT1_DIALOG4][2]); // (ES) "A la mañana siguiente..." - (EN) "The next morning..."

    // Wake linus up
    release_item(4);
    PAL_setPalette(PAL1, characters_pal.data, DMA);
    move_character_instant(CHR_linus, 35, 175);
    show_character(CHR_linus, true);
    
    // You can move
    player_scroll_active=true;
    movement_active=true;

    bool item_interacted[4]={false,false,false,false};
    bool scene_timeout=0;
    while (scene_timeout<(SCREEN_FPS*3)) // Scene ends 3 seconds after interacting every object
    {
        switch (pending_item_interaction) // Process item interactions
        {
        case 0: // Bed
            talk_dialog(&dialogs[ACT1_DIALOG4][3]); // (ES) "He dormido regular esta noche|Tuve horribles pesadillas" - (EN) "I've not slept well last night|I had terrible nightmares"
            pending_item_interaction=ITEM_NONE;
            item_interacted[0]=true;
            break;
        case 1: // Chair
            talk_dialog(&dialogs[ACT1_DIALOG4][5]); // (ES) "No tengo tiempo de sentarme|Madre me espera" - (EN) "I don't have time to sit down|Mother wating for me"
            pending_item_interaction=ITEM_NONE;
            item_interacted[1]=true;
            break;
        case 2: // Windowsill
            talk_dialog(&dialogs[ACT1_DIALOG4][4]); // (ES) "No ha podido ser real|La ventana está cerrada" - (EN) "It couldn't be real|The windows is closed"
            pending_item_interaction=ITEM_NONE;
            item_interacted[2]=true;
            break;
        case 3: // Cabinet
            talk_dialog(&dialogs[ACT1_DIALOG4][6]); // (ES) "Esta es la nana que me|cantaban cada noche" - (EN) "That's the lullaby they used|to sing to me every night"
            pending_item_interaction=ITEM_NONE;
            // if (obj_pattern[PTRN_SLEEP].active==false) {
            //     activate_spell(PTRN_SLEEP);
            //     talk_dialog(&dialogs[ACT1_DIALOG4][7]); // (ES) "Has aprendido|tu primer patrón" - (EN) "You have learned|your first pattern"
            //     talk_dialog(&dialogs[ACT1_DIALOG4][8]); // (ES) "Entra en el menú de|pausa para verlo" - (EN) "Enter the pause menu|to check it out"
            // }
            item_interacted[3]=true;
            break;
        default:
            break;
        }
        if (item_interacted[0]==true && item_interacted[1]==true && item_interacted[2]==true && item_interacted[3]==true) scene_timeout++;
        next_frame(true);
    }
    talk_dialog(&dialogs[ACT1_DIALOG4][9]); // (ES) "Linus, ¿dónde estás?" - (EN) "Linus, where are you?"
    talk_dialog(&dialogs[ACT1_DIALOG4][10]); // (ES) "Se me ha hecho demasiado tarde|tengo que ir al salón" - (EN) "It's gotten too late|I need to go the hall"

    end_level(); // Free resources
    current_scene=2; // Next scene
}

void act_1_scene_2(void)    // Corridor scene with history books and memories
{
    // Initialize level
    new_level(NULL, NULL, &historians_corridor_front_tile, &historians_corridor_front_map, historians_corridor_pal, 576, BG_SCRL_USER_LEFT, 0);
    set_limits(0,131,275,170);

    // Initialize items
    init_item(0, &item_corridor_bookpedestal_sprite, PAL0, 400, 90, COLLISION_DEFAULT, COLLISION_DEFAULT, 8, 58, CALCULATE_DEPTH); // Guild history book
    init_item(1, &item_corridor_bookpedestal_sprite, PAL0, 200, 90, COLLISION_DEFAULT, COLLISION_DEFAULT, 8, 58, CALCULATE_DEPTH); // Myths and legends

    // Initialize characters and dialog faces
    init_character(CHR_linus);

    // Tech demo warning message
    talk_dialog(&dialogs[SYSTEM_DIALOG][1]); // (ES) "The Weave|Demo técnica|Enero de 2025" - (EN) "The Weave|Tech demo|January 2025"
    talk_dialog(&dialogs[SYSTEM_DIALOG][2]); // (ES) "Los gráficos, mecánicas o sonidos|no son definitivos, ni|representan el resultado final" - (EN) "Graphics, mechanics or sounds|aren't final, nor they|represent the final result"

    // Put character in screen
    move_character_instant(CHR_linus, 340, 154);
    move_character(CHR_linus, 270, 154);

    // Dialog
    talk_dialog(&dialogs[ACT1_DIALOG1][0]); // (ES) "Creo que he dormido demasiado|Debo llegar rápido al salón" - (EN) "I think I've overslept|I should go to the hall quickly"
    talk_dialog(&dialogs[ACT1_DIALOG1][1]); // (ES) "Aunque siendo el día que es|este pasillo me trae|demasiados recuerdos" - (EN) "Although in a day like this|this hallway brings back|too many memories"

    // You can move
    player_scroll_active=true;
    movement_active=true;

    bool item_interacted[2]={false, false};
    while (true) {
        switch (pending_item_interaction) // Process item interactions
        {
        case 0: // Guild history book
            talk_dialog(&dialogs[ACT1_DIALOG1][3]); // (ES) "Este tomo narra la historia|de nuestro gremio|desde la Gran Separación" - (EN) "This volume narrates the history|of our guild|since the Great Split"
            talk_dialog(&dialogs[ACT1_DIALOG1][4]); // (ES) "El último capítulo|termina con el fallecimiento|de mi padre" - (EN) "The last chapter|ends with the passing|of my father"
            talk_dialog(&dialogs[ACT1_DIALOG1][5]); // (ES) "Madre dice que seré yo|el que deba escribir|el siguiente" - (EN) "Mother says it will be me|who has to write|the next one"
            item_interacted[0]=true;
            pending_item_interaction=ITEM_NONE;
            break;
        case 1: // Myths and legends
            talk_dialog(&dialogs[ACT1_DIALOG1][6]); // (ES) "Una colección de|mitos y leyendas|de los distintos gremios" - (EN) "A collection of|myths and legends|from the different guilds"
            talk_dialog(&dialogs[ACT1_DIALOG1][7]); // (ES) "Gracias a mi padre|tenemos documentadas|las que cantaban los Pastores" - (EN) "Thanks to my father|we have documented|those the Shepherds sang"
            item_interacted[1]=true;
            pending_item_interaction=ITEM_NONE;
            break;
        default:
            break;
        }

        if (offset_BGA<=1 && obj_character[active_character].x<=1) { // Players try to exit screen
            if (item_interacted[0]==false || item_interacted[1]==false) { // We han't read every book
                talk_dialog(&dialogs[ACT1_DIALOG1][2]); // (ES) "Antes de irme quiero|repasar algunos recuerdos|Se lo debo a papá" - (EN) "Before I leave I want to|revisit some memories|I owe it to dad"
                move_character(active_character,20,obj_character[active_character].y+obj_character[active_character].y_size); // Go backwards
            }
            else break; // We have read it --> exit
        }

        next_frame(true);
    }

    move_character(active_character,-30,obj_character[active_character].y+obj_character[active_character].y_size);

    end_level(); // Free resources
    current_scene=3; // Next scene
}

void act_1_scene_3(void)    // Hall scene with Clio and Xander discussing Weavers
{
    // Initialize level
    new_level(&historians_bg_tile, &historians_bg_map, &historians_front_tile, &historians_front_map, historians_pal, SCREEN_WIDTH, BG_SCRL_AUTO_RIGHT, 3);
    
    // Initialize characters and dialog faces
    init_character(CHR_linus);
    init_character(CHR_clio);
    init_character(CHR_xander);
    
    // Starting positions
    move_character_instant(CHR_clio,40,174);
    move_character_instant(CHR_linus,360,164);
    look_left(CHR_clio,false);
    look_left(CHR_linus,true);
    show_character(CHR_clio, true);
    show_character(CHR_linus, true);
       
    // Dialog
    talk_dialog(&dialogs[ACT1_DIALOG2][0]); // (ES) "Gremio de los historiadores|Año 8121" - (EN) "Historians guild|Year 8121"
    talk_dialog(&dialogs[ACT1_DIALOG2][1]); // (ES) "Lunes|Primera hora de la mañana" - (EN) "Monday|Early morning"
    move_character(CHR_linus, 200, 174);
    talk_dialog(&dialogs[ACT1_DIALOG2][2]); // (ES) "Es tarde, Linus|Y uno no debe llegar tarde|a su cumpleaños" - (EN) "It's late, Linus|And you shouldn't be late|at your birthday"
    talk_dialog(&dialogs[ACT1_DIALOG2][3]); // (ES) "He tenido el sueño|más extraño, Madre" - (EN) "I have had the strangest|dream, Mother"
    talk_dialog(&dialogs[ACT1_DIALOG2][4]); // (ES) "Un cisne venía a|mi cuarto y..." - (EN) "A swan came to my room|and..."
    talk_dialog(&dialogs[ACT1_DIALOG2][5]); // (ES) "Luego me lo cuentas|Xander nos espera" - (EN) "You can tell me later|Xander is waiting for us"
    // Xander's entrance
    move_character(CHR_clio, 100, 154);
    wait_seconds(1);
    look_left(CHR_clio, true);
    move_character_instant(CHR_xander,-30,174);
    show_character(CHR_xander, true);
    move_character(CHR_xander, 40, 174);
    talk_dialog(&dialogs[ACT1_DIALOG2][6]); // (ES) "Por fin|estás despierto, Linus" - (EN) "At last,|you're awake Linus"
    talk_dialog(&dialogs[ACT1_DIALOG2][7]); // (ES) "Perdóname, maestro|Un extraño sueño me ha|mantenido despierto" - (EN) "Forgive me, master|A strange dream has|kept me awake"
    talk_dialog(&dialogs[ACT1_DIALOG2][8]); // (ES) "Ciertamente eres el|hijo de tu padre|Aiden tenía grandes sueños" - (EN) "You are certainly your|father's son|Aiden had big dreams"
    talk_dialog(&dialogs[ACT1_DIALOG2][9]); // (ES) "Y estamos aquí para hablar|sobre uno que|nunca llegó a cumplir" - (EN) "And we are here to talk|about one that he|never achieved"
    talk_dialog(&dialogs[ACT1_DIALOG2][10]); // (ES) "He leído sus historias|mil veces|¿De cuál hablamos?" - (EN) "I've read his stories|a thousand times|Which one is this?"
    talk_dialog(&dialogs[ACT1_DIALOG2][11]); // (ES) "Una que no encontrarás en|un libro. La de la isla|del gremio de los Tejedores" - (EN) "One you won't find in a book|The one about Weavers|guild island"
    u8 response = choice_dialog(&choices[ACT1_CHOICE1][0]); // (ES) "¿Los Tejedores?" - (EN) "The Weavers?", (ES) "Era mi leyenda favorita" - (EN) "It was my favourite legend", (ES) "¿Qué pasó con ellos?" - (EN) "What happened to them?"
    dprintf(2,"Response: %d\n",response);
    talk_dialog(&dialogs[ACT1_DIALOG2][12+response]); // Response texts:
    // If response=0: (ES) "Según la leyenda Fueron un gremio capaz de tejer hechizos" - (EN) "According to the legend They were a guild able to weave spells"
    // If response=1: (ES) "Para él no era una leyenda Los Pastores la cantaban como cierta" - (EN) "That was no legend for him Shepherds sang it as a fact"
    // If response=2: (ES) "Desaparecieron sin dejar rastro Aunque muchos creen que era solo un cuento" - (EN) "They vanished without a trace Although many believe it was just a tale"
    talk_dialog(&dialogs[ACT1_DIALOG2][15]); // (ES) "Tu padre quería encontrar|la isla donde vivían" - (EN) "Your father wanted to find|their home island"
    talk_dialog(&dialogs[ACT1_DIALOG2][16]); // (ES) "Nuestro destino es|documentar hechos,|no perseguirlos" - (EN) "Our destiny is to|document facts,|not to chase them"
    talk_dialog(&dialogs[ACT1_DIALOG2][17]); // (ES) "Linus tiene diecisiete años|Esa era mi edad cuando|viajé por el mundo" - (EN) "Linus is seventeen|That was my age when|I traveled the world"
    talk_dialog(&dialogs[ACT1_DIALOG2][18]); // (ES) "Y la edad de su padre cuando|llegó aquí" - (EN) "And his father's age when|he came to us"
    talk_dialog(&dialogs[ACT1_DIALOG2][19]); // (ES) "Un año antes de que|le acogiéramos|como uno de los nuestros" - (EN) "A year before we|took him as one of ours"
    talk_dialog(&dialogs[ACT1_DIALOG2][20]); // (ES) "Madre..." - (EN) "Mother..."
    response = choice_dialog(&choices[ACT1_CHOICE1][1]); // (ES) "Tengo que ir a la isla" - (EN) "I have to go to the island", (ES) "¿Vendrías conmigo?" - (EN) "Would you come with me?"
    look_left(CHR_clio, false);
    talk_dialog(&dialogs[ACT1_DIALOG2][21+response]); // Response texts:
    // If response=0: (ES) "Si Xander lo quiere, así será Pero no irás solo" - (EN) "If Xander wants it that way, so it will be But you'll not go alone"
    // If response=1: (ES) "Nunca me ha gustado viajar Pero no dejaré que vayas solo" - (EN) "I've never liked to travel But I won't let you go alone"
    
    wait_seconds(2);

    end_level(); // Free resources
    current_scene=5; // Next scene
}

void act_1_scene_5(void)    // Combat tutorial scene with pattern demonstrations
{
    // Initialize level
    new_level(&forest_bg_tile, &forest_bg_map, &forest_front_tile, &forest_front_map, forest_dark_pal, 1440, BG_SCRL_USER_RIGHT, 3);
    set_limits(0,134,275,172);

    // Initialize items
    init_item(0, &item_forest_fg1_sprite, PAL0, 260, 176-16, 0, 0, 0, 0, FORCE_FOREGROUND); // Rock 1
    init_item(1, &item_forest_fg5_sprite, PAL0, 180, 0, 0, 0, 0, 0, FORCE_FOREGROUND); // Tree (vertical)
    init_item(2, &item_forest_fg2_sprite, PAL0, 440, 176-24, 0, 0, 0, 0, FORCE_FOREGROUND); // Rock 2
    init_item(3, &item_forest_fg3_sprite, PAL0, 880, 176-16, 0, 0, 0, 0, FORCE_FOREGROUND); // Rock 3
    init_item(4, &item_forest_fg4_sprite, PAL0, 1400, 176-72, 0, 0, 0, 0, FORCE_FOREGROUND); // Tree (big)
    init_item(5, &item_forest_fg1_sprite, PAL0, 1050, 176-16, 0, 0, 0, 0, FORCE_FOREGROUND); // Rock 1
    init_item(6, &item_forest_fg5_sprite, PAL0, 1270, 0, 0, 0, 0, 0, FORCE_FOREGROUND); // Tree (vertical)
    
    // Initialize characters
    player_has_rod=true; // Give player the rod
    init_character(CHR_linus);
    init_character(CHR_clio);
    active_character=CHR_linus;
    move_character_instant(CHR_linus, -30, 154);
    move_character_instant(CHR_clio, -30, 154);
    follow_active_character(CHR_clio, true, 2);

    // Initialize spells
    // obj_pattern[PTRN_ELECTRIC].active=true;
    // obj_pattern[PTRN_HIDE].active=true;
    // obj_pattern[PTRN_OPEN].active=true;
    // obj_pattern[PTRN_SLEEP].active=true;

    // Dialog
    move_character(CHR_linus, 30, 154);
    //talk_dialog(&dialogs[ACT1_DIALOG3][0]); // (ES) "Algún tiempo después" - (EN) "Some time later"
    //talk_dialog(&dialogs[ACT1_DIALOG3][1]); // (ES) "Se aproximan enemigos|Tenemos que estar atentos|Quédate cerca, madre" - (EN) "Enemies are approaching|We have to stay alert|Stay close, mother"
    ////talk_dialog(&dialogs[ACT1_DIALOG3][11]); // (ES) "NOTA: Ni esta escena ni estos|gráficos estarán en el|juego cuando esté terminado" - (EN) "NOTE: Neither that scene nor those|graphics will be present|in the game when it's finished"
    ////talk_dialog(&dialogs[ACT1_DIALOG3][12]); // (ES) "Se ha decidido incluirla|en esta demo técnica|como prueba de ciertas mecánicas" - (EN) "It's been decided to include it|in this technical demo|as a test of certain mechanics"
    //talk_dialog(&dialogs[ACT1_DIALOG3][13]); // (ES) "Pulsa START para ver|tu inventario de hechizos" - (EN) "Press START to view|your spell inventory"

    // Fade to day palette
    PAL_fadeTo(0, 15, forest_pal.data, SCREEN_FPS, false);

    // Show the interface and allow character to move and play patterns
    player_scroll_active=true;
    movement_active=true;
    interface_active=true;
    player_patterns_enabled=true;
    show_or_hide_interface(true);

    while (offset_BGA<230) {
        next_frame(true);
    }

    // COMBAT SCENE
    show_or_hide_interface(false);

    // Initialize enemies
    PAL_setPalette(PAL3, weaver_ghost_sprite.palette->data, DMA); // Enemy palette

    // init_enemy(0,ENEMY_CLS_3HEADMONKEY);
    // move_enemy_instant(0, -20, 156);
    // move_character(CHR_linus, 200, 144);
    // move_enemy(0, 20, 156);
    // show_or_hide_interface(true);
    // start_combat(true);
    // while (is_combat_active==true) {
    //     next_frame(true);
    // }

    anim_character(active_character, ANIM_IDLE);
    reset_character_animations();
    // init_enemy(0,ENEMY_CLS_WEAVERGHOST);
    // init_enemy(1,ENEMY_CLS_WEAVERGHOST);
    // move_enemy_instant(0, 350, 176);
    // move_enemy_instant(1, -20, 156);
    // move_enemy(0, 250, 136);
    // move_enemy(1, 20, 156);
    show_or_hide_interface(true);
    // start_combat(true);
    // while (is_combat_active==true) {
    //     // Actualizar las máquinas de estado en combate
    //     combat_update();
        
    //     next_frame(true);
    // }

    show_or_hide_interface(false);
    talk_dialog(&dialogs[ACT1_DIALOG3][10]); // (ES) "¡Esto es todo!|(por ahora)" - (EN) "That's all!|(by now)"
    talk_dialog(&dialogs[ACT1_DIALOG3][5]); // (ES) "Gracias por probar la demo técnica|Sígueme por X para estar al día|@GeeseBumpsGames" - (EN) "Thtanks for testing our tech demo|Follow me in X for updates|@GeeseBumpsGames"
    talk_dialog(&dialogs[ACT1_DIALOG3][7]); // (ES) "Apaga tu consola|y haz algo constructivo|como jugar un poco al frontón" - (EN) "Turn off your console|and do something constructive|like play a little racquetball"
    talk_dialog(&dialogs[ACT1_DIALOG3][8]); // (ES) "o preparar la cena,|o organizar tu cajón de calcetines|alfabéticamente." - (EN) "or cook dinner,|or organize your sock drawer|alphabetically."
    PAL_fadeOutAll(120,false);

    SYS_hardReset(); // Reset and start again
}




================================================================
End of Codebase
================================================================
